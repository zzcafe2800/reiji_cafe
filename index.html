<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ゲームカフェ 飲食疑似提供サイト（改良版 v2）</title>
<style>
  :root{
    --bg:#f7efe7; --accent:#b33; --paper:#fff8ef; --dark:#3a2b20; --muted:#8b6d5c;
    --card-skin:#fff2e6;
  }
  html,body{height:100%;margin:0;font-family: "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background:linear-gradient(180deg,#fdf2ea 0%,#f7efe7 100%);}
  .container{max-width:1000px;margin:12px auto;padding:12px;background:var(--paper);box-shadow:0 6px 20px rgba(0,0,0,0.12);border-radius:10px;border:6px solid #b33;position:relative;min-height:700px;}
  header{display:flex;align-items:center;justify-content:space-between;padding:6px 12px;color:var(--dark);}
  h1{margin:0;font-size:18px;}
  /* layout simplified: single-column center for home; staff takes full screen */
  main.app{display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px;}
  .center-top{background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:8px;border:2px solid #f0c6c6;font-weight:700;color:var(--dark);text-align:center;width:100%;max-width:760px;}
  .order-area{display:flex;flex-direction:column;align-items:center;gap:12px;width:100%;max-width:760px;}
  .order-btn{background:linear-gradient(180deg,#ffd4c4,#ffb38a);border:4px solid #b33;color:var(--dark);padding:28px 48px;border-radius:12px;font-size:36px;cursor:pointer;box-shadow:0 6px 0 #913;user-select:none;}
  .order-btn.disabled{opacity:0.35;cursor:not-allowed;box-shadow:none;}
  .small-pass{position:fixed;left:12px;bottom:12px;background:rgba(255,255,255,0.95);padding:6px;border-radius:6px;border:1px dashed #c66;display:flex;align-items:center;gap:6px;z-index:50;}
  .small-pass input{width:100px;padding:4px;}
  .status-text{margin-top:6px;font-size:14px;color:var(--muted);text-align:center;}
  .footer-note{font-size:12px;color:var(--muted);text-align:center;margin-top:6px;}
  .right-bottom-small{position:fixed;right:12px;bottom:12px;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;border:1px solid #e6d0c6;font-size:13px;}
  /* staff full screen */
  .staff-full{position:fixed;inset:0;background:var(--paper);z-index:80;padding:18px;overflow:auto;}
  .staff-header{display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid #e6d0c6;padding-bottom:8px;margin-bottom:8px;}
  .big-toggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .big-toggle button{flex:1;padding:12px;border-radius:8px;font-size:16px;border:2px solid #c6b3b3;cursor:pointer;}
  .big-toggle .on{background:#2b8f4a;color:#fff;border-color:#2b8f4a;}
  .big-toggle .off{background:#f0f0f0;color:#666;}
  .panel{background:var(--paper);padding:10px;border-radius:8px;border:1px solid #e6d6cc;margin-bottom:8px;}
  .order-list{max-height:300px;overflow:auto;}
  .order-item{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;justify-content:space-between;align-items:center;}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:120;}
  .modal{background:#fff;padding:16px;border-radius:10px;width:760px;max-width:95%;box-shadow:0 8px 30px rgba(0,0,0,0.4);border:6px solid #b33;}
  .menu-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;}
  .menu-item{padding:8px;border:2px solid #e0bdb5;background:#fff;border-radius:8px;text-align:center;cursor:pointer;}
  img.menu-thumb{width:100%;height:120px;object-fit:cover;border-radius:6px;}
  /* art / card */
  .art-area{position:relative;width:240px;height:240px;border-radius:6px;overflow:hidden;border:1px solid #d4c0b8;background:#b36e3c;}
  .art-area canvas{position:absolute;left:0;top:0;width:240px;height:240px;}
  .card-canvas{border:1px solid #e6d0c6;background:var(--card-skin);border-radius:8px;}
  /* status overlay for customer */
  .status-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:130;flex-direction:column;color:#111;}
  .status-card{width:80%;max-width:720px;background:rgba(255,255,255,0.98);padding:36px;border-radius:12px;border:4px solid #b33;text-align:center;font-size:26px;font-weight:700;}
  .status-small{font-size:12px;color:#666;margin-top:8px;}
  /* responsive */
  @media (max-width:640px){
    .order-btn{padding:20px 32px;font-size:28px;}
    .modal{width:95%;}
    .container{margin:6px;padding:8px;}
    .center-top{font-size:14px;}
    .status-card{font-size:20px;padding:24px;}
  }
</style>
</head>
<body>
<div class="container" id="appContainer">
  <header><h1>ゲームカフェ 飲食疑似提供サイト</h1><div class="small-info">現在時刻: <span id="nowtime">--:--:--</span></div></header>

  <main class="app" id="homeMain">
    <div class="center-top" id="globalStatus">注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div>

    <div class="order-area">
      <div id="shiftSummaryText" class="status-text">スタッフシフト情報はここに表示されます（簡潔）</div>

      <button id="orderBtn" class="order-btn disabled">注文</button>

      <div id="statusHint" class="status-text">現在の状態はここに表示されます</div>
    </div>

    <div class="footer-note">プロトタイプ — モバイル縦画面対応</div>
  </main>

  <div class="right-bottom-small" id="guestSmallCard">
    <div>あなたは現在：客</div>
    <div class="small-info">左下にスタッフ用パスワード欄。スタッフは「1232」で入室。</div>
  </div>

  <div class="small-pass" id="passBox">
    <label style="font-size:12px;margin:0">スタッフパスワード</label>
    <input id="staffPass" placeholder="小さい" />
    <button id="passOk" class="small">OK</button>
  </div>
</div>

<!-- Staff full-screen UI (hidden by default) -->
<div id="staffFull" class="staff-full hidden" aria-hidden="true">
  <div class="staff-header">
    <div>
      <h2>スタッフモード</h2>
      <div id="staffBadge">---</div>
    </div>
    <div>
      <button id="logoutStaff" class="small">退室</button>
    </div>
  </div>

  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div>
        <div>シフト設定</div>
        <div style="display:flex;gap:8px;margin-top:6px;">
          <input type="time" id="shiftStart" />
          <input type="time" id="shiftEnd" />
          <button id="saveShift" class="small">保存</button>
        </div>
      </div>
      <div style="width:280px;">
        <div>モード</div>
        <div class="big-toggle">
          <button id="shiftBtn" class="on">シフト中</button>
          <button id="breakBtn" class="off">休憩中</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <strong>現在のスタッフ一覧（重複は自動整理）</strong>
    <div id="shiftList" style="margin-top:8px;"></div>
  </div>

  <div class="panel">
    <strong>スタッフ用 注文一覧 <span id="incompleteJobs" style="font-size:12px;color:#b33;margin-left:8px;"></span></strong>
    <div id="staffOrderList" class="order-list" style="margin-top:8px;"></div>
  </div>

  <!-- Make Latte Modal embedded inside staffFull for convenience -->
  <div id="makeAreaPanel" class="panel hidden" style="margin-top:12px;" aria-hidden="true">
    <h3 id="makeTitle">制作画面</h3>
    <div style="display:flex;gap:12px;flex-wrap:wrap;">
      <div style="flex:1;min-width:280px;">
        <div style="width:180px;height:180px;border-radius:12px;background:#fff8f2;display:flex;align-items:center;justify-content:center;border:2px solid #d2b6ab;">
          <canvas id="latteCanvas" width="120" height="120"></canvas>
        </div>

        <div style="margin-top:8px;">
          <label>エスプレッソ注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startEsp" class="small">注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="espBar" style="height:100%;width:0%;background:linear-gradient(90deg,#a7552b,#6b3);"></div>
                </div>
                <div style="position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;">
                  <div id="espMarkLow" style="position:absolute;left:95%;top:0;bottom:0;width:2px;background:rgba(255,255,255,0.9);transform:translateX(-1px);"></div>
                  <div id="espMarkHigh" style="position:absolute;left:105%;top:0;bottom:0;width:2px;background:rgba(255,255,255,0.9);transform:translateX(-1px);"></div>
                </div>
              </div>
              <div id="espPct" style="width:44px;text-align:right;font-weight:700;">0%</div>
            </div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label>フームドミルク注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startMilk" class="small" disabled>注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="milkBar" style="height:100%;width:0%;background:linear-gradient(90deg,#fff,#eee);"></div>
                </div>
                <div style="position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;">
                  <div id="milkMarkLow" style="position:absolute;left:95%;top:0;bottom:0;width:2px;background:rgba(0,0,0,0.6);transform:translateX(-1px);"></div>
                  <div id="milkMarkHigh" style="position:absolute;left:105%;top:0;bottom:0;width:2px;background:rgba(0,0,0,0.6);transform:translateX(-1px);"></div>
                </div>
              </div>
              <div id="milkPct" style="width:44px;text-align:right;font-weight:700;">0%</div>
            </div>
          </div>
        </div>
      </div>

      <div style="width:360px;min-width:260px;">
        <div style="background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>ラテアート（白ペン）</strong>
          <div style="margin-top:8px;">
            <div class="art-area" id="artArea">
              <canvas id="artBg" width="240" height="240"></canvas>
              <canvas id="artLayer" width="240" height="240"></canvas>
            </div>
            <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
              <label>ツール</label>
              <select id="penMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
              <label>サイズ</label>
              <select id="penSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
              <button id="clearArt" class="small">キャンバスクリア</button>
            </div>
            <div style="margin-top:8px;text-align:right;">
              <button id="saveArt" class="btn-green" disabled>アート保存</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>メッセージカード（手書き）</strong>
          <div style="margin-top:6px;">
            <canvas id="cardCanvas" class="card-canvas" width="320" height="120"></canvas>
          </div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
            <label>ツール</label>
            <select id="cardMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="cardSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="clearCard" class="small">消す</button>
          </div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveCard" class="small" disabled>カード保存</button>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px;align-items:center;">
          <div id="incompleteSmall" style="font-size:12px;color:#b33;"></div>
          <button id="completeMake" class="btn-red" disabled>提供する（完了）</button>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Modals for guest menu & served view -->
<div id="modalName" class="modal-back hidden"><div class="modal"><h3>注文者の名前を入力</h3><input id="orderName" placeholder="名前を入力" /><div style="margin-top:10px;text-align:right;"><button id="cancelOrderName" class="small">キャンセル</button><button id="okOrderName" class="btn-red">決定</button></div></div></div>

<div id="modalMenu" class="modal-back hidden"><div class="modal"><h3>メニューを選択</h3><div class="menu-grid" id="menuGrid"></div><div style="margin-top:10px;text-align:right;"><button id="backMenu" class="small">戻る</button></div></div></div>

<div id="modalEat" class="modal-back hidden"><div class="modal"><h3>飲食画面</h3><div style="display:flex;gap:12px;"><div style="flex:1;"><div style="width:320px;height:240px;border:1px solid #d4c0b8;border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;position:relative;"><img id="servedImage" src="" style="max-width:100%;max-height:100%;border-radius:8px;"></div><div style="margin-top:8px;display:flex;gap:6px;align-items:center;"><button id="eatNext" class="small">食べる（次へ）</button><div id="eatSoundInfo" class="small-info">クリックで rate.mp3 を順に再生します</div></div></div><div style="width:200px;"><div style="border:1px solid #e2cfc8;padding:8px;border-radius:8px;background:#fff7f3;"><strong>メッセージカード</strong><div id="servedCard" style="margin-top:8px;background:var(--card-skin);padding:8px;border-radius:6px;border:1px solid #e6d0c6;min-height:120px;"></div><div style="margin-top:8px;text-align:right;"><button id="saveImageBtn" class="small">画像保存</button><button id="homeFromEat" class="small">ホームへ</button></div></div></div></div></div></div>

<!-- overlay for client status -->
<div id="orderStatusOverlay" class="status-overlay hidden"><div class="status-card" id="orderStatusCard"></div><div class="status-small" id="orderStatusSmall">① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div></div>

<script type="module">
/* Full updated app script implementing requested features */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
import { getFirestore, collection, doc, onSnapshot, addDoc, updateDoc, deleteDoc, getDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";
import { getStorage, ref as storageRef, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyCNm1bmsVG4uZIJaL-bwbIcLCghzJ-ejvM",
  authDomain: "reiji-cafr.firebaseapp.com",
  projectId: "reiji-cafr",
  storageBucket: "reiji-cafr.firebasestorage.app",
  messagingSenderId: "18020287382",
  appId: "1:18020287382:web:1a87e6378598697ea3d3b7",
  measurementId: "G-F35S7FGW9M"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);
signInAnonymously(auth).catch(e=>console.warn('anon sign-in failed', e));

// DOM refs (many)
const nowtime = document.getElementById('nowtime');
const orderBtn = document.getElementById('orderBtn');
const passOk = document.getElementById('passOk');
const staffPassInput = document.getElementById('staffPass');
const guestSmallCard = document.getElementById('guestSmallCard');
const shiftSummaryText = document.getElementById('shiftSummaryText');
const statusHint = document.getElementById('statusHint');
const orderStatusOverlay = document.getElementById('orderStatusOverlay');
const orderStatusCard = document.getElementById('orderStatusCard');
const orderStatusSmall = document.getElementById('orderStatusSmall');

const modalName = document.getElementById('modalName');
const modalMenu = document.getElementById('modalMenu');
const modalEat = document.getElementById('modalEat');
const orderName = document.getElementById('orderName');
const cancelOrderName = document.getElementById('cancelOrderName');
const okOrderName = document.getElementById('okOrderName');
const menuGrid = document.getElementById('menuGrid');

const modalMakeArea = document.getElementById('makeAreaPanel'); // inside staffFull
const staffFull = document.getElementById('staffFull');
const logoutStaff = document.getElementById('logoutStaff');
const staffBadge = document.getElementById('staffBadge');
const shiftStart = document.getElementById('shiftStart');
const shiftEnd = document.getElementById('shiftEnd');
const saveShift = document.getElementById('saveShift');
const shiftList = document.getElementById('shiftList');
const shiftBtn = document.getElementById('shiftBtn');
const breakBtn = document.getElementById('breakBtn');
const staffOrderList = document.getElementById('staffOrderList');
const incompleteJobs = document.getElementById('incompleteJobs');

const startEsp = document.getElementById('startEsp');
const espBar = document.getElementById('espBar');
const espPct = document.getElementById('espPct');
const startMilk = document.getElementById('startMilk');
const milkBar = document.getElementById('milkBar');
const milkPct = document.getElementById('milkPct');
const latteCanvas = document.getElementById('latteCanvas');
const latteCtx = latteCanvas.getContext('2d');

const artBg = document.getElementById('artBg');
const artLayer = document.getElementById('artLayer');
const artBgCtx = artBg.getContext('2d');
const artLayerCtx = artLayer.getContext('2d');
const penMode = document.getElementById('penMode');
const penSize = document.getElementById('penSize');
const clearArt = document.getElementById('clearArt');
const saveArt = document.getElementById('saveArt');

const cardCanvas = document.getElementById('cardCanvas');
const cardCtx = cardCanvas.getContext('2d');
const cardMode = document.getElementById('cardMode');
const cardSize = document.getElementById('cardSize');
const clearCard = document.getElementById('clearCard');
const saveCard = document.getElementById('saveCard');

const completeMake = document.getElementById('completeMake');
const incompleteSmall = document.getElementById('incompleteSmall');

const servedImage = document.getElementById('servedImage');
const servedCard = document.getElementById('servedCard');
const eatNext = document.getElementById('eatNext');
const saveImageBtn = document.getElementById('saveImageBtn');
const homeFromEat = document.getElementById('homeFromEat');

const statusSmall = document.getElementById('orderStatusSmall');
const startArea = document.getElementById('homeMain');

// audio assets (GitHub raw)
function getAssetUrl(path){ if (!path) return ''; if (path.startsWith('@')) return 'https://raw.githubusercontent.com/' + path.slice(1); try{ return new URL(path).href }catch(e){ return path; } }
const audioTyaimu = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/tyaimu.mp3'));
const audioCookbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/cookbgm.mp3'));
const audioRate = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/rate.mp3'));

// menu
const menuItems = [{ id:'latte', title:'カフェラテ', imageBase:'@zzcafe2800/reiji_cafe/main/rate' }];

// state
const state = { staffs:[], orders:[], currentUser:{role:'guest', staffId:null}, clientOrderId:null, makingOrderId:null };

// Firestore refs
const staffsCol = collection(db,'staffs');
const ordersCol = collection(db,'orders');

// utilities
function uid(p='id'){ return p + Math.random().toString(36).slice(2,9); }
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function nowISO(){ return new Date().toISOString(); }

// responsive: hide right panel from earlier design: already removed

// --- Firestore realtime: staffs with duplicate-name cleanup ---
try {
  const qS = query(staffsCol, orderBy('createdAt','asc'));
  onSnapshot(qS, async snap => {
    const docs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    // group by name
    const byName = {};
    docs.forEach(d=> {
      const name = (d.name || '').trim();
      if (!byName[name]) byName[name]=[];
      byName[name].push(d);
    });
    // for any name with >1, keep newest (by createdAt) and delete older
    for(const name in byName){
      const arr = byName[name];
      if (name === '') continue;
      if (arr.length > 1){
        arr.sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
        const keep = arr[0];
        const toDelete = arr.slice(1);
        for(const d of toDelete){
          try { await deleteDoc(doc(db,'staffs',d.id)); } catch(e){ /* may lack permission - but local state will be deduped below */ }
        }
      }
    }
    // update local state after attempted deletions
    state.staffs = (await Promise.resolve(snap.docs.map(d=>({ id:d.id, ...d.data() })))).map(s=>({ ...s, onShift: !!s.onShift, breaking: !!s.breaking, shiftStart: s.shiftStart||'09:00', shiftEnd: s.shiftEnd||'17:00' }));
    renderStaffList();
    updateOrderButtonState();
  }, err => console.warn('staffs snapshot error', err));
} catch(e){ console.warn('attach staffs snapshot failed', e); }

// orders snapshot with automatic pruning after 5 minutes
try {
  const qO = query(ordersCol, orderBy('createdAt','asc'));
  onSnapshot(qO, async snap => {
    state.orders = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    // auto delete orders older than 5 min (createdAt)
    const now = Date.now();
    for(const o of state.orders){
      const c = o.createdAt || 0;
      if (now - c > 5*60*1000){
        try { await deleteDoc(doc(db,'orders', o.id)); } catch(e){ /* ignore */ }
      }
    }
    renderOrderLists();
    updateClientOverlay();
  }, err => console.warn('orders snapshot error', err));
} catch(e){ console.warn('attach orders snapshot failed', e); }

// periodic UI time
setInterval(()=>{ nowtime.textContent = new Date().toLocaleTimeString(); },1000);

// build menu
async function buildMenu(){
  menuGrid.innerHTML = '';
  for(const it of menuItems){
    const div = document.createElement('div'); div.className='menu-item'; div.dataset.id = it.id;
    const img = document.createElement('img'); img.className='menu-thumb';
    img.alt = it.title;
    const firstUrl = getAssetUrl(it.imageBase + '1.png');
    try { const res = await fetch(firstUrl); if (res.ok){ const blob=await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = placeholder(it.title); } catch(e){ img.src = placeholder(it.title); }
    div.appendChild(img);
    const h = document.createElement('strong'); h.textContent = it.title; div.appendChild(h);
    div.addEventListener('click', ()=> onMenuSelect(it));
    menuGrid.appendChild(div);
  }
}
function placeholder(title){
  const c=document.createElement('canvas'); c.width=320;c.height=240; const ctx=c.getContext('2d'); ctx.fillStyle='#fff8ef'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#6b3b24'; ctx.beginPath(); ctx.arc(160,110,60,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText(title, 100,200); return c.toDataURL();
}
buildMenu().catch(()=>{});

// MODE: Guest order flow
passOk.addEventListener('click', ()=>{
  if (staffPassInput.value === '1232'){ // direct entry
    // show staff login overlay inside staffFull for simple UX
    // show staff full-screen and staffName input
    showStaffLogin();
  } else alert('パスワードが違います');
});

function showStaffLogin(){
  // show staff overlay prompt for name
  const name = prompt('スタッフ名を入力してください');
  if (!name) return;
  addStaff(name);
}

// add staff doc
async function addStaff(name){
  try {
    const ref = await addDoc(staffsCol, { name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() });
    // switch to staff full view
    enterStaffMode(ref.id, name);
  } catch(e){
    // fallback local
    const id = uid('s');
    state.staffs.push({ id, name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() });
    enterStaffMode(id, name);
  }
}

function enterStaffMode(id, name){
  state.currentUser.role = 'staff';
  state.currentUser.staffId = id;
  staffBadge.textContent = name;
  // hide home and show staff full-screen
  document.getElementById('appContainer').style.display = 'none';
  staffFull.classList.remove('hidden');
  document.body.scrollTop = 0;
  renderStaffList();
  renderOrderLists();
}

// logout staff
logoutStaff.addEventListener('click', async ()=>{
  const id = state.currentUser.staffId;
  if (id){
    try { await deleteDoc(doc(db,'staffs',id)); } catch(e){ /* ignore */ }
  }
  state.currentUser = { role:'guest', staffId:null };
  staffFull.classList.add('hidden');
  document.getElementById('appContainer').style.display = 'block';
});

// build shifts display (concise) and dedupe (server attempted deletion already)
function renderStaffList(){
  shiftList.innerHTML = '';
  const now = new Date();
  state.staffs.forEach(s=>{
    const d = document.createElement('div');
    const onNow = isNowWithinShift(s.shiftStart,s.shiftEnd, now);
    d.innerHTML = `<strong>${escapeHtml(s.name)}</strong> ${s.shiftStart||''}〜${s.shiftEnd||''} ${s.onShift?'<span style="color:green">シフト中</span>':'<span style="color:gray">-</span>'} ${s.breaking?'<span style="color:orange">休憩中</span>':''} ${onNow?'<span style="small-info">（現在この時間）</span>':''}`;
    shiftList.appendChild(d);
  });

  // also update concise top text on home for guests: show first current shift names
  const active = state.staffs.filter(s=> s.onShift && !s.breaking && isNowWithinShift(s.shiftStart, s.shiftEnd, now));
  if (active.length) shiftSummaryText.textContent = '対応可能: ' + active.map(s=>s.name).join(' / ');
  else shiftSummaryText.textContent = '現在対応可能なスタッフはいません';
}

// time check
function isNowWithinShift(start,end,dateObj){
  if (!start || !end) return false;
  const [sh,sm] = start.split(':').map(Number); const [eh,em] = end.split(':').map(Number);
  const sDate = new Date(dateObj); sDate.setHours(sh,sm,0,0);
  const eDate = new Date(dateObj); eDate.setHours(eh,em,0,0);
  if (eDate <= sDate) eDate.setDate(eDate.getDate()+1);
  return dateObj >= sDate && dateObj <= eDate;
}

// enable order button if any staff onShift and not breaking
function updateOrderButtonState(){
  const now = new Date();
  const anyAvailable = (state.staffs||[]).some(s=> s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if (anyAvailable){ orderBtn.classList.remove('disabled'); statusHint.textContent = 'スタッフ対応可能です。注文できます。'; }
  else { orderBtn.classList.add('disabled'); statusHint.textContent = '現在、スタッフ対応不可（シフト外／休憩中）'; }
}

// Order flow: guest press order
orderBtn.addEventListener('click', ()=>{
  if (orderBtn.classList.contains('disabled')) return;
  try { audioTyaimu.currentTime=0; audioTyaimu.play(); } catch(e){}
  showModal(modalName);
});
cancelOrderName.addEventListener('click', ()=> hideModal(modalName));
okOrderName.addEventListener('click', ()=> {
  const name = orderName.value.trim(); if (!name){ alert('名前を入力'); return; }
  hideModal(modalName);
  buildMenu(); showModal(modalMenu);
});

// show/hide modal helper
function showModal(m){ m.classList.remove('hidden'); }
function hideModal(m){ m.classList.add('hidden'); }

// when a menu item is selected
async function onMenuSelect(item){
  hideModal(modalMenu);
  const name = orderName.value.trim() || '名無し';
  const createdAt = Date.now(), expiresAt = createdAt + 5*60*1000;
  const orderObj = { name, item: item.id, state:'waiting', createdAt, expiresAt, assignedTo:null, assignedToName:null, artData:null, cardData:null, servedImageUrl:null };
  try {
    const ref = await addDoc(ordersCol, orderObj);
    state.clientOrderId = ref.id;
    showClientOverlay('現在対応待ち中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます');
    // schedule removal if not handled (server-side)
  } catch(e){
    console.warn('add order failed', e);
    orderObj.id = uid('o'); state.orders.push(orderObj);
    state.clientOrderId = orderObj.id;
    showClientOverlay('現在対応待ち中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます');
    renderOrderLists();
  }
}

// staff assign order
async function assignOrderToStaff(orderId){
  const staffId = state.currentUser.staffId; if (!staffId) { alert('スタッフとして入室してください'); return; }
  const s = state.staffs.find(x=>x.id===staffId);
  if (!s) return;
  try {
    await updateDoc(doc(db,'orders',orderId), { state:'inprogress', assignedTo: staffId, assignedToName: s.name });
    // stop any previous cook bgm? Start cook bgm for staff; clients hear conditionally (not implemented per-client)
    try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play(); } catch(e){}
    // now open make modal inside staffFull
    const snap = await getDoc(doc(db,'orders',orderId));
    openMake(orderId, snap.exists()?snap.data():null);
  } catch(e){
    console.warn('assign update failed', e);
  }
}

// render staff orders; also show incomplete jobs summary, remove orders older than 5min
function renderOrderLists(){
  staffOrderList.innerHTML = '';
  const now = Date.now();
  let incomplete = [];
  state.orders.forEach(o=>{
    if (!o) return;
    // auto-prune any orders older than 5 minutes
    if ((o.createdAt||0) + 5*60*1000 < now){
      try { deleteDoc(doc(db,'orders',o.id)); } catch(e){}
      return;
    }
    // show waiting & inprogress & done
    if (o.state === 'cancelled') return;
    const div = document.createElement('div'); div.className='order-item';
    const left = document.createElement('div');
    left.innerHTML = `<strong>${escapeHtml(o.name)}</strong><div class="small-info">${escapeHtml(o.item)} - 状態:${escapeHtml(o.state)} - 作成:${new Date(o.createdAt||0).toLocaleTimeString()}</div>`;
    const right = document.createElement('div');
    if (o.state === 'waiting'){
      const btn = document.createElement('button'); btn.textContent='対応'; btn.className='small btn-green';
      btn.onclick = ()=> assignOrderToStaff(o.id);
      right.appendChild(btn);
      incomplete.push(`${o.name} の注文対応待ち`);
    } else if (o.state === 'inprogress'){
      right.innerHTML = `<div class="small-info">担当:${escapeHtml(o.assignedToName||o.assignedTo||'')}</div>`;
      const doneBtn = document.createElement('button'); doneBtn.textContent='完成'; doneBtn.className='small'; doneBtn.onclick = async ()=>{
        try { await updateDoc(doc(db,'orders',o.id), { state:'done' }); } catch(e){ console.warn(e); }
      };
      right.appendChild(doneBtn);
    } else if (o.state === 'done'){
      // allow "提供" which opens make flow (should be immediate)
      const provideBtn = document.createElement('button'); provideBtn.textContent='提供'; provideBtn.className='small btn-green';
      provideBtn.onclick = ()=> openMake(o.id, o);
      right.appendChild(provideBtn);
    }
    div.appendChild(left); div.appendChild(right);
    staffOrderList.appendChild(div);
  });
  // show incomplete jobs summary small
  incompleteJobs.textContent = incomplete.length ? `未完了: ${incomplete.length}` : '';
  incompleteSmall.textContent = incomplete.length ? `未完了: ${incomplete.length}` : '';
  // update concise home shift text for guests
  renderStaffList(); updateOrderButtonState();
}

// Open Make UI inside staffFull (we use panel makeAreaPanel)
let makeOrderId = null;
function openMake(orderId, orderData){
  makeOrderId = orderId;
  modalMakeArea.classList.remove('hidden');
  // setup maker name
  const assignedName = (orderData && orderData.assignedToName) || (state.staffs.find(s=>s.id===state.currentUser.staffId)||{}).name || '';
  document.getElementById('makeTitle').textContent = `制作画面（担当: ${assignedName}）`;
  // reset canvases and pouring
  resetLatte(); initArt(); initCard();
  saveArt.disabled = true; saveCard.disabled = true; completeMake.disabled = true;
  updateIncompleteIndicator();
}

// update incomplete indicator text left of provide button
function updateIncompleteIndicator(){
  const parts = [];
  // check pouring: if esp or milk not done
  if (!espDone) parts.push('注ぎ未完了');
  if (!milkDone) parts.push('ミルク未完了');
  if (!artSaved) parts.push('アート未保存');
  if (!cardSaved) parts.push('カード未保存');
  incompleteSmall.textContent = parts.length ? parts.join(' / ') : '';
}

// --- Pouring implementation (95~105 success, 120 fail) ---
let espInterval=null, milkInterval=null, espDone=false, milkDone=false, artSaved=false, cardSaved=false;
function resetLatte(){
  clearInterval(espInterval); clearInterval(milkInterval); espInterval=null; milkInterval=null;
  espBar.style.width='0%'; milkBar.style.width='0%'; espPct.textContent='0%'; milkPct.textContent='0%';
  espDone=false; milkDone=false; artSaved=false; cardSaved=false;
  startEsp.disabled=false; startMilk.disabled=true;
  // draw base
  latteCtx.clearRect(0,0,latteCanvas.width,latteCanvas.height);
  latteCtx.fillStyle = '#6b3b24'; latteCtx.beginPath(); latteCtx.arc(60,60,58,0,Math.PI*2); latteCtx.fill();
}

function pourStart(barElem, pctElem){
  let pct=0;
  const interval = setInterval(()=>{
    pct = Math.min(130, pct + Math.random()*3 + 1.5);
    barElem.style.width = pct + '%';
    pctElem.textContent = Math.round(pct) + '%';
    // if exceed 120, immediate failure
    if (pct >= 120){
      clearInterval(interval);
      alert('注ぎ過ぎ！120% 到達で失敗しました。最初からやり直してください。');
      resetLatte();
      updateIncompleteIndicator();
    }
  }, 90);
  return interval;
}

startEsp.addEventListener('mousedown', ()=>{
  if (espInterval) return;
  startEsp.textContent='注ぎ中...';
  espInterval = pourStart(espBar, espPct);
});
startEsp.addEventListener('mouseup', ()=>{
  if (espInterval){ clearInterval(espInterval); espInterval=null; }
  startEsp.textContent='注ぐ（押し続け）';
  const pct = parseFloat(espBar.style.width)||0;
  if (pct >= 95 && pct <= 105){
    espDone = true; playTone(523,0.12);
    // draw espresso lower half
    latteCtx.fillStyle = '#5a2f1a'; latteCtx.fillRect(0,60,latteCanvas.width,60);
    startMilk.disabled = false;
  } else {
    alert('合格範囲外です。最初からやり直し。');
    resetLatte();
  }
  updateIncompleteIndicator();
});
startEsp.addEventListener('touchstart',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mousedown')); });
startEsp.addEventListener('touchend',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mouseup')); });

startMilk.addEventListener('mousedown', ()=>{
  if (milkInterval) return;
  startMilk.textContent='注ぎ中...';
  milkInterval = pourStart(milkBar, milkPct);
});
startMilk.addEventListener('mouseup', ()=>{
  if (milkInterval){ clearInterval(milkInterval); milkInterval=null; }
  startMilk.textContent='注ぐ（押し続け）';
  const pct = parseFloat(milkBar.style.width)||0;
  if (pct >= 95 && pct <= 105){
    milkDone = true; playTone(660,0.12);
    latteCtx.fillStyle = '#f6efe6'; latteCtx.beginPath(); latteCtx.arc(60,60,48,0,Math.PI*2); latteCtx.fill();
  } else {
    alert('合格範囲外です。最初からやり直し。');
    resetLatte();
  }
  updateIncompleteIndicator();
});
startMilk.addEventListener('touchstart',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mousedown')); });
startMilk.addEventListener('touchend',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mouseup')); });

// --- Art drawing (two-layer approach: background brown (artBg), strokes on artLayer only) ---
function initArt(){
  artBgCtx.clearRect(0,0,artBg.width,artBg.height);
  artBgCtx.fillStyle = '#6b3b24'; artBgCtx.beginPath(); artBgCtx.arc(120,120,100,0,Math.PI*2); artBgCtx.fill();
  artLayerCtx.clearRect(0,0,artLayer.width,artLayer.height);
  artLayerCtx.lineCap = 'round'; artLayerCtx.lineJoin='round';
  artSaved = false;
  saveArt.disabled = !(espDone && milkDone);
  updateIncompleteIndicator();
}
let artDrawing=false, artLast={x:0,y:0};
function artPos(e, canvas){ const r=canvas.getBoundingClientRect(); const t=e.touches?e.touches[0]:null; const cx=t? t.clientX:e.clientX; const cy=t? t.clientY:e.clientY; return { x:(cx-r.left)*(canvas.width/r.width), y:(cy-r.top)*(canvas.height/r.height) }; }
artLayer.addEventListener('mousedown',(e)=>{ if (!espDone || !milkDone) return; artDrawing=true; artLast = artPos(e, artLayer); });
artLayer.addEventListener('mousemove',(e)=>{ if(!artDrawing) return; const p=artPos(e, artLayer); drawArt(artLast,p); artLast=p; });
artLayer.addEventListener('mouseup',()=>{ artDrawing=false; artLayerCtx.globalCompositeOperation='source-over'; });
artLayer.addEventListener('mouseleave',()=>{ artDrawing=false; artLayerCtx.globalCompositeOperation='source-over'; });
artLayer.addEventListener('touchstart',(e)=>{ e.preventDefault(); if (!espDone || !milkDone) return; artDrawing=true; artLast=artPos(e,artLayer); });
artLayer.addEventListener('touchmove',(e)=>{ e.preventDefault(); if(!artDrawing) return; const p=artPos(e,artLayer); drawArt(artLast,p); artLast=p; });
artLayer.addEventListener('touchend',(e)=>{ e.preventDefault(); artDrawing=false; artLayerCtx.globalCompositeOperation='source-over'; });

function drawArt(from, to){
  const size = parseInt(penSize.value,10);
  const mode = penMode.value;
  if (mode === 'draw'){ artLayerCtx.globalCompositeOperation='source-over'; artLayerCtx.strokeStyle='#ffffff'; artLayerCtx.lineWidth=size; }
  else { artLayerCtx.globalCompositeOperation='destination-out'; artLayerCtx.lineWidth=size; }
  artLayerCtx.beginPath(); artLayerCtx.moveTo(from.x, from.y); artLayerCtx.lineTo(to.x, to.y); artLayerCtx.stroke();
}

clearArt.addEventListener('click', ()=> initArt());

saveArt.addEventListener('click', ()=>{
  if (!espDone || !milkDone){ alert('注ぎをクリアしてください'); return; }
  // Merge artLayer into latteCanvas (scale)
  const tmp = document.createElement('canvas'); tmp.width = latteCanvas.width; tmp.height = latteCanvas.height;
  const tctx = tmp.getContext('2d');
  // draw brown base
  tctx.fillStyle = '#6b3b24'; tctx.beginPath(); tctx.arc(60,60,58,0,Math.PI*2); tctx.fill();
  // draw artLayer scaled
  tctx.drawImage(artLayer, 0, 0, tmp.width, tmp.height);
  // copy to latteCanvas
  latteCtx.clearRect(0,0,latteCanvas.width,latteCanvas.height);
  latteCtx.drawImage(tmp,0,0);
  artSaved = true; saveArt.disabled = true; saveCard.disabled = false;
  updateIncompleteIndicator();
  alert('アート保存しました。次にカードを書いてください。');
});

// --- Card drawing ---
function initCard(){
  cardCtx.clearRect(0,0,cardCanvas.width, cardCanvas.height);
  cardCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin').trim() || '#fff2e6';
  cardCtx.fillRect(0,0,cardCanvas.width, cardCanvas.height);
  cardSaved = false;
  saveCard.disabled = true;
  updateIncompleteIndicator();
}
initCard();

let cardDrawing=false, cardLast={x:0,y:0};
function cardPos(e){ const r=cardCanvas.getBoundingClientRect(); const t=e.touches?e.touches[0]:null; const cx=t? t.clientX:e.clientX; const cy=t? t.clientY:e.clientY; return { x:(cx-r.left)*(cardCanvas.width/r.width), y:(cy-r.top)*(cardCanvas.height/r.height) }; }
cardCanvas.addEventListener('mousedown',(e)=>{ cardDrawing=true; cardLast=cardPos(e); });
cardCanvas.addEventListener('mousemove',(e)=>{ if(!cardDrawing) return; const p=cardPos(e); drawCard(cardLast,p); cardLast=p; });
cardCanvas.addEventListener('mouseup',()=>{ cardDrawing=false; cardCtx.globalCompositeOperation='source-over'; });
cardCanvas.addEventListener('mouseleave',()=>{ cardDrawing=false; cardCtx.globalCompositeOperation='source-over'; });
cardCanvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); cardDrawing=true; cardLast=cardPos(e); });
cardCanvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); if(!cardDrawing) return; const p=cardPos(e); drawCard(cardLast,p); cardLast=p; });
cardCanvas.addEventListener('touchend',(e)=>{ e.preventDefault(); cardDrawing=false; cardCtx.globalCompositeOperation='source-over'; });

function drawCard(from,to){
  const size = parseInt(cardSize.value,10);
  const mode = cardMode.value;
  if (mode === 'draw'){ cardCtx.globalCompositeOperation='source-over'; cardCtx.strokeStyle='#000'; cardCtx.lineWidth=size; }
  else { cardCtx.globalCompositeOperation='destination-out'; cardCtx.lineWidth=size; }
  cardCtx.beginPath(); cardCtx.moveTo(from.x, from.y); cardCtx.lineTo(to.x, to.y); cardCtx.stroke();
}
clearCard.addEventListener('click', ()=> initCard());
saveCard.addEventListener('click', ()=> { cardSaved=true; saveCard.disabled=true; completeMake.disabled = false; updateIncompleteIndicator(); alert('カード保存しました'); });

// --- complete provide: robust update (ensure state updated even if upload fails) ---
completeMake.addEventListener('click', async ()=>{
  if (!makeOrderId) { alert('対象注文がありません'); return; }
  const orderId = makeOrderId;
  // compose served image
  const tmp = document.createElement('canvas'); tmp.width=600; tmp.height=600;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff8ef'; tctx.fillRect(0,0,tmp.width,tmp.height);
  // draw cup
  tctx.drawImage(latteCanvas, 180,120,240,240);
  // draw card
  tctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin').trim() || '#fff2e6';
  tctx.fillRect(160,380,280,120);
  tctx.drawImage(cardCanvas, 170,390,260,100);
  const dataUrl = tmp.toDataURL('image/png');

  // Try to update order state to 'delivered' immediately to avoid "提供されない" bug
  try {
    await updateDoc(doc(db,'orders',orderId), { state:'delivered', deliveredAt: Date.now() });
  } catch(e){
    console.warn('set delivered failed (will continue):', e);
  }

  // attempt upload then update servedImageUrl
  try {
    const sRef = storageRef(storage, `served_images/${orderId}.png`);
    await uploadString(sRef, dataUrl, 'data_url');
    const url = await getDownloadURL(sRef);
    try { await updateDoc(doc(db,'orders',orderId), { servedImageUrl: url }); } catch(e){ console.warn('update servedImageUrl failed', e); }
    alert('提供しました（クラウド保存）');
  } catch(e){
    console.warn('upload failed - saving locally in document', e);
    try { await updateDoc(doc(db,'orders',orderId), { servedImageLocal: dataUrl }); } catch(e){ console.warn('local save to doc failed', e); }
    alert('提供しました（ローカル保存）');
  } finally {
    // cleanup: hide make panel, stop cook bgm
    modalMakeArea.classList.add('hidden'); makeOrderId = null;
    try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
    // schedule deletion after 5 minutes
    setTimeout(async ()=>{ try{ await deleteDoc(doc(db,'orders',orderId)); } catch(e){} }, 5*60*1000);
  }
});

// --- Customer overlay: update based on order state in snapshot ---
function showClientOverlay(largeText, smallText){
  orderStatusCard.textContent = largeText;
  orderStatusSmall.textContent = smallText || '① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます';
  orderStatusOverlay.classList.remove('hidden');
}
function hideClientOverlay(){ orderStatusOverlay.classList.add('hidden'); }

// update overlay when orders change for clientOrderId
function updateClientOverlay(){
  if (!state.clientOrderId) return;
  const o = state.orders.find(x=>x.id===state.clientOrderId);
  if (!o) return;
  if (o.state === 'waiting'){ showClientOverlay('現在対応待ち中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます'); }
  else if (o.state === 'inprogress'){ showClientOverlay('現在調理中…','① ���意：事故として必ずスタッフ（店員）が対応できない場合もございます'); }
  else if (o.state === 'done' || o.state === 'delivered'){ showClientOverlay('只今、運搬中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます'); }
  else if (o.state === 'cancelled'){ showClientOverlay('スタッフの応答がないため現在注文を取り消しになります','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます'); setTimeout(()=>{ hideClientOverlay(); state.clientOrderId=null; },10000); }
}

// served view (guest)
function showServed(orderId){
  const o = state.orders.find(x=>x.id===orderId);
  if (!o) return;
  servedImage.src = o.servedImageUrl || o.servedImageLocal || placeholder('Cafe Latte');
  servedCard.innerHTML = `<div style="font-size:14px;white-space:pre-wrap;">${escapeHtml(o.cardData||'')}</div>`;
  document.getElementById('modalEat').classList.remove('hidden');
  let clicks=0;
  eatNext.onclick = ()=>{
    clicks++;
    if (clicks===1){ servedImage.style.filter='grayscale(20%)'; try{ audioRate.currentTime=0; audioRate.play(); } catch(e){}; }
    else if (clicks===2){ servedImage.style.filter='grayscale(50%)'; try{ audioRate.currentTime=0; audioRate.play(); } catch(e){}; }
    else { servedImage.style.filter='grayscale(100%)'; eatNext.disabled=true; }
  };
  saveImageBtn.onclick = ()=> { const a=document.createElement('a'); a.href = servedImage.src; a.download = `served_${o.id}.png`; a.click(); };
  homeFromEat.onclick = ()=> document.getElementById('modalEat').classList.add('hidden');
}

// --- Utility tone ---
function playTone(freq=440,dur=0.12){ try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination); g.gain.value=0.12; o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, dur*1000); } catch(e){} }

// --- onSnapshot rendering and housekeeping for guests/staff ---
function renderOrderLists(){
  // update staff list rendering (if staff full visible)
  renderOrderListsForStaff();
  // update guest concise lists: show if any delivered etc on bottom small card maybe
  // For simplicity update client overlay above
  updateClientOverlay();
}

function renderOrderListsForStaff(){
  staffOrderList.innerHTML = '';
  const now = Date.now();
  // filter and display waiting/inprogress/done
  const ordersSorted = (state.orders || []).slice().sort((a,b)=> (a.createdAt||0)-(b.createdAt||0));
  const incomplete = [];
  ordersSorted.forEach(o=>{
    if (!o) return;
    // skip cancelled
    if (o.state === 'cancelled') return;
    // prune old >5min (already attempted delete on snapshot, but also local)
    if ((o.createdAt||0) + 5*60*1000 < now){
      try { deleteDoc(doc(db,'orders',o.id)); } catch(e){}
      return;
    }
    const div = document.createElement('div'); div.className = 'order-item';
    const left = document.createElement('div');
    left.innerHTML = `<strong>${escapeHtml(o.name)}</strong><div class="small-info">${escapeHtml(o.item)} - 状態:${escapeHtml(o.state)} - 作成:${new Date(o.createdAt||0).toLocaleTimeString()}</div>`;
    const right = document.createElement('div');
    if (o.state === 'waiting'){
      const btn = document.createElement('button'); btn.textContent='対応'; btn.className='small btn-green';
      btn.onclick = ()=> assignOrderToStaff(o.id);
      right.appendChild(btn);
      incomplete.push(`対応待ち: ${o.name}`);
    } else if (o.state === 'inprogress'){
      right.innerHTML = `<div class="small-info">担当:${escapeHtml(o.assignedToName || o.assignedTo || '')}</div>`;
      const doneBtn = document.createElement('button'); doneBtn.textContent='完成'; doneBtn.className='small';
      doneBtn.onclick = async ()=> { try{ await updateDoc(doc(db,'orders',o.id), { state:'done' }); } catch(e){ console.warn(e); } };
      right.appendChild(doneBtn);
    } else if (o.state === 'done'){
      const provideBtn = document.createElement('button'); provideBtn.textContent='提供'; provideBtn.className='small btn-green';
      provideBtn.onclick = ()=> openMake(o.id, o);
      right.appendChild(provideBtn);
    }
    div.appendChild(left); div.appendChild(right);
    staffOrderList.appendChild(div);
  });
  incompleteJobs.textContent = incomplete.length ? `未完了: ${incomplete.length}` : '未完了: 0';
  incompleteSmall.textContent = incomplete.length ? `未完了: ${incomplete.length}` : '';
}

// --- Helpers: show/hide modals implemented earlier with IDs ---
function hideModal(el){ if (!el) return; el.classList.add('hidden'); }
function showModal(el){ if (!el) return; el.classList.remove('hidden'); }

// build menu items click handler wiring
document.getElementById('backMenu').addEventListener('click', ()=> hideModal(modalMenu));
cancelOrderName.addEventListener('click', ()=> hideModal(modalName));
okOrderName.addEventListener('click', ()=> {
  if (!orderName.value.trim()){ alert('名前を入れてください'); return; }
  hideModal(modalName); showModal(modalMenu);
});

// menu item selection uses earlier onMenuSelect - we need to wire created menu items to onMenuSelect built earlier
async function populateMenu(){
  menuGrid.innerHTML = '';
  for(const it of menuItems){
    const el = document.createElement('div'); el.className='menu-item';
    const img = document.createElement('img'); img.className='menu-thumb'; img.alt = it.title;
    try { const res = await fetch(getAssetUrl(it.imageBase+'1.png')); if (res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = placeholder(it.title); } catch(e){ img.src = placeholder(it.title); }
    el.appendChild(img);
    el.appendChild(Object.assign(document.createElement('strong'),{textContent:it.title}));
    el.addEventListener('click', ()=> onMenuItemSelect(it));
    menuGrid.appendChild(el);
  }
}
populateMenu().catch(()=>{});

// onMenuItemSelect uses same order creation logic
async function onMenuItemSelect(item){
  hideModal(modalMenu);
  const name = orderName.value.trim() || '名無し';
  const createdAt = Date.now(), expiresAt = createdAt + 5*60*1000;
  const orderObj = { name, item:item.id, state:'waiting', createdAt, expiresAt, assignedTo:null, assignedToName:null, artData:null, cardData:null, servedImageUrl:null };
  try {
    const ref = await addDoc(ordersCol, orderObj);
    state.clientOrderId = ref.id;
    showClientOverlay('現在対応待ち中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます');
  } catch(e){
    console.warn('add order failed', e);
    orderObj.id = uid('o'); state.orders.push(orderObj);
    state.clientOrderId = orderObj.id;
    showClientOverlay('現在対応待ち中','① 注意：事故として必ずスタッフ（店員）が対応できない場合もございます');
    renderOrderLists();
  }
}

// Remove right-panel from home as requested (already removed) and put small guest card bottom-right (already present)

// Utility: placeholder used earlier
function placeholder(t){ const c=document.createElement('canvas'); c.width=320;c.height=240; const ctx=c.getContext('2d'); ctx.fillStyle='#fff8ef'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#6b3b24'; ctx.beginPath(); ctx.arc(160,110,60,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText(t, 100,200); return c.toDataURL(); }

// initial state update functions
function renderStaffListInitial(){ renderStaffList(); }
renderStaffListInitial();

// --- Accessibility / mobile tweaks handled by CSS above ---

// Expose debug
window.__reiji_state = state;

/*
  Note: This file performs server-side deletes (deleteDoc) when duplicates by name are detected.
  That requires the Firebase user to have permissions; in local dev without security rules allowing deletes, deletes may fail silently and UI will dedupe locally on next snapshot attempt.
*/

</script>
</body>
</html>
