
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>仮想飲食システム（完全版）</title>
<meta name="format-detection" content="telephone=no">

<style>
  :root{
    --bg:#f7efe7;
    --accent:#b33;
    --paper:#fff8ef;
    --dark:#3a2b20;
    --muted:#8b6d5c;
    --card-skin:#fff2e6;
  }

  html,body{
    height:100%;
    margin:0;
    font-family:"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
    background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/3739270_l.jpg") center center / cover no-repeat;
  }
  body{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .container{
    width:100%;
    max-width:420px;
    margin:0;
    position:relative;
    perspective:2000px;
    aspect-ratio:3/5;
  }
  .book{position:relative;width:100%;height:100%;}
  .page{position:absolute;inset:0;width:100%;height:100%;overflow:hidden;}
  .cover{
    background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/menuh1.png") center/cover no-repeat;
    transform-origin:right center;
    z-index:2;
    pointer-events:auto;
  }

  /* ✅ 開くモーション復活 */
  .cover.open{animation:flip 7.2s ease-in-out forwards;pointer-events:none;}
  .cover.open.finished{display:none;}

  .inner{
    position:absolute;inset:0;
    background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/menuh.png") center/cover no-repeat;
    box-shadow:0 6px 20px rgba(0,0,0,0.15);
    border-radius:10px;
    outline:6px solid var(--accent);
    outline-offset:-6px;
    z-index:1;
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }

  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:12px;
    color:var(--dark);
  }

  @keyframes flip{
    0%{transform:rotateY(0deg);box-shadow:0 20px 40px rgba(0,0,0,.25);}
    40%{transform:rotateY(-55deg);}
    70%{transform:rotateY(-130deg);}
    100%{transform:rotateY(-180deg);box-shadow:none;}
  }

  @media (min-width:768px){
    .container{width:94vw;margin:12px auto;aspect-ratio:3/5;}
  }

  .content{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:12px;
    padding:12px;
    position:relative;
    flex:1;
  }

  .order-block{
    width:100%;
    max-width:520px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }

  .status-line{
    font-weight:700;
    background:rgba(255,255,255,0.92);
    padding:8px 12px;
    border-radius:8px;
    border:2px solid #f0c6c6;
    text-align:center;
    width:100%;
    box-sizing:border-box;
  }

  .order-row{
    width:100%;
    display:flex;
    gap:8px;
    align-items:stretch;
    justify-content:center;
  }

  .order-btn{
    flex:1;
    background:linear-gradient(180deg,#ffd4c4,#ffb38a);
    border:4px solid var(--accent);
    color:var(--dark);
    padding:14px 18px;
    border-radius:12px;
    cursor:pointer;
    box-shadow:0 6px 0 #913;
    user-select:none;
    width:100%;
    max-width:160px;
    aspect-ratio:5/3;
    font-size:clamp(16px,4vw,30px);
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
  }
  .order-btn.disabled{opacity:0.4;cursor:not-allowed;box-shadow:none;}

  .offline-order{
    flex:0 0 33%;
    max-width:100px;
    aspect-ratio:5 / 3;
    background:linear-gradient(180deg,#ffe8de,#ffbfa5);
    border:3px dashed #e6b2a3;
    color:#5a2e1e;
    border-radius:14px;
    cursor:pointer;
    box-shadow:0 4px 0 #a35a42;
    font-size:12px;
    font-weight:800;
    line-height:1.2;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    user-select:none;
  }

  .small-pass{
    position:fixed;left:12px;bottom:12px;
    background:rgba(255,255,255,0.95);
    padding:6px;border-radius:6px;border:1px dashed #c66;
    display:flex;align-items:center;gap:6px;z-index:60;
  }
  .small-pass input{width:110px;padding:4px;}

  .guest-mini{
    position:fixed;right:12px;bottom:12px;
    background:var(--paper);padding:8px;border-radius:8px;border:1px solid #e6d6cc;
    font-size:13px;box-shadow:0 6px 12px rgba(0,0,0,0.08);z-index:60;
  }

  .small-info{font-size:12px;color:var(--muted);}
  .bgm-btn{
    font-size:12px;padding:6px 10px;border-radius:8px;
    background:rgba(255,255,255,0.95);
    border:1px solid #e6d0c6;cursor:pointer;
  }

  .btn-red{
    background:linear-gradient(180deg,#ff7b7b,#ff4f4f);
    color:#fff;border:none;border-radius:10px;padding:10px 14px;
    font-weight:800;cursor:pointer;
    box-shadow:0 4px 0 #a22;
  }
  .btn-green{
    background:linear-gradient(180deg,#6b3,#2b8f4a);
    color:#fff;border:none;border-radius:10px;padding:10px 14px;
    font-weight:800;cursor:pointer;
    box-shadow:0 4px 0 #1c6a35;
  }
  .small{
    padding:8px 10px;border-radius:8px;border:1px solid #d4c0b8;background:#fff;cursor:pointer;
    font-weight:700;
  }

  /* ===== Modals / overlays ===== */
  .modal-back{
    position:fixed;inset:0;background:rgba(0,0,0,0.45);
    display:none;align-items:center;justify-content:center;z-index:100;
  }
  .modal{
    background:#fff;padding:16px;border-radius:12px;width:780px;max-width:95%;
    box-shadow:0 8px 30px rgba(0,0,0,0.4);
    border:6px solid var(--accent);
  }
  .status-overlay{
    position:fixed;inset:0;background:rgba(0,0,0,0.45);
    display:none;align-items:center;justify-content:center;z-index:120;flex-direction:column;color:#111;
  }
  .status-card{
    width:80%;max-width:720px;background:rgba(255,255,255,0.98);
    padding:28px;border-radius:12px;border:4px solid var(--accent);
    text-align:center;font-size:26px;font-weight:900;
  }
  .status-sub{font-size:14px;color:#444;margin-top:8px;}

  /* ===== Staff ===== */
  .staff-full{
    position:fixed;inset:0;background:linear-gradient(180deg,#fff8f2,#fff3ec);
    padding:18px;z-index:90;display:none;flex-direction:column;overflow:auto;
  }
  .staff-full.show{display:flex;}
  .staff-top{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .big-toggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .big-toggle button{flex:1;padding:12px;border-radius:8px;font-size:16px;border:2px solid #c6b3b3;cursor:pointer;}
  .big-toggle .on{background:#2b8f4a;color:#fff;border-color:#2b8f4a;}
  .big-toggle .off{background:#f0f0f0;color:#666;}
  .staff-body{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;}
  .staff-panel{flex:1;min-width:280px;background:var(--paper);padding:12px;border-radius:10px;border:1px solid #e6d6cc;max-height:560px;overflow:auto;}
  .order-item{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;justify-content:space-between;align-items:center;gap:10px;}
  .order-item .left{min-width:0;}
  .order-item .right{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
  .shift-row{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;gap:10px;align-items:center;justify-content:space-between;}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;font-size:12px;font-weight:900;border:1px solid #ddd;background:#fff;}
  .pill.waiting{border-color:#c7d2fe;background:#eef2ff;}
  .pill.cooking{border-color:#fde68a;background:#fffbeb;}
  .pill.off{border-color:#e5e7eb;background:#f9fafb;color:#777;}

  /* ===== Menu ===== */
  .menu-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;}
  .menu-item{padding:8px;border:2px solid #e0bdb5;background:#fff;border-radius:10px;text-align:center;cursor:pointer;}
  img.menu-thumb{width:100%;height:120px;object-fit:cover;border-radius:8px;}
  @media (max-width:520px){ img.menu-thumb{height:90px;} .modal{width:94%;} }

  /* ===== Make / Paint ===== */
  .art-area{
    position:relative;width:240px;height:240px;border-radius:10px;overflow:hidden;
    /* ✅ アートの黒縁→白に */
    border:2px solid #fff;
    background:#b36e3c;
    box-shadow:0 6px 16px rgba(0,0,0,0.12);
  }
  .art-area canvas{position:absolute;left:0;top:0;width:240px;height:240px;}
  .card-canvas{border:1px solid #fff;background:var(--card-skin);border-radius:10px;}

  /* ===== Eat (photo folder) ===== */
  #modalEat .modal{
    width:95%;
    max-width:960px;
    background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/3739270_l.jpg") center center / cover no-repeat;
    border-radius:14px;
    padding:14px;
    box-shadow:0 12px 30px rgba(0,0,0,0.25);
  }
  #modalEat h3{
    font-size:14px;color:#fff;opacity:.75;margin:0 0 6px 6px;font-weight:700;
  }
  .photo-folder{background:#f6efe7;border-radius:12px;padding:10px;box-shadow: inset 0 2px 4px rgba(0,0,0,.1);}
  .photo-frame{
    background:#fff;border:10px solid #e8dccd;border-bottom:16px solid #d7c6b2;border-radius:6px;
    box-shadow:0 6px 14px rgba(0,0,0,.25);padding:6px;position:relative;transform:rotate(-1deg);
  }
  #eatMainWrap{
    width:100%;height:520px;border-radius:12px;background:#fffdf8;
    display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;
    box-shadow:inset 0 0 12px rgba(0,0,0,.15);
  }
  #servedImage{max-width:100%;max-height:100%;border-radius:8px;cursor:pointer;}
  #eatSoundInfo{
    font-weight:900;padding:.6em .9em;background:#fff;border-radius:14px;
    box-shadow:0 3px 10px rgba(0,0,0,.15);position:relative;
  }
  #eatSoundInfo:after{
    content:"";position:absolute;left:16px;bottom:-8px;border:8px solid transparent;border-top-color:#fff;
  }
  .wood-btn{
    background:linear-gradient(#c9a57a,#a67c52);color:#fff;border:none;border-radius:10px;padding:6px 12px;font-weight:900;
    box-shadow:0 3px 6px rgba(0,0,0,.25);cursor:pointer;
  }
  .wood-btn.small{font-size:12px;}
  .side-card{background:rgba(255,255,255,.92);border-radius:12px;padding:8px;box-shadow:0 4px 12px rgba(0,0,0,.15);}
  .photo-stack{display:flex;gap:8px;justify-content:center;margin-top:8px;}
  .mini-frame{
    background:#fff;border:6px solid #e8dccd;border-bottom:10px solid #d7c6b2;border-radius:4px;padding:4px;
    box-shadow:0 4px 10px rgba(0,0,0,.2);
  }

  /* ✅ ポロドーモタイマー復活（Eat内表示） */
  #pomodoroPanel{
    position:absolute;bottom:8px;right:8px;
    width:230px;aspect-ratio:1/1;
    background:#fff7e9;border-radius:14px;padding:10px;
    box-shadow:0 8px 18px rgba(0,0,0,.3);
    transform:scale(0.82);transform-origin:bottom right;
    overflow:auto;
    display:none; /* 初期はクリックで表示 */
    z-index:10;
  }
  #pomodoroPanel.show{display:block;}
  .pomo-row{display:flex;align-items:center;gap:8px;margin-bottom:8px;font-size:12px;}
  .pomo-number{display:flex;align-items:center;gap:6px;background:#fff;border:1px solid #e6d0c6;padding:6px;border-radius:8px;flex:1;}
  .pomo-number input{border:none;width:56px;font-weight:900;text-align:center;}
  .pomo-btn{width:28px;height:28px;border-radius:6px;border:1px solid #ccc;background:#fafafa;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;user-select:none;font-weight:900;}
  .pomo-timer{
    font-family:monospace;font-size:26px;text-align:center;background:#222;color:#7cff7c;padding:6px;border-radius:8px;letter-spacing:2px;font-weight:900;
  }
  .pomo-controls{display:flex;gap:6px;margin-top:6px;}
  .pomo-controls button{flex:1;padding:8px;border-radius:8px;border:1px solid #d4c0b8;background:#fff;cursor:pointer;font-weight:900;}
  .pomo-progress{height:10px;background:#eee;border-radius:999px;overflow:hidden;width:100%;margin-top:6px;}
  .pomo-progress > i{display:block;height:100%;background:linear-gradient(90deg,#ffd4c4,#ffb38a);width:0%;}

  @media(max-width:700px){
    #pomodoroPanel{transform:scale(0.72);transform-origin:bottom right;}
  }

  /* ✅ ホームの「新メニューの提供」ボタン */
  .newmenu-btn{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:86px;
    z-index:55;
    font-size:12px;
    padding:8px 12px;
    border-radius:999px;
    border:1px solid #e6d0c6;
    background:rgba(255,255,255,0.92);
    cursor:pointer;
    font-weight:900;
    box-shadow:0 6px 14px rgba(0,0,0,0.12);
  }

  /* 音の許可 */
  .sound-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;background:rgba(0,0,0,0.6);color:#fff;flex-direction:column;}
  .sound-panel{background:#fff;padding:18px;border-radius:12px;color:#111;border:3px solid var(--accent);width:360px;max-width:92%;text-align:center;}
</style>
</head>

<body>

<div class="container">
  <div class="book">
    <div class="page cover" id="coverPage" title="クリックで開く"></div>

    <div class="page inner">
      <header>
        <h1 style="margin:0;font-size:16px;"></h1>
        <div style="display:flex;align-items:center;gap:8px;">
          <div class="small-info">時刻: <span id="nowtime">--:--:--</span></div>
          <button id="bgmBtn" class="bgm-btn" title="Xを開く">X</button>
        </div>
      </header>

      <div class="content">
        <div class="order-block">
          <div id="shiftShort" class="status-line">読み込み中...</div>

          <div class="order-row">
            <button id="orderBtn" class="order-btn disabled">注文</button>
            <button id="offlineOrderBtn" class="offline-order" style="display:none;">アート<br>なし版</button>
          </div>

          <div class="small-info" id="helperSmall">実際の支払いはありません</div>
        </div>

        <!-- ✅ 新メニューの提供（小さく下の方） -->
        <button id="openNewMenu" class="newmenu-btn">＋ 新メニューの提供</button>
      </div>
    </div>
  </div>
</div>

<div class="guest-mini" id="guestMini">
  <div id="guestRole"><strong>あなた：客</strong></div>
  <div class="small-info" style="margin-top:6px">目的：注文</div>
</div>

<div class="small-pass">
  <label style="font-size:12px;margin:0">店員用</label>
  <input id="staffPass" placeholder="　" />
  <button id="passOk" class="small">OK</button>
</div>

<!-- Staff screen -->
<div id="staffFull" class="staff-full" aria-hidden="true">
  <div class="staff-top">
    <div>
      <strong id="staffBadge">店員</strong>
      <div class="small-info">店員控室</div>
    </div>
    <div>
      <button id="logoutStaff" class="small">退室</button>
    </div>
  </div>

  <div style="margin-top:8px;">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
      <label>シフト開始</label><input id="shiftStart" type="time" />
      <label>終了</label><input id="shiftEnd" type="time" />
      <button id="saveShift" class="small">保存</button>
      <span class="small-info">※時間は店員側の時間基準</span>
    </div>

    <div class="big-toggle" style="margin-top:8px;">
      <button id="shiftBtn" class="off">シフト中</button>
      <button id="breakBtn" class="off">休憩中</button>
    </div>
  </div>

  <div class="staff-body">
    <div class="staff-panel">
      <strong>全員のシフト一覧</strong>
      <div id="shiftList" class="small-info" style="margin-top:8px">読み込み中…</div>
    </div>

    <div class="staff-panel">
      <strong>注文一覧 <span id="pendingTasksSmall" class="small-info"></span></strong>
      <div id="staffOrderList" style="margin-top:8px"></div>
    </div>
  </div>

  <!-- ✅ 新メニュー提出一覧（スタッフのみ） -->
  <div class="staff-body">
    <div class="staff-panel" style="min-width:100%;">
      <strong>新メニュー提出（消すまで表示され続けます）</strong>
      <div class="small-info">ここに「番号」「名前」「画像」「保存」「削除」が出ます</div>
      <div id="newMenuList" style="margin-top:10px;"></div>
    </div>
  </div>
</div>

<!-- Sound permission -->
<div id="soundOverlay" class="sound-overlay" style="display:none;">
  <div class="sound-panel">
    <h3 style="margin:0 0 8px;">効果音など流しますか？</h3>
    <p style="font-size:12px;margin:0;">音声、効果音が流れます</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
      <button id="enableSoundBtn" class="btn-green">OK</button>
      <button id="disableSoundBtn" class="small">NO</button>
    </div>
  </div>
</div>

<!-- Status overlay -->
<div id="orderStatusOverlay" class="status-overlay">
  <div class="status-card" id="orderStatusCard">
    <div id="orderStatusMain">状態</div>
    <div id="orderStatusSub" class="status-sub">対応されない場合再度注文</div>
  </div>
</div>

<!-- Name modal -->
<div id="modalName" class="modal-back" style="display:none;">
  <div class="modal">
    <h3>ゲーム内の名前</h3>
    <input id="orderName" placeholder="名前を入力" style="width: 300px; height: 60px;font-size:18px;padding:8px;" />
    <div style="margin-top:10px;text-align:right;">
      <button id="cancelOrderName" class="small">キャンセル</button>
      <button id="okOrderName" class="btn-red">決定</button>
    </div>
  </div>
</div>

<!-- Menu modal -->
<div id="modalMenu" class="modal-back" style="display:none;">
  <div class="modal">
    <h3 id="menuTitleH3">メニューを選択『１日１品まで』</h3>
    <div class="menu-grid" id="menuGrid"></div>
    <div style="margin-top:10px;text-align:right;">
      <button id="backMenu" class="small">戻る</button>
    </div>
  </div>
</div>

<!-- Make modal -->
<div id="modalMakeLatte" class="modal-back" style="display:none;align-items:flex-start;overflow:auto;">
  <div class="modal" style="width:95%;max-width:920px;">
    <h3 id="makeTitle">制作（担当：<span id="makerName"></span>）</h3>

    <div style="display:flex;flex-wrap:wrap;gap:12px;">
      <div style="flex:1;min-width:280px;">
        <div style="height:220px;display:flex;align-items:center;justify-content:center;">
          <div style="width:180px;height:180px;border-radius:12px;background:#fff8f2;display:flex;align-items:center;justify-content:center;border:2px solid #d2b6ab;position:relative;">
            <div style="position:absolute;left:8px;top:8px;right:8px;bottom:8px;display:flex;align-items:center;justify-content:center;flex-direction:column;">
              <div id="espressoCup" style="width:120px;height:120px;border-radius:60px;overflow:hidden;position:relative;background:#6b3b24;">
                <canvas id="latteCanvas" width="120" height="120" style="display:block;"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="espressoLabel">エスプレッソ注ぎ</label>
          <div style="background:#eee;border-radius:8px;padding:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startEsp" class="small">注ぐ（押し続け）</button>
              <div style="flex:1;">
                <div style="height:16px;background:#fff;border-radius:999px;border:1px solid #d4c0b8;overflow:hidden;">
                  <div id="espBar" style="height:100%;width:0%;background:linear-gradient(90deg,#a7552b,#6b3);"></div>
                </div>
              </div>
              <div id="espPct" style="width:52px;text-align:right;font-weight:900;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="milkLabel">フームドミルク注ぎ</label>
          <div style="background:#eee;border-radius:8px;padding:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startMilk" class="small" disabled>注ぐ（押し続け）</button>
              <div style="flex:1;">
                <div style="height:16px;background:#fff;border-radius:999px;border:1px solid #d4c0b8;overflow:hidden;">
                  <div id="milkBar" style="height:100%;width:0%;background:linear-gradient(90deg,#fff,#eee);"></div>
                </div>
              </div>
              <div id="milkPct" style="width:52px;text-align:right;font-weight:900;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%</div>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:300px;">
        <div style="background:#fff8ef;padding:10px;border-radius:12px;border:1px solid #e0c7bb;">
          <strong id="latteArtLabel">アート（似顔絵など）</strong>

          <div style="margin-top:8px;">
            <div class="art-area" id="artArea">
              <canvas id="artBg" width="240" height="240"></canvas>
              <canvas id="artLayer" width="240" height="240"></canvas>
            </div>

            <div style="margin-top:10px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
              <label>ツール</label>
              <select id="penMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
              <label>太さ</label>
              <select id="penSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
              <button id="clearArt" class="small">クリア</button>
            </div>

            <div style="display:flex;gap:10px;align-items:center;margin-top:8px;flex-wrap:wrap;">
              <label style="font-size:12px;">背景色</label><input id="artBgColor" type="color" value="#6b3b24"/>
              <label style="font-size:12px;">ペン色</label><input id="artPenColor" type="color" value="#ffffff"/>
            </div>

            <div style="margin-top:10px;text-align:right;">
              <button id="saveArt" class="btn-green" disabled>アート保存</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;background:#fff8ef;padding:10px;border-radius:12px;border:1px solid #e0c7bb;">
          <strong>メッセージカード（応援等々…）</strong>
          <div style="margin-top:8px;">
            <canvas id="cardCanvas" class="card-canvas" width="320" height="120"></canvas>
          </div>

          <div style="margin-top:8px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
            <label>ツール</label>
            <select id="cardMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="cardSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="clearCard" class="small">クリア</button>
          </div>

          <div style="display:flex;gap:10px;align-items:center;margin-top:8px;flex-wrap:wrap;">
            <label style="font-size:12px;">背景色</label><input id="cardBgColor" type="color" value="#fff2e6"/>
            <label style="font-size:12px;">ペン色</label><input id="cardPenColor" type="color" value="#000000"/>
          </div>

          <div style="margin-top:10px;text-align:right;">
            <button id="saveCard" class="small" disabled>保存</button>
          </div>
        </div>

        <div style="margin-top:10px;display:flex;justify-content:flex-end;align-items:center;gap:8px;">
          <div id="taskStatusSmall" class="small-info" style="margin-right:auto"></div>
          <button id="completeMake" class="btn-red" disabled>提供する</button>
          <button id="cancelMake" class="small">中止</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Eat modal -->
<div id="modalEat" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal">
    <h3 id="eatTitle">飲食</h3>

    <div style="display:flex;gap:12px;flex-wrap:wrap;">
      <div style="flex:1;min-width:420px;" class="photo-folder">
        <div class="photo-frame">
          <div id="eatMainWrap">
            <img id="servedImage" src="" alt="商品画像" />

            <!-- ✅ ポロドーモ（クリックで開く） -->
            <div id="pomodoroPanel" aria-hidden="true">
              <div id="pomoSettings">
                <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:6px;">
                  <div>ポロドーモタイマー</div>
                  <div id="pomoCountDisplay">1 / 1</div>
                </div>

                <div class="pomo-row">
                  <div style="width:56px;">ループ</div>
                  <div class="pomo-number">
                    <button class="pomo-btn" id="loopDown">-</button>
                    <input id="loopCount" type="number" value="2" min="1" max="10"/>
                    <button class="pomo-btn" id="loopUp">+</button>
                  </div>
                </div>

                <div class="pomo-row">
                  <div style="width:56px;">作業</div>
                  <div class="pomo-number">
                    <button class="pomo-btn" id="workDown">-</button>
                    <input id="workMin" type="number" value="1" min="1" max="200"/>
                    <button class="pomo-btn" id="workUp">+</button>
                  </div>
                </div>

                <div class="pomo-row">
                  <div style="width:56px;">休憩</div>
                  <div class="pomo-number">
                    <button class="pomo-btn" id="breakDown">-</button>
                    <input id="breakMin" type="number" value="5" min="1" max="200"/>
                    <button class="pomo-btn" id="breakUp">+</button>
                  </div>
                </div>

                <div style="text-align:right;margin-top:8px;">
                  <button id="startPomoBtn" class="wood-btn">再生 ▶</button>
                </div>
              </div>

              <div id="pomoRunning" style="display:none;">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                  <div id="pomoLoopCounter" style="font-weight:900;">1 / 1</div>
                  <div id="pomoPhaseLabel" style="font-weight:900;">作業中</div>
                </div>
                <div class="pomo-timer" id="pomoTimerText">00:00:00</div>
                <div class="pomo-progress"><i id="pomoProgressBar"></i></div>

                <div class="pomo-controls">
                  <button id="stopPomoBtn">■</button>
                  <button id="pausePomoBtn">⏸</button>
                  <button id="skipPomoBtn">⏭</button>
                </div>

                <div id="pomoHint" style="font-size:12px;text-align:center;margin-top:6px;">
                  作業した分、飲食が進むよ！
                </div>
              </div>
            </div>

          </div>
        </div>

        <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
          <div id="eatSoundInfo">↑ 画像をクリックするとポロドーモを設定できます</div>
          <button id="saveAllBtn" class="wood-btn small" style="margin-left:auto">画像保存</button>
        </div>
      </div>

      <div style="width:320px;">
        <div class="side-card">
          <div class="photo-stack">
            <div class="mini-frame">
              <canvas id="servedArtMini" width="220" height="220"></canvas>
            </div>
          </div>

          <div class="photo-stack">
            <div class="mini-frame">
              <canvas id="servedCardMini" width="260" height="120"></canvas>
            </div>
          </div>

          <div style="margin-top:10px;text-align:right;">
            <button id="homeFromEat" class="wood-btn small">ホームへ</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ✅ 新メニュー説明モーダル -->
<div id="modalNewMenuInfo" class="modal-back" style="display:none;">
  <div class="modal" style="max-width:720px;">
    <h3>新メニューの提供</h3>
    <div class="small-info" style="font-size:14px;color:#333;line-height:1.6;">
      お客様が描いた商品が、メニューとして追加されるかも！<br>
      SNSに掲載されたり、このサイト内で使用することがあります。了承の上で挑戦してください。
    </div>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;">
      <button id="cancelNewMenuInfo" class="small">やめる</button>
      <button id="goNewMenuPaint" class="btn-green">挑戦</button>
    </div>
  </div>
</div>

<!-- ✅ 新メニュー提出（ペイント） -->
<div id="modalNewMenuPaint" class="modal-back" style="display:none;align-items:flex-start;overflow:auto;">
  <div class="modal" style="max-width:860px;width:95%;">
    <h3>新メニュー：おえかき提出</h3>

    <div style="display:flex;gap:12px;flex-wrap:wrap;">
      <div style="flex:1;min-width:280px;">
        <div class="small-info">名前（スタッフ画面に表示されます）</div>
        <input id="newMenuName" placeholder="名前を入力" style="width:100%;height:46px;font-size:18px;padding:8px;border-radius:10px;border:1px solid #d4c0b8;box-sizing:border-box;">
        <div class="small-info" style="margin-top:10px;">商品（おえかき）</div>

        <div style="margin-top:8px;">
          <div class="art-area" style="width:320px;height:320px;">
            <canvas id="newMenuBg" width="320" height="320"></canvas>
            <canvas id="newMenuLayer" width="320" height="320"></canvas>
          </div>

          <div style="margin-top:10px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
            <label>ツール</label>
            <select id="newMenuMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="newMenuSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="newMenuClear" class="small">クリア</button>
          </div>

          <div style="display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap;">
            <label style="font-size:12px;">背景色</label><input id="newMenuBgColor" type="color" value="#fff2e6"/>
            <label style="font-size:12px;">ペン色</label><input id="newMenuPenColor" type="color" value="#000000"/>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:280px;">
        <div style="background:#fff8ef;border:1px solid #e0c7bb;border-radius:12px;padding:10px;">
          <strong>提出の流れ</strong>
          <div class="small-info" style="margin-top:8px;color:#333;">
            ・保存して提出すると「番号」が発行され、スタッフ画面に表示されます。<br>
            ・スタッフは画像を保存できます。<br>
            ・スタッフが削除するまで、提出は残ります。
          </div>
        </div>

        <div style="margin-top:14px;display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;">
          <button id="closeNewMenuPaint" class="small">戻る</button>
          <button id="submitNewMenu" class="btn-red">保存して提出</button>
        </div>

        <div id="newMenuSubmitHint" class="small-info" style="margin-top:10px;color:#333;"></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ===== Firebase imports ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
import {
  getFirestore,
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  query,
  orderBy,
  getDoc
} from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

/* ===== Firebase config ===== */
const firebaseConfig = {
  apiKey: "AIzaSyBJe7_PGeOEkCyC1NxaTMc5bjelQwv2OaU",
  authDomain: "insyoku-f9aee.firebaseapp.com",
  projectId: "insyoku-f9aee",
  storageBucket: "insyoku-f9aee.firebasestorage.app",
  messagingSenderId: "887841835344",
  appId: "1:887841835344:web:249470b39af256b8a34455",
  measurementId: "G-QET0N3KP2L"
};

/* ===== init ===== */
let app, auth, db;
try{
  app = initializeApp(firebaseConfig);
  auth = getAuth(app);
  db = getFirestore(app);
  signInAnonymously(auth).catch(e=>console.warn("anon sign-in failed", e));
}catch(e){
  console.warn("Firebase init failed - offline mode", e);
  db = null;
}

/* ===== DOM ===== */
const nowtimeEl = document.getElementById("nowtime");
const coverPage = document.getElementById("coverPage");

const orderBtn = document.getElementById("orderBtn");
const offlineOrderBtn = document.getElementById("offlineOrderBtn");
const shiftShort = document.getElementById("shiftShort");

const staffPass = document.getElementById("staffPass");
const passOk = document.getElementById("passOk");

const modalName = document.getElementById("modalName");
const orderName = document.getElementById("orderName");
const okOrderName = document.getElementById("okOrderName");
const cancelOrderName = document.getElementById("cancelOrderName");

const modalMenu = document.getElementById("modalMenu");
const menuTitleH3 = document.getElementById("menuTitleH3");
const menuGrid = document.getElementById("menuGrid");
const backMenu = document.getElementById("backMenu");

const staffFull = document.getElementById("staffFull");
const staffBadge = document.getElementById("staffBadge");
const logoutStaff = document.getElementById("logoutStaff");
const shiftBtn = document.getElementById("shiftBtn");
const breakBtn = document.getElementById("breakBtn");
const shiftStart = document.getElementById("shiftStart");
const shiftEnd = document.getElementById("shiftEnd");
const saveShift = document.getElementById("saveShift");
const shiftList = document.getElementById("shiftList");
const staffOrderList = document.getElementById("staffOrderList");
const pendingTasksSmall = document.getElementById("pendingTasksSmall");

const newMenuList = document.getElementById("newMenuList");

const modalMakeLatte = document.getElementById("modalMakeLatte");
const makerName = document.getElementById("makerName");
const makeTitle = document.getElementById("makeTitle");
const espressoLabelEl = document.getElementById("espressoLabel");
const milkLabelEl = document.getElementById("milkLabel");
const latteArtLabelEl = document.getElementById("latteArtLabel");

const startEsp = document.getElementById("startEsp");
const espBar = document.getElementById("espBar");
const espPct = document.getElementById("espPct");
const startMilk = document.getElementById("startMilk");
const milkBar = document.getElementById("milkBar");
const milkPct = document.getElementById("milkPct");

const artBg = document.getElementById("artBg");
const artLayer = document.getElementById("artLayer");
const artBgCtx = artBg.getContext("2d");
const artLayerCtx = artLayer.getContext("2d");
const penMode = document.getElementById("penMode");
const penSize = document.getElementById("penSize");
const clearArt = document.getElementById("clearArt");
const saveArt = document.getElementById("saveArt");
const artBgColor = document.getElementById("artBgColor");
const artPenColor = document.getElementById("artPenColor");

const cardCanvas = document.getElementById("cardCanvas");
const cardCtx = cardCanvas.getContext("2d");
const cardMode = document.getElementById("cardMode");
const cardSize = document.getElementById("cardSize");
const clearCard = document.getElementById("clearCard");
const saveCard = document.getElementById("saveCard");
const cardBgColor = document.getElementById("cardBgColor");
const cardPenColor = document.getElementById("cardPenColor");

const taskStatusSmall = document.getElementById("taskStatusSmall");
const completeMake = document.getElementById("completeMake");
const cancelMake = document.getElementById("cancelMake");

const soundOverlay = document.getElementById("soundOverlay");
const enableSoundBtn = document.getElementById("enableSoundBtn");
const disableSoundBtn = document.getElementById("disableSoundBtn");

const orderStatusOverlay = document.getElementById("orderStatusOverlay");
const orderStatusMain = document.getElementById("orderStatusMain");
const orderStatusSub = document.getElementById("orderStatusSub");

const bgmBtn = document.getElementById("bgmBtn");

/* Eat */
const modalEat = document.getElementById("modalEat");
const eatTitle = document.getElementById("eatTitle");
const servedImage = document.getElementById("servedImage");
const servedArtMini = document.getElementById("servedArtMini");
const servedCardMini = document.getElementById("servedCardMini");
const saveAllBtn = document.getElementById("saveAllBtn");
const homeFromEat = document.getElementById("homeFromEat");

/* Pomodoro in eat */
const pomoPanel = document.getElementById("pomodoroPanel");
const pomoSettings = document.getElementById("pomoSettings");
const pomoRunning = document.getElementById("pomoRunning");
const loopCountInput = document.getElementById("loopCount");
const workMinInput = document.getElementById("workMin");
const breakMinInput = document.getElementById("breakMin");
const loopUp = document.getElementById("loopUp");
const loopDown = document.getElementById("loopDown");
const workUp = document.getElementById("workUp");
const workDown = document.getElementById("workDown");
const breakUp = document.getElementById("breakUp");
const breakDown = document.getElementById("breakDown");
const startPomoBtn = document.getElementById("startPomoBtn");
const pomoLoopCounter = document.getElementById("pomoLoopCounter");
const pomoPhaseLabel = document.getElementById("pomoPhaseLabel");
const pomoTimerText = document.getElementById("pomoTimerText");
const pomoProgressBar = document.getElementById("pomoProgressBar");
const stopPomoBtn = document.getElementById("stopPomoBtn");
const pausePomoBtn = document.getElementById("pausePomoBtn");
const skipPomoBtn = document.getElementById("skipPomoBtn");
const pomoCountDisplay = document.getElementById("pomoCountDisplay");

/* New menu feature */
const openNewMenuBtn = document.getElementById("openNewMenu");
const modalNewMenuInfo = document.getElementById("modalNewMenuInfo");
const cancelNewMenuInfo = document.getElementById("cancelNewMenuInfo");
const goNewMenuPaint = document.getElementById("goNewMenuPaint");
const modalNewMenuPaint = document.getElementById("modalNewMenuPaint");
const newMenuName = document.getElementById("newMenuName");
const newMenuBg = document.getElementById("newMenuBg");
const newMenuLayer = document.getElementById("newMenuLayer");
const newMenuBgCtx = newMenuBg.getContext("2d");
const newMenuLayerCtx = newMenuLayer.getContext("2d");
const newMenuMode = document.getElementById("newMenuMode");
const newMenuSize = document.getElementById("newMenuSize");
const newMenuClear = document.getElementById("newMenuClear");
const newMenuBgColor = document.getElementById("newMenuBgColor");
const newMenuPenColor = document.getElementById("newMenuPenColor");
const closeNewMenuPaint = document.getElementById("closeNewMenuPaint");
const submitNewMenu = document.getElementById("submitNewMenu");
const newMenuSubmitHint = document.getElementById("newMenuSubmitHint");

/* ===== Firestore collections ===== */
const staffsCol = db ? collection(db, "staffs") : null;
const ordersCol = db ? collection(db, "orders") : null;
const signalsCol = db ? collection(db, "signals") : null;
const newMenusCol = db ? collection(db, "newMenus") : null;

/* ===== Helpers ===== */
function uid(p="id"){ return p + Math.random().toString(36).slice(2,9); }
function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])); }
function show(el){ el.style.display="flex"; el.setAttribute("aria-hidden","false"); }
function hide(el){ el.style.display="none"; el.setAttribute("aria-hidden","true"); }
function getAssetUrl(path){
  if(!path) return "";
  if(path.startsWith("@")) return "https://raw.githubusercontent.com/" + path.slice(1);
  try{ return new URL(path).href; }catch(e){ return path; }
}

/* JST now */
function nowInJST(){
  const s = new Date().toLocaleString("en-US",{ timeZone:"Asia/Tokyo" });
  return new Date(s);
}
setInterval(()=> nowtimeEl.textContent = nowInJST().toLocaleTimeString(), 1000);

/* Shift time check: staff-side time 기준 (JST) */
function isNowWithinShift(start,end,dateObj){
  if(!start || !end) return false;
  const [sh,sm] = start.split(":").map(Number);
  const [eh,em] = end.split(":").map(Number);
  const sDate = new Date(dateObj); sDate.setHours(sh,sm,0,0);
  const eDate = new Date(dateObj); eDate.setHours(eh,em,0,0);
  if(eDate <= sDate) eDate.setDate(eDate.getDate()+1);
  return dateObj >= sDate && dateObj <= eDate;
}

/* Cover open motion (クリック or OK で確実に開く) */
function openCover(){
  if(!coverPage) return;
  coverPage.classList.add("open");
  coverPage.addEventListener("animationend", ()=>{
    coverPage.classList.add("finished");
    try{ coverPage.remove(); }catch(e){}
  }, { once:true });
}
if(coverPage){
  document.addEventListener("click", function onFirst(){
    openCover();
    document.removeEventListener("click", onFirst);
  }, { once:true });
}

/* ===== Audio ===== */
const audioTyaimu = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/tyaimu.mp3"));
const audioCookbgm = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/cookbgm.mp3"));
const audioCookdbgm = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/cookdbgm.mp3"));
const audioPiroStart = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/piro.mp3"));
const audioPiroBreak = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/piro1.mp3"));
const audioPiroToggle = new Audio(getAssetUrl("@zzcafe2800/reiji_cafe/main/piro3.mp3"));

/* ===== State ===== */
const state = {
  staffs: [],
  orders: [],
  newMenus: [],
  currentUser: { role:"guest", staffId:null },
  currentOrderIdForClient: null,
  audioUnlocked: false,
  pendingPlayQueue: []
};

let clientId = localStorage.getItem("reiji_clientId");
if(!clientId){
  clientId = "c_" + Math.random().toString(36).slice(2,9);
  localStorage.setItem("reiji_clientId", clientId);
}

/* ===== MENUS ===== */
const MENUS = {
  rate: {
    id:"rate", title:"カフェ・ラテ",
    imageBase:"@zzcafe2800/reiji_cafe/main/rate",
    frameCount:6, lastFrameRandom:true,
    artBg:"#6b3b24", artPen:"#ffffff", cardBg:"#fff2e6", cardPen:"#000000",
    ui:{ makeTitle:"カフェラテ制作", espressoLabel:"エスプレッソ注ぎ", milkLabel:"フームドミルク注ぎ", latteArtLabel:"ラテアート" }
  },
  asa: {
    id:"asa", title:"食テロ",
    imageBase:"@zzcafe2800/reiji_cafe/main/asa",
    frameCount:4, lastFrameRandom:false,
    artBg:"#6b3b24", artPen:"#ffffff", cardBg:"#fff2e6", cardPen:"#000000",
    ui:{ makeTitle:"あさごはん", espressoLabel:"ウィンナー焼き", milkLabel:"味噌汁", latteArtLabel:"ノリアート" }
  },
  tyoko: {
    id:"tyoko", title:"ケーキ（バレンタイン限定）",
    imageBase:"@zzcafe2800/reiji_cafe/main/tyoko",
    frameCount:4, lastFrameRandom:false,
    artBg:"#6b3b24", artPen:"#ffffff", cardBg:"#fff2e6", cardPen:"#000000",
    ui:{ makeTitle:"チョコケーキ", espressoLabel:"チョコ", milkLabel:"スポンジ", latteArtLabel:"チョコアート" }
  },
  pafe: {
    id:"pafe", title:"パフェ（新メニュー）",
    imageBase:"@zzcafe2800/reiji_cafe/main/pafe",
    frameCount:3, lastFrameRandom:false,
    artBg:"#6b3b24", artPen:"#ffffff", cardBg:"#fff2e6", cardPen:"#000000",
    ui:{ makeTitle:"パフェ制作", espressoLabel:"クリーム注ぎ", milkLabel:"トッピング", latteArtLabel:"クリームアート" }
  },
  omu: {
    id:"omu", title:"オムライス",
    imageBase:"@zzcafe2800/reiji_cafe/main/omu",
    frameCount:6, lastFrameRandom:true,
    artBg:"#ffd66b", artPen:"#ff0000", cardBg:"#fff2e6", cardPen:"#000000",
    ui:{ makeTitle:"オムライス制作", espressoLabel:"ケチャップライス", milkLabel:"卵で包む", latteArtLabel:"ケチャップアート" }
  }
};

/* ===== UI helpers ===== */
function showClientStatus(text){
  orderStatusMain.textContent = text;
  orderStatusSub.textContent = "数分そのままでお待ちください";
  orderStatusOverlay.style.display = "flex";
}
function hideClientStatus(){ orderStatusOverlay.style.display = "none"; }

/* ===== Realtime ===== */
function startRealtime(){
  if(!db){
    // offline fallback
    try{
      state.staffs = JSON.parse(localStorage.getItem("reiji_state_staffs")||"[]");
      state.orders = JSON.parse(localStorage.getItem("reiji_state_orders")||"[]");
      state.newMenus = JSON.parse(localStorage.getItem("reiji_state_newMenus")||"[]");
    }catch(e){}
    renderShiftShort();
    renderShiftList();
    renderOrderLists();
    renderNewMenuList();
    updateOrderButtonState();
    return;
  }

  onSnapshot(query(staffsCol, orderBy("createdAt","asc")), snap=>{
    state.staffs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}
    renderShiftShort();
    renderShiftList();
    updateOrderButtonState();
    updateStaffToggleUI();
  });

  onSnapshot(query(ordersCol, orderBy("createdAt","asc")), snap=>{
    state.orders = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}
    renderOrderLists();
    updateClientOverlay();
  });

  onSnapshot(query(newMenusCol, orderBy("createdAt","asc")), snap=>{
    state.newMenus = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    try{ localStorage.setItem("reiji_state_newMenus", JSON.stringify(state.newMenus)); }catch(e){}
    renderNewMenuList();
  });
}

/* ===== Shift short + list (✅「待機中 / 料理中」表示) ===== */
function staffStatusLabel(staff){
  // 二択：待機中 or 料理中
  const cooking = state.orders.some(o => o.state === "inprogress" && (o.assignedTo === staff.id));
  return cooking ? "料理中" : "待機中";
}

function renderShiftShort(){
  const now = nowInJST();
  const humanActive = state.staffs.filter(s => s.onShift && !s.breaking && isNowWithinShift(s.shiftStart, s.shiftEnd, now));
  if(humanActive.length){
    shiftShort.textContent = "シフト：" + humanActive.map(s=>{
      return `${s.name}（${staffStatusLabel(s)}） ${s.shiftStart||""}〜${s.shiftEnd||""}`;
    }).join(" / ");
    return;
  }
  shiftShort.textContent = "シフト：無人（注文不可）";
}

function renderShiftList(){
  shiftList.innerHTML = "";
  const now = nowInJST();

  state.staffs.forEach(s=>{
    const onNow = isNowWithinShift(s.shiftStart,s.shiftEnd,now);
    const row = document.createElement("div");
    row.className = "shift-row";
    const left = document.createElement("div");
    left.innerHTML = `
      <div><strong>${escapeHtml(s.name)}</strong> <span class="small-info">${escapeHtml(s.shiftStart||"")}〜${escapeHtml(s.shiftEnd||"")}</span></div>
      <div class="small-info">
        ${s.onShift ? '<span class="pill waiting">シフト</span>' : '<span class="pill off">OFF</span>'}
        ${s.breaking ? '<span class="pill off">休憩</span>' : ''}
        ${onNow ? '<span class="pill waiting">現在この時間</span>' : ''}
        <span class="pill ${staffStatusLabel(s)==="料理中"?"cooking":"waiting"}">${staffStatusLabel(s)}</span>
      </div>
    `;
    const right = document.createElement("div");
    const del = document.createElement("button");
    del.className = "small";
    del.textContent = "削除";
    del.onclick = async ()=>{
      if(!s.id) return;
      if(db){
        try{ await deleteDoc(doc(db,"staffs",s.id)); }catch(e){ console.warn(e); }
      }else{
        state.staffs = state.staffs.filter(x=>x.id!==s.id);
        try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}
        renderShiftList(); renderShiftShort(); updateOrderButtonState();
      }
    };
    right.appendChild(del);
    row.appendChild(left);
    row.appendChild(right);
    shiftList.appendChild(row);
  });
}

/* ===== Order button state =====
   ✅ 無人(シフト0)の時は注文できない
   ✅ スタッフの時間基準（JST）
*/
function updateOrderButtonState(){
  const now = nowInJST();
  const anyAvailable = state.staffs.some(s => s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if(anyAvailable){
    orderBtn.classList.remove("disabled");
    orderBtn.disabled = false;
    offlineOrderBtn.style.display = "none"; // 今回は「アートなし版」温存だけ（必要なら表示）
  }else{
    orderBtn.classList.add("disabled");
    orderBtn.disabled = true;
    offlineOrderBtn.style.display = "none";
  }
}

/* ===== Staff login ===== */
passOk.addEventListener("click", ()=>{
  if(staffPass.value === "1232"){
    show(modalName);
    orderName.value = "";
  }else{
    alert("パスワードが違います");
  }
});

cancelOrderName.addEventListener("click", ()=>{
  hide(modalName);
  orderName.value = "";
});

okOrderName.addEventListener("click", async ()=>{
  const name = orderName.value.trim();
  if(!name){ alert("名前"); return; }

  hide(modalName);

  // If currently guest clicked "注文" it uses same name modal → detect mode by a flag
  if(modalName.dataset.mode === "guest"){
    delete modalName.dataset.mode;
    buildMenu();
    show(modalMenu);
    return;
  }

  // staff enter
  try{
    if(db){
      const ref = await addDoc(staffsCol, { name, shiftStart:"09:00", shiftEnd:"17:00", onShift:true, breaking:false, createdAt: Date.now() });
      enterStaffFull(name, ref.id);
    }else{
      const s = { id: uid("s"), name, shiftStart:"09:00", shiftEnd:"17:00", onShift:true, breaking:false, createdAt: Date.now() };
      state.staffs.push(s);
      try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}
      enterStaffFull(name, s.id);
    }
  }catch(e){
    console.warn(e);
    const s = { id: uid("s"), name, shiftStart:"09:00", shiftEnd:"17:00", onShift:true, breaking:false, createdAt: Date.now() };
    state.staffs.push(s);
    enterStaffFull(name, s.id);
  }
});

function enterStaffFull(name, staffId){
  state.currentUser = { role:"staff", staffId };
  staffBadge.textContent = name;
  staffFull.classList.add("show");
  renderShiftList();
  renderOrderLists();
  renderNewMenuList();
  updateStaffToggleUI();
}

logoutStaff.addEventListener("click", async ()=>{
  const id = state.currentUser.staffId;
  if(id){
    if(db){
      try{ await deleteDoc(doc(db,"staffs",id)); }catch(e){}
    }else{
      state.staffs = state.staffs.filter(s=>s.id!==id);
      try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}
    }
  }
  state.currentUser = { role:"guest", staffId:null };
  staffFull.classList.remove("show");
});

/* shift toggle */
function updateStaffToggleUI(){
  if(state.currentUser.role==="staff" && state.currentUser.staffId){
    const my = state.staffs.find(s=>s.id===state.currentUser.staffId);
    if(my){
      if(my.onShift && !my.breaking){
        shiftBtn.classList.add("on"); shiftBtn.classList.remove("off");
        breakBtn.classList.add("off"); breakBtn.classList.remove("on");
      }else if(my.breaking){
        breakBtn.classList.add("on"); breakBtn.classList.remove("off");
        shiftBtn.classList.add("off"); shiftBtn.classList.remove("on");
      }else{
        shiftBtn.classList.add("off"); shiftBtn.classList.remove("on");
        breakBtn.classList.add("off"); breakBtn.classList.remove("on");
      }
    }
  }
}

shiftBtn.addEventListener("click", async ()=>{
  const id = state.currentUser.staffId; if(!id) return;
  if(db){
    try{ await updateDoc(doc(db,"staffs",id), { onShift:true, breaking:false }); }catch(e){}
  }else{
    const s = state.staffs.find(x=>x.id===id);
    if(s){ s.onShift=true; s.breaking=false; try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}; renderShiftList(); renderShiftShort(); updateOrderButtonState(); }
  }
  updateStaffToggleUI();
});

breakBtn.addEventListener("click", async ()=>{
  const id = state.currentUser.staffId; if(!id) return;
  if(db){
    try{ await updateDoc(doc(db,"staffs",id), { onShift:false, breaking:true }); }catch(e){}
  }else{
    const s = state.staffs.find(x=>x.id===id);
    if(s){ s.onShift=false; s.breaking=true; try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}; renderShiftList(); renderShiftShort(); updateOrderButtonState(); }
  }
  updateStaffToggleUI();
});

saveShift.addEventListener("click", async ()=>{
  const id = state.currentUser.staffId; if(!id) return;
  const payload = { shiftStart:shiftStart.value||"09:00", shiftEnd:shiftEnd.value||"17:00" };
  if(db){
    try{ await updateDoc(doc(db,"staffs",id), payload); }catch(e){ console.warn(e); }
  }else{
    const s = state.staffs.find(x=>x.id===id);
    if(s){ Object.assign(s, payload); try{ localStorage.setItem("reiji_state_staffs", JSON.stringify(state.staffs)); }catch(e){}; renderShiftList(); renderShiftShort(); updateOrderButtonState(); }
  }
});

/* ===== Menu build (✅ メニュー名が「0」になる問題を避ける：titleを必ず使う) ===== */
async function buildMenu(){
  menuGrid.innerHTML = "";
  menuTitleH3.textContent = "メニューを選択『１日１品まで』";

  const keys = Object.keys(MENUS);
  for(const k of keys){
    const it = MENUS[k];
    const div = document.createElement("div");
    div.className = "menu-item";
    const img = document.createElement("img");
    img.className = "menu-thumb";

    const url = getAssetUrl(it.imageBase + "1.png");
    try{
      const res = await fetch(url);
      if(res.ok){
        const blob = await res.blob();
        img.src = URL.createObjectURL(blob);
      }else{
        img.src = makePlaceholder(it.title);
      }
    }catch(e){
      img.src = makePlaceholder(it.title);
    }

    const label = document.createElement("div");
    label.style.fontWeight = "900";
    label.textContent = it.title; // ✅ ここが数字0にならない
    div.appendChild(img);
    div.appendChild(label);

    div.addEventListener("click", ()=> onMenuSelect(it));
    menuGrid.appendChild(div);
  }
}
function makePlaceholder(title){
  const c=document.createElement("canvas"); c.width=320; c.height=240;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#fff8ef"; ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle="#6b3b24"; ctx.beginPath(); ctx.arc(160,110,60,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#fff"; ctx.font="20px sans-serif"; ctx.fillText(title||"menu", 90, 210);
  return c.toDataURL("image/png");
}

backMenu.addEventListener("click", ()=> hide(modalMenu));

/* ===== Ordering ===== */
orderBtn.addEventListener("click", async ()=>{
  if(orderBtn.classList.contains("disabled")) return;

  // signal (tyaimu) minimal write
  if(db && signalsCol){
    try{ await addDoc(signalsCol, { type:"tyaimu", ts: Date.now() }); }catch(e){}
  }
  try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{}); }catch(e){}

  modalName.dataset.mode = "guest";
  show(modalName);
});

async function onMenuSelect(item){
  hide(modalMenu);

  const name = (orderName.value.trim() || "名無し");
  const createdAt = Date.now();
  const expiresAt = createdAt + 5*60*1000;
  const orderObj = {
    name,
    item: item.id,
    itemTitle: item.title,
    itemImageBase: item.imageBase,
    state:"waiting",
    createdAt,
    expiresAt,
    assignedTo:null,
    assignedToName:null,
    artStrokes:null,
    cardStrokes:null,
    artMeta:null,
    cardMeta:null,
    artDataUrl:null,
    cardDataUrl:null,
    servedImageData:null,
    clientId
  };

  // human staff check
  const now = nowInJST();
  const humanActive = state.staffs.filter(s => s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if(!humanActive.length){
    // no staff: order should not be possible per requirement. But just in case:
    showClientStatus("現在無人です（注文できません）");
    setTimeout(()=> hideClientStatus(), 2500);
    return;
  }

  try{
    if(db){
      const ref = await addDoc(ordersCol, orderObj);
      state.currentOrderIdForClient = ref.id;
      showClientStatus("現在対応待ち中");
      scheduleOrderTimeout(ref.id, expiresAt);
    }else{
      orderObj.id = uid("o");
      state.orders.push(orderObj);
      try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}
      state.currentOrderIdForClient = orderObj.id;
      showClientStatus("現在対応待ち中");
      scheduleOrderTimeout(orderObj.id, expiresAt);
      renderOrderLists();
    }
  }catch(e){
    console.warn(e);
    orderObj.id = uid("o");
    state.orders.push(orderObj);
    try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}
    state.currentOrderIdForClient = orderObj.id;
    showClientStatus("現在対応待ち中");
    scheduleOrderTimeout(orderObj.id, expiresAt);
    renderOrderLists();
  }
}

async function scheduleOrderTimeout(orderId, expiresAt){
  const remaining = (expiresAt||0) - Date.now();
  if(remaining <= 0) return;
  setTimeout(async ()=>{
    try{
      if(!db){
        const o = state.orders.find(x=>x.id===orderId);
        if(o && o.state==="waiting"){
          o.state="cancelled";
          o.cancelReason="スタッフの応答がないため現在注文を取り消しになります";
          try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}
          renderOrderLists();
        }
        return;
      }
      const snap = await getDoc(doc(db,"orders",orderId));
      if(snap.exists()){
        const o = snap.data();
        if(o.state==="waiting"){
          await updateDoc(doc(db,"orders",orderId), { state:"cancelled", cancelReason:"スタッフの応答がないため現在注文を取り消しになります" });
        }
      }
    }catch(e){ console.warn(e); }
  }, remaining);
}

/* ===== Staff orders list ===== */
function renderOrderLists(){
  staffOrderList.innerHTML = "";
  const visible = (state.orders||[]).filter(o => o && !["cancelled","served"].includes(o.state));
  const pendingCount = visible.filter(o => o.state==="waiting" || o.state==="inprogress").length;
  pendingTasksSmall.textContent = pendingCount ? ` 未処理:${pendingCount}` : "";

  visible.forEach(o=>{
    if(o.state === "delivered") return;

    const div = document.createElement("div");
    div.className = "order-item";

    const left = document.createElement("div");
    left.className = "left";
    const time = new Date(o.createdAt||0).toLocaleTimeString();
    left.innerHTML = `
      <div style="font-weight:900;">${escapeHtml(o.name)} <span class="small-info">(${escapeHtml(o.itemTitle || MENUS[o.item]?.title || o.item)})</span></div>
      <div class="small-info">状態: ${escapeHtml(o.state)} / 作成: ${escapeHtml(time)}</div>
    `;

    const right = document.createElement("div");
    right.className = "right";

    if(o.state === "waiting"){
      const btn = document.createElement("button");
      btn.className = "small btn-green";
      btn.textContent = "対応";
      btn.onclick = ()=> assignOrderToCurrentStaff(o.id);
      right.appendChild(btn);
    }else if(o.state === "inprogress"){
      const info = document.createElement("span");
      info.className = "small-info";
      info.textContent = `担当:${o.assignedToName||o.assignedTo||""}`;
      right.appendChild(info);

      const makeBtn = document.createElement("button");
      makeBtn.className = "small";
      makeBtn.textContent = "制作開始";
      makeBtn.onclick = ()=> openMakeModal(o);
      right.appendChild(makeBtn);
    }else if(o.state === "done"){
      const provideBtn = document.createElement("button");
      provideBtn.className = "small btn-green";
      provideBtn.textContent = "提供";
      provideBtn.onclick = ()=> openMakeModal(o);
      right.appendChild(provideBtn);
    }else if(o.state === "cancelled"){
      const span = document.createElement("span");
      span.className = "small-info";
      span.textContent = "キャンセル";
      right.appendChild(span);
    }

    div.appendChild(left);
    div.appendChild(right);
    staffOrderList.appendChild(div);
  });
}

async function assignOrderToCurrentStaff(orderId){
  const staffId = state.currentUser.staffId;
  if(!staffId){ alert("スタッフとしてログインしてください"); return; }
  const s = state.staffs.find(x=>x.id===staffId);

  try{
    if(db){
      await updateDoc(doc(db,"orders",orderId), { state:"inprogress", assignedTo: staffId, assignedToName: s?.name||"" });
    }else{
      const o = state.orders.find(x=>x.id===orderId);
      if(o){ o.state="inprogress"; o.assignedTo=staffId; o.assignedToName=s?.name||""; try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}; renderOrderLists(); }
    }
    if(state.audioUnlocked){
      try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); }catch(e){}
    }else{
      state.pendingPlayQueue.push({ type:"cook" });
    }
  }catch(e){ console.warn(e); }
}

/* ===== Drawing (✅ 消しゴムで背景まで消えるバグ修正：背景は別キャンバス固定、消しゴムは上レイヤのみ) ===== */
function normPointInCanvas(pt, canvas){ return { x: pt.x / canvas.width, y: pt.y / canvas.height }; }
function denormPoint(p, canvas){ return { x: (p.x||0)*canvas.width, y: (p.y||0)*canvas.height }; }

function initArtCanvas(bgColor){
  artBgCtx.clearRect(0,0,artBg.width,artBg.height);
  artBgCtx.fillStyle = bgColor || artBgColor.value || "#6b3b24";
  artBgCtx.beginPath(); artBgCtx.arc(120,120,100,0,Math.PI*2); artBgCtx.fill();

  artLayerCtx.clearRect(0,0,artLayer.width,artLayer.height);
  artLayerCtx.lineCap="round"; artLayerCtx.lineJoin="round";
}
function initCardCanvas(bgColor){
  cardCtx.clearRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.fillStyle = bgColor || cardBgColor.value || "#fff2e6";
  cardCtx.fillRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.lineCap="round"; cardCtx.lineJoin="round";
}

let artStrokes = [];
let cardStrokes = [];
let currentArtStroke = null;
let currentCardStroke = null;
let artDrawing=false, cardDrawing=false;

let savedArtDataUrlLocal = null, savedCardDataUrlLocal = null;
let savedArtMeta = null, savedCardMeta = null;
let savedArtStrokesLocal = null, savedCardStrokesLocal = null;

function getEventPos(e, canvas){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : null;
  const cx = t ? t.clientX : e.clientX;
  const cy = t ? t.clientY : e.clientY;
  return { x:(cx-r.left)*(canvas.width/r.width), y:(cy-r.top)*(canvas.height/r.height) };
}

function renderLatestStrokeSegment(stroke, canvasEl, ctx){
  if(!stroke || stroke.points.length<2) return;
  const p1 = denormPoint(stroke.points[stroke.points.length-2], canvasEl);
  const p2 = denormPoint(stroke.points[stroke.points.length-1], canvasEl);

  if(stroke.tool==="draw"){
    ctx.globalCompositeOperation="source-over";
    ctx.strokeStyle = stroke.pen;
    ctx.lineWidth = stroke.width;
  }else{
    // ✅ 上レイヤだけを消す（背景は artBg / cardBg で守られる）
    ctx.globalCompositeOperation="destination-out";
    ctx.lineWidth = stroke.width;
  }
  ctx.beginPath();
  ctx.moveTo(p1.x,p1.y);
  ctx.lineTo(p2.x,p2.y);
  ctx.stroke();
  ctx.closePath();
  ctx.globalCompositeOperation="source-over";
}

/* Art layer events */
artLayer.addEventListener("mousedown", (e)=>{
  artDrawing=true;
  const p = getEventPos(e, artLayer);
  currentArtStroke = {
    tool: penMode.value,
    width: parseInt(penSize.value,10),
    points: [ normPointInCanvas(p, artLayer) ],
    pen: artPenColor.value || "#ffffff"
  };
});
artLayer.addEventListener("mousemove",(e)=>{
  if(!artDrawing || !currentArtStroke) return;
  const p = getEventPos(e, artLayer);
  currentArtStroke.points.push(normPointInCanvas(p, artLayer));
  renderLatestStrokeSegment(currentArtStroke, artLayer, artLayerCtx);
});
function endArt(){
  if(!artDrawing) return;
  artDrawing=false;
  if(currentArtStroke){
    artStrokes.push(currentArtStroke);
    currentArtStroke=null;
    saveArt.disabled=false;
    updateTaskStatus();
  }
}
artLayer.addEventListener("mouseup", endArt);
artLayer.addEventListener("mouseleave", endArt);
artLayer.addEventListener("touchstart",(e)=>{ e.preventDefault(); const t=e.touches[0]; artLayer.dispatchEvent(new MouseEvent("mousedown",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
artLayer.addEventListener("touchmove",(e)=>{ e.preventDefault(); const t=e.touches[0]; artLayer.dispatchEvent(new MouseEvent("mousemove",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
artLayer.addEventListener("touchend",(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent("mouseup")); }, {passive:false});

/* Card canvas events */
cardCanvas.addEventListener("mousedown",(e)=>{
  cardDrawing=true;
  const p = getEventPos(e, cardCanvas);
  currentCardStroke = {
    tool: cardMode.value,
    width: parseInt(cardSize.value,10),
    points: [ normPointInCanvas(p, cardCanvas) ],
    pen: cardPenColor.value || "#000000"
  };
});
cardCanvas.addEventListener("mousemove",(e)=>{
  if(!cardDrawing || !currentCardStroke) return;
  const p = getEventPos(e, cardCanvas);
  currentCardStroke.points.push(normPointInCanvas(p, cardCanvas));
  renderLatestStrokeSegment(currentCardStroke, cardCanvas, cardCtx);
});
function endCard(){
  if(!cardDrawing) return;
  cardDrawing=false;
  if(currentCardStroke){
    cardStrokes.push(currentCardStroke);
    currentCardStroke=null;
    saveCard.disabled=false;
    updateTaskStatus();
  }
}
cardCanvas.addEventListener("mouseup", endCard);
cardCanvas.addEventListener("mouseleave", endCard);
cardCanvas.addEventListener("touchstart",(e)=>{ e.preventDefault(); const t=e.touches[0]; cardCanvas.dispatchEvent(new MouseEvent("mousedown",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
cardCanvas.addEventListener("touchmove",(e)=>{ e.preventDefault(); const t=e.touches[0]; cardCanvas.dispatchEvent(new MouseEvent("mousemove",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
cardCanvas.addEventListener("touchend",(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent("mouseup")); }, {passive:false});

/* clear */
clearArt.addEventListener("click", ()=>{ initArtCanvas(); artStrokes=[]; currentArtStroke=null; saveArt.disabled=true; updateTaskStatus(); });
clearCard.addEventListener("click", ()=>{ initCardCanvas(); cardStrokes=[]; currentCardStroke=null; saveCard.disabled=true; updateTaskStatus(); });

/* save art/card (✅ 画像つぶれ対策：保存サイズ固定＆比率保持のまま描画) */
saveArt.addEventListener("click", ()=>{
  const scale = 2;
  const tmp = document.createElement("canvas");
  tmp.width = artLayer.width * scale;
  tmp.height = artLayer.height * scale;
  const t = tmp.getContext("2d");

  t.fillStyle = artBgColor.value || "#6b3b24";
  t.fillRect(0,0,tmp.width,tmp.height);

  t.lineCap="round"; t.lineJoin="round";
  const strokes = JSON.parse(JSON.stringify(artStrokes||[]));
  for(const s of strokes){
    t.beginPath();
    t.globalCompositeOperation = (s.tool==="draw") ? "source-over" : "destination-out";
    t.strokeStyle = s.pen || artPenColor.value || "#fff";
    t.lineWidth = (s.width||6)*scale;
    const pts = s.points||[];
    for(let i=0;i<pts.length;i++){
      const x = pts[i].x * tmp.width;
      const y = pts[i].y * tmp.height;
      if(i===0) t.moveTo(x,y); else t.lineTo(x,y);
    }
    t.stroke(); t.closePath();
    t.globalCompositeOperation="source-over";
  }

  savedArtDataUrlLocal = tmp.toDataURL("image/png");
  savedArtMeta = { origWidth: artLayer.width, origHeight: artLayer.height, savedWidth: tmp.width, savedHeight: tmp.height, bg: artBgColor.value || "#6b3b24", penDefault: artPenColor.value || "#ffffff", scale };
  savedArtStrokesLocal = JSON.parse(JSON.stringify(artStrokes||[]));
  saveArt.disabled=true;
  updateTaskStatus();
  alert("アートを保存しました。");
});

saveCard.addEventListener("click", ()=>{
  const scale = 2;
  const tmp = document.createElement("canvas");
  tmp.width = cardCanvas.width * scale;
  tmp.height = cardCanvas.height * scale;
  const t = tmp.getContext("2d");

  t.fillStyle = cardBgColor.value || "#fff2e6";
  t.fillRect(0,0,tmp.width,tmp.height);

  t.lineCap="round"; t.lineJoin="round";
  const strokes = JSON.parse(JSON.stringify(cardStrokes||[]));
  for(const s of strokes){
    t.beginPath();
    t.globalCompositeOperation = (s.tool==="draw") ? "source-over" : "destination-out";
    t.strokeStyle = s.pen || cardPenColor.value || "#000";
    t.lineWidth = (s.width||4)*scale;
    const pts = s.points||[];
    for(let i=0;i<pts.length;i++){
      const x = pts[i].x * tmp.width;
      const y = pts[i].y * tmp.height;
      if(i===0) t.moveTo(x,y); else t.lineTo(x,y);
    }
    t.stroke(); t.closePath();
    t.globalCompositeOperation="source-over";
  }

  savedCardDataUrlLocal = tmp.toDataURL("image/png");
  savedCardMeta = { origWidth: cardCanvas.width, origHeight: cardCanvas.height, savedWidth: tmp.width, savedHeight: tmp.height, bg: cardBgColor.value || "#fff2e6", penDefault: cardPenColor.value || "#000000", scale };
  savedCardStrokesLocal = JSON.parse(JSON.stringify(cardStrokes||[]));
  saveCard.disabled=true;
  updateTaskStatus();
  alert("カードを保存しました。");
});

/* pouring */
const latteCanvas = document.getElementById("latteCanvas");
const latteCtx = latteCanvas.getContext("2d");
function latteClear(){
  latteCtx.clearRect(0,0,latteCanvas.width,latteCanvas.height);
  latteCtx.fillStyle="#6b3b24";
  latteCtx.beginPath(); latteCtx.arc(60,60,58,0,Math.PI*2); latteCtx.fill();
}
function latteFillEsp(){ latteCtx.fillStyle="#5a2f1a"; latteCtx.fillRect(0,60,latteCanvas.width,60); }
function latteFillMilk(){ latteCtx.fillStyle="#f6efe6"; latteCtx.beginPath(); latteCtx.arc(60,60,48,0,Math.PI*2); latteCtx.fill(); }
latteClear();

let espInterval=null, milkInterval=null, espDone=false, milkDone=false;
function resetPouring(){
  if(espInterval){ clearInterval(espInterval); espInterval=null; }
  if(milkInterval){ clearInterval(milkInterval); milkInterval=null; }
  espBar.style.width="0%"; espPct.textContent="0%";
  milkBar.style.width="0%"; milkPct.textContent="0%";
  espDone=false; milkDone=false;
  startEsp.disabled=false; startMilk.disabled=true;
  updateTaskStatus();
}
resetPouring();

function startAutoPour(barEl,pctEl,onOverflow){
  let pct=0;
  const it=setInterval(()=>{
    pct = Math.min(130, pct + Math.random()*4 + 1);
    barEl.style.width = pct + "%";
    pctEl.textContent = Math.round(pct) + "%";
    if(pct>=120){ clearInterval(it); onOverflow(); }
  }, 100);
  return { it, getPct: ()=>pct };
}

startEsp.addEventListener("mousedown", ()=>{
  if(espInterval) return;
  startEsp.textContent="注ぎ中...";
  const res = startAutoPour(espBar, espPct, ()=>{ alert("注ぎ過ぎ（120%）最初からやり直し"); resetPouring(); });
  espInterval = res.it;
});
startEsp.addEventListener("mouseup", ()=>{
  if(espInterval){ clearInterval(espInterval); espInterval=null; }
  startEsp.textContent="注ぐ（押し続け）";
  const pct = parseFloat(espBar.style.width)||0;
  if(pct>=95 && pct<=105){ espDone=true; latteFillEsp(); startMilk.disabled=false; updateTaskStatus(); }
  else{ alert("合格ラインを外しました。最初から"); resetPouring(); }
});
startMilk.addEventListener("mousedown", ()=>{
  if(milkInterval) return;
  startMilk.textContent="注ぎ中...";
  const res = startAutoPour(milkBar, milkPct, ()=>{ alert("注ぎ過ぎ（120%）最初からやり直し"); resetPouring(); });
  milkInterval = res.it;
});
startMilk.addEventListener("mouseup", ()=>{
  if(milkInterval){ clearInterval(milkInterval); milkInterval=null; }
  startMilk.textContent="注ぐ（押し続け）";
  const pct = parseFloat(milkBar.style.width)||0;
  if(pct>=95 && pct<=105){ milkDone=true; latteFillMilk(); updateTaskStatus(); }
  else{ alert("合格ラインを外しました。最初から"); resetPouring(); }
});
startEsp.addEventListener("touchstart",(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event("mousedown")); }, {passive:false});
startEsp.addEventListener("touchend",(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event("mouseup")); }, {passive:false});
startMilk.addEventListener("touchstart",(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event("mousedown")); }, {passive:false});
startMilk.addEventListener("touchend",(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event("mouseup")); }, {passive:false});

/* task status */
function updateTaskStatus(){
  const parts=[];
  if(!espDone || !milkDone) parts.push("注ぎ");
  if(!savedArtDataUrlLocal && (!artStrokes || !artStrokes.length)) parts.push("アート");
  if(!savedCardDataUrlLocal && (!cardStrokes || !cardStrokes.length)) parts.push("カード");
  taskStatusSmall.textContent = parts.length ? "未完了: " + parts.join(", ") : "すべて完了";
  completeMake.disabled = parts.length !== 0;
}

/* open make modal */
let currentMakingOrderId=null;
async function openMakeModal(order){
  currentMakingOrderId = order.id;
  makerName.textContent = order.assignedToName || "";

  const cfg = MENUS[order.item] || MENUS.rate;
  makeTitle.textContent = `${cfg.ui.makeTitle}（担当：${order.assignedToName||""}）`;
  espressoLabelEl.textContent = cfg.ui.espressoLabel;
  milkLabelEl.textContent = cfg.ui.milkLabel;
  latteArtLabelEl.textContent = cfg.ui.latteArtLabel;

  resetPouring();
  initArtCanvas(cfg.artBg);
  initCardCanvas(cfg.cardBg);

  artStrokes = Array.isArray(order.artStrokes) ? JSON.parse(JSON.stringify(order.artStrokes)) : [];
  cardStrokes = Array.isArray(order.cardStrokes) ? JSON.parse(JSON.stringify(order.cardStrokes)) : [];

  savedArtDataUrlLocal = order.artDataUrl || null;
  savedCardDataUrlLocal = order.cardDataUrl || null;
  savedArtMeta = order.artMeta || null;
  savedCardMeta = order.cardMeta || null;

  // replay
  if(artStrokes.length) replayStrokesOnCanvas(artStrokes, artLayer, artLayerCtx);
  if(cardStrokes.length) replayStrokesOnCanvas(cardStrokes, cardCanvas, cardCtx);

  saveArt.disabled = !artStrokes.length;
  saveCard.disabled = !cardStrokes.length;
  updateTaskStatus();

  show(modalMakeLatte);
}
cancelMake.addEventListener("click", ()=> hide(modalMakeLatte));

function replayStrokesOnCanvas(strokes, canvasEl, ctx){
  for(const s of strokes){
    ctx.beginPath();
    ctx.lineWidth = s.width || 3;
    if(s.tool==="draw"){
      ctx.globalCompositeOperation="source-over";
      ctx.strokeStyle = s.pen || "#000";
    }else{
      ctx.globalCompositeOperation="destination-out";
    }
    const pts = s.points||[];
    for(let i=0;i<pts.length;i++){
      const p = denormPoint(pts[i], canvasEl);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
    ctx.closePath();
    ctx.globalCompositeOperation="source-over";
  }
}

/* complete make: generate served image */
completeMake.addEventListener("click", async ()=>{
  if(!currentMakingOrderId){ alert("対象の注文がありません"); return; }

  const tmp = document.createElement("canvas");
  tmp.width = 1200; tmp.height = 1200;
  const tctx = tmp.getContext("2d");
  tctx.fillStyle = "#fff8ef"; tctx.fillRect(0,0,tmp.width,tmp.height);

  // latte
  tctx.drawImage(latteCanvas, 450, 300, 300, 300);

  // art
  if(savedArtDataUrlLocal){
    const img = new Image(); img.src = savedArtDataUrlLocal;
    await new Promise(r=>{ img.onload=r; img.onerror=r; });
    tctx.drawImage(img, 440,120,320,320);
  }

  // card
  if(savedCardDataUrlLocal){
    const img = new Image(); img.src = savedCardDataUrlLocal;
    await new Promise(r=>{ img.onload=r; img.onerror=r; });
    tctx.drawImage(img, 430,700,340,160);
  }

  const servedDataUrl = tmp.toDataURL("image/png");

  try{
    if(db){
      await updateDoc(doc(db,"orders",currentMakingOrderId), {
        state:"delivered",
        deliveredAt: Date.now(),
        servedImageData: servedDataUrl,
        artStrokes: artStrokes || [],
        cardStrokes: cardStrokes || [],
        artMeta: savedArtMeta || null,
        cardMeta: savedCardMeta || null,
        artDataUrl: savedArtDataUrlLocal || null,
        cardDataUrl: savedCardDataUrlLocal || null
      });
    }else{
      const o = state.orders.find(x=>x.id===currentMakingOrderId);
      if(o){
        o.state="delivered";
        o.servedImageData = servedDataUrl;
        o.artStrokes = artStrokes || [];
        o.cardStrokes = cardStrokes || [];
        o.artDataUrl = savedArtDataUrlLocal || null;
        o.cardDataUrl = savedCardDataUrlLocal || null;
        try{ localStorage.setItem("reiji_state_orders", JSON.stringify(state.orders)); }catch(e){}
      }
      renderOrderLists();
    }
    hide(modalMakeLatte);
    try{ audioCookbgm.pause(); audioCookbgm.currentTime=0; }catch(e){}
    alert("提供しました。");
  }catch(e){
    console.warn(e);
    hide(modalMakeLatte);
    alert("提供に失敗しました。");
  }
});

/* ===== Client overlay updates ===== */
function updateClientOverlay(){
  if(!state.currentOrderIdForClient) return;
  const o = state.orders.find(x=>x.id===state.currentOrderIdForClient);
  if(!o) return;

  if(o.state==="waiting"){
    showClientStatus("現在対応待ち中");
  }else if(o.state==="inprogress"){
    showClientStatus("現在調理中…");
    if(state.audioUnlocked){
      try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); }catch(e){}
    }else{
      state.pendingPlayQueue.push({ type:"cook" });
    }
  }else if(o.state==="delivered"){
    hideClientStatus();
    try{ audioCookbgm.pause(); audioCookbgm.currentTime=0; }catch(e){}
    showClientServed(o);
  }else if(o.state==="cancelled"){
    showClientStatus(o.cancelReason || "注文が取り消されました");
    setTimeout(()=>{ hideClientStatus(); state.currentOrderIdForClient=null; }, 8000);
  }
}

/* ===== Served / Eat modal ===== */
async function preloadFrames(basePath, frameCount=6){
  const frames=[];
  for(let i=1;i<=frameCount;i++){
    const candidates = [
      `${basePath}${i}.png`,
      `${basePath}${String(i).padStart(2,"0")}.png`,
      `${basePath}_${i}.png`,
      `${basePath}_${String(i).padStart(2,"0")}.png`
    ];
    for(const c of candidates){
      try{
        const url = getAssetUrl(c);
        const res = await fetch(url);
        if(!res.ok) continue;
        const blob = await res.blob();
        frames.push(URL.createObjectURL(blob));
        break;
      }catch(e){}
    }
  }
  return frames;
}

/* ✅ ポロドーモ開始後、②以降の画像を表示する仕組み（メニューごと） */
function getWorkFrameIndex(menuKey, elapsedMs, totalMs){
  const menu = MENUS[menuKey] || MENUS.rate;
  const fc = menu.frameCount || 6;
  if(!totalMs || totalMs<=0) return 1;
  const ratio = Math.min(1, Math.max(0, elapsedMs / totalMs));
  const from = 2;
  const to = fc;
  const idx = Math.floor(from + (to-from)*ratio);
  return Math.min(fc, Math.max(1, idx));
}
function pickBreakFrame(menuKey){
  const menu = MENUS[menuKey] || MENUS.rate;
  const fc = menu.frameCount || 6;
  if(fc<=1) return 1;
  return Math.random() < 0.5 ? Math.max(1,fc-1) : fc;
}
async function setServedImageFrame(menuKey, frameIndex){
  const menu = MENUS[menuKey] || MENUS.rate;
  const candidates = [
    `${menu.imageBase}${frameIndex}.png`,
    `${menu.imageBase}${String(frameIndex).padStart(2,"0")}.png`,
    `${menu.imageBase}_${frameIndex}.png`,
    `${menu.imageBase}_${String(frameIndex).padStart(2,"0")}.png`
  ];
  for(const c of candidates){
    try{
      const url = getAssetUrl(c);
      const res = await fetch(url, { method:"HEAD" });
      if(res.ok){ servedImage.src = url; return; }
    }catch(e){}
  }
  servedImage.src = getAssetUrl(menu.imageBase + "1.png");
}

async function showClientServed(order){
  const cfg = MENUS[order.item] || MENUS.rate;

  // ✅ Eatタイトルにメニュー名（0表示問題を完全回避）
  eatTitle.textContent = `飲食（${cfg.title}）`;

  // served image
  if(order.servedImageData){
    servedImage.src = order.servedImageData;
  }else{
    servedImage.src = getAssetUrl(cfg.imageBase + "1.png");
  }

  // minis
  const artCtx = servedArtMini.getContext("2d");
  artCtx.clearRect(0,0,servedArtMini.width,servedArtMini.height);
  artCtx.fillStyle = (order.artMeta && order.artMeta.bg) || cfg.artBg || "#6b3b24";
  artCtx.fillRect(0,0,servedArtMini.width,servedArtMini.height);
  if(order.artDataUrl){
    const img = new Image(); img.src = order.artDataUrl;
    await new Promise(r=>{ img.onload=r; img.onerror=r; });
    artCtx.drawImage(img,0,0,servedArtMini.width,servedArtMini.height);
  }

  const cardCtxMini = servedCardMini.getContext("2d");
  cardCtxMini.clearRect(0,0,servedCardMini.width,servedCardMini.height);
  cardCtxMini.fillStyle = (order.cardMeta && order.cardMeta.bg) || cfg.cardBg || "#fff2e6";
  cardCtxMini.fillRect(0,0,servedCardMini.width,servedCardMini.height);
  if(order.cardDataUrl){
    const img = new Image(); img.src = order.cardDataUrl;
    await new Promise(r=>{ img.onload=r; img.onerror=r; });
    cardCtxMini.drawImage(img,0,0,servedCardMini.width,servedCardMini.height);
  }

  // pomodoro binds to this menu
  POMO.currentMenuKey = cfg.id;

  // show eat
  show(modalEat);
}

/* save image */
saveAllBtn.addEventListener("click", ()=>{
  const tmp = document.createElement("canvas");
  tmp.width=1200; tmp.height=1200;
  const t = tmp.getContext("2d");
  t.fillStyle="#fff8ef"; t.fillRect(0,0,tmp.width,tmp.height);

  const mainImg = new Image();
  mainImg.crossOrigin="anonymous";
  mainImg.src = servedImage.src;

  mainImg.onload = ()=>{
    // ✅ つぶれ対策：常に同じ座標・同じ比率で描画
    t.drawImage(mainImg, 150,100,900,600);
    t.drawImage(servedArtMini, 860,120,220,220);
    t.drawImage(servedCardMini, 860,360,260,120);

    const a = document.createElement("a");
    a.href = tmp.toDataURL("image/png");
    a.download = "served_save.png";
    a.click();
  };
  mainImg.onerror = ()=> alert("画像の読み込みに失敗しました");
});

/* home from eat */
homeFromEat.addEventListener("click", ()=>{
  hide(modalEat);
  state.currentOrderIdForClient = null;
  // pomodoro hidden
  pomoPanel.classList.remove("show");
});

/* ===== Pomodoro ===== */
const POMO = {
  running:false,
  phase:"idle", // work, break, paused, idle
  loopTotal:1,
  loopIndex:0,
  workMin:25,
  breakMin:5,
  remainingMs:0,
  tickInterval:null,
  lastTickTs:0,
  currentMenuKey:"rate",
  _prevPhase:"work"
};

function formatTime(ms){
  if(ms<0) ms=0;
  let s=Math.floor(ms/1000);
  const h=Math.floor(s/3600); s%=3600;
  const m=Math.floor(s/60);
  const sec=s%60;
  return String(h).padStart(2,"0")+":"+String(m).padStart(2,"0")+":"+String(sec).padStart(2,"0");
}

function renderPomoUI(){
  if(!POMO.running){
    pomoSettings.style.display="block";
    pomoRunning.style.display="none";
    pomoTimerText.textContent="00:00:00";
    pomoProgressBar.style.width="0%";
    return;
  }
  pomoSettings.style.display="none";
  pomoRunning.style.display="block";
  pomoLoopCounter.textContent = `${POMO.loopIndex+1} / ${POMO.loopTotal}`;
  pomoPhaseLabel.textContent = (POMO.phase==="work") ? "作業中" : (POMO.phase==="break" ? "休憩中" : (POMO.phase==="paused" ? "一時停止" : "待機"));
  pomoTimerText.textContent = formatTime(POMO.remainingMs);

  // progress
  let total = (POMO.phase==="work") ? (POMO.workMin*60*1000) : (POMO.breakMin*60*1000);
  if(POMO.phase==="paused") total = (POMO._prevPhase==="work") ? (POMO.workMin*60*1000) : (POMO.breakMin*60*1000);
  const elapsed = Math.max(0, total - POMO.remainingMs);
  const pct = Math.min(100, Math.floor((elapsed/total)*100));
  pomoProgressBar.style.width = pct + "%";

  pausePomoBtn.textContent = (POMO.phase==="paused") ? "▶" : "⏸";
}

function startPomoTick(){
  if(POMO.tickInterval) return;
  POMO.lastTickTs = Date.now();
  POMO.tickInterval = setInterval(async ()=>{
    const now = Date.now();
    const delta = now - POMO.lastTickTs;
    POMO.lastTickTs = now;

    if(POMO.phase==="paused" || POMO.phase==="idle") return;

    POMO.remainingMs -= delta;

    if(POMO.remainingMs <= 0){
      if(POMO.phase === "work"){
        POMO.phase = "break";
        try{ audioPiroBreak.currentTime=0; audioPiroBreak.play().catch(()=>{}); }catch(e){}
        POMO.remainingMs = POMO.breakMin*60*1000;
        await setServedImageFrame(POMO.currentMenuKey, pickBreakFrame(POMO.currentMenuKey));
      }else if(POMO.phase === "break"){
        POMO.loopIndex++;
        if(POMO.loopIndex >= POMO.loopTotal){
          stopPomo(true);
          return;
        }
        POMO.phase = "work";
        POMO.remainingMs = POMO.workMin*60*1000;
        try{ audioPiroStart.currentTime=0; audioPiroStart.play().catch(()=>{}); }catch(e){}
        await setServedImageFrame(POMO.currentMenuKey, 2);
      }
      renderPomoUI();
      return;
    }

    // ✅ 作業中は経過に応じて ②以降の画像へ
    if(POMO.phase==="work"){
      const total = POMO.workMin*60*1000;
      const elapsed = total - POMO.remainingMs;
      const idx = getWorkFrameIndex(POMO.currentMenuKey, elapsed, total);
      await setServedImageFrame(POMO.currentMenuKey, idx);
    }
    renderPomoUI();
  }, 300);
}

function stopPomoTick(){
  if(POMO.tickInterval){
    clearInterval(POMO.tickInterval);
    POMO.tickInterval = null;
  }
}

function startPomo(){
  POMO.loopTotal = Math.max(1, Math.min(10, parseInt(loopCountInput.value||"1",10)));
  POMO.loopIndex = 0;
  POMO.workMin = Math.max(1, Math.min(200, parseInt(workMinInput.value||"25",10)));
  POMO.breakMin = Math.max(1, Math.min(200, parseInt(breakMinInput.value||"5",10)));

  POMO.running = true;
  POMO.phase = "work";
  POMO.remainingMs = POMO.workMin*60*1000;

  // ✅ count display
  pomoCountDisplay.textContent = `${POMO.loopTotal} / ${POMO.loopTotal}`;

  try{ audioPiroStart.currentTime=0; audioPiroStart.play().catch(()=>{}); }catch(e){}
  setServedImageFrame(POMO.currentMenuKey, 2);
  renderPomoUI();
  startPomoTick();
}

function togglePausePomo(){
  if(!POMO.running) return;
  if(POMO.phase==="paused"){
    POMO.phase = POMO._prevPhase || "work";
    try{ audioPiroToggle.currentTime=0; audioPiroToggle.play().catch(()=>{}); }catch(e){}
    startPomoTick();
  }else{
    POMO._prevPhase = POMO.phase;
    POMO.phase = "paused";
    stopPomoTick();
    try{ audioPiroToggle.currentTime=0; audioPiroToggle.play().catch(()=>{}); }catch(e){}
  }
  renderPomoUI();
}

function stopPomo(resetToSettings){
  POMO.running = false;
  POMO.phase = "idle";
  POMO.remainingMs = 0;
  stopPomoTick();
  if(resetToSettings){
    pomoSettings.style.display="block";
    pomoRunning.style.display="none";
  }
  renderPomoUI();
}

function skipPomo(){
  if(!POMO.running) return;
  POMO.remainingMs = 0;
}

/* Buttons */
function wireHoldButton(buttonEl, inputEl, delta, min, max){
  let timer=null;
  function step(){
    let v = parseInt(inputEl.value||"0",10);
    v += delta;
    if(typeof min==="number") v=Math.max(min,v);
    if(typeof max==="number") v=Math.min(max,v);
    inputEl.value = v;
    pomoCountDisplay.textContent = `${Math.max(1,Math.min(10,parseInt(loopCountInput.value||"1",10)))} / ${Math.max(1,Math.min(10,parseInt(loopCountInput.value||"1",10)))}`;
  }
  function startHold(){
    step();
    timer=setTimeout(function repeat(){
      step();
      timer=setTimeout(repeat, 120);
    }, 380);
  }
  function stopHold(){ if(timer){ clearTimeout(timer); timer=null; } }
  buttonEl.addEventListener("mousedown",(e)=>{ e.preventDefault(); startHold(); });
  buttonEl.addEventListener("touchstart",(e)=>{ e.preventDefault(); startHold(); }, {passive:false});
  window.addEventListener("mouseup", stopHold);
  window.addEventListener("touchend", stopHold);
  buttonEl.addEventListener("click",(e)=>{ e.preventDefault(); step(); });
}
wireHoldButton(loopUp, loopCountInput, +1, 1, 10);
wireHoldButton(loopDown, loopCountInput, -1, 1, 10);
wireHoldButton(workUp, workMinInput, +1, 1, 200);
wireHoldButton(workDown, workMinInput, -1, 1, 200);
wireHoldButton(breakUp, breakMinInput, +1, 1, 200);
wireHoldButton(breakDown, breakMinInput, -1, 1, 200);

startPomoBtn.addEventListener("click", ()=>{ if(!POMO.running) startPomo(); });
stopPomoBtn.addEventListener("click", ()=> stopPomo(true));
pausePomoBtn.addEventListener("click", ()=> togglePausePomo());
skipPomoBtn.addEventListener("click", ()=> skipPomo());

/* ✅ 画像クリックでポロドーモ設定を開く（なくなってた動作の復活） */
servedImage.addEventListener("click", ()=>{
  pomoPanel.classList.toggle("show");
  renderPomoUI();
});

/* ===== Sound permission ===== */
function flushPendingPlays(){
  while(state.pendingPlayQueue.length){
    const req = state.pendingPlayQueue.shift();
    if(req.type==="cook"){
      try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); }catch(e){}
    }
  }
}
function showSoundOverlay(){ soundOverlay.style.display="flex"; }
function hideSoundOverlay(){ soundOverlay.style.display="none"; }

enableSoundBtn.addEventListener("click", ()=>{
  state.audioUnlocked = true;
  // ✅ OKでも開くモーションが確実に動く
  openCover();
  try{ audioTyaimu.play().then(()=>{ audioTyaimu.pause(); audioTyaimu.currentTime=0; }).catch(()=>{}); }catch(e){}
  hideSoundOverlay();
  flushPendingPlays();
});
disableSoundBtn.addEventListener("click", ()=>{
  state.audioUnlocked = false;
  // ✅ NOでも開くモーション
  openCover();
  hideSoundOverlay();
});

/* X */
bgmBtn.addEventListener("click", ()=> window.open("https://x.com/zzcafe_280", "_blank"));

/* ===== New Menu Submission Feature ===== */
function initNewMenuCanvas(){
  newMenuBgCtx.clearRect(0,0,newMenuBg.width,newMenuBg.height);
  newMenuBgCtx.fillStyle = newMenuBgColor.value || "#fff2e6";
  newMenuBgCtx.fillRect(0,0,newMenuBg.width,newMenuBg.height);

  newMenuLayerCtx.clearRect(0,0,newMenuLayer.width,newMenuLayer.height);
  newMenuLayerCtx.lineCap="round";
  newMenuLayerCtx.lineJoin="round";
}

let newMenuDrawing=false;
let newMenuStroke=null;
let newMenuStrokes=[];

function newMenuPos(e, canvas){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : null;
  const cx = t ? t.clientX : e.clientX;
  const cy = t ? t.clientY : e.clientY;
  return { x:(cx-r.left)*(canvas.width/r.width), y:(cy-r.top)*(canvas.height/r.height) };
}
function nmNorm(p){ return { x:p.x/newMenuLayer.width, y:p.y/newMenuLayer.height }; }
function nmDen(p){ return { x:(p.x||0)*newMenuLayer.width, y:(p.y||0)*newMenuLayer.height }; }

function drawNewMenuSeg(st){
  if(!st || st.points.length<2) return;
  const p1 = nmDen(st.points[st.points.length-2]);
  const p2 = nmDen(st.points[st.points.length-1]);

  if(st.tool==="draw"){
    newMenuLayerCtx.globalCompositeOperation="source-over";
    newMenuLayerCtx.strokeStyle = st.pen;
    newMenuLayerCtx.lineWidth = st.width;
  }else{
    newMenuLayerCtx.globalCompositeOperation="destination-out";
    newMenuLayerCtx.lineWidth = st.width;
  }
  newMenuLayerCtx.beginPath();
  newMenuLayerCtx.moveTo(p1.x,p1.y);
  newMenuLayerCtx.lineTo(p2.x,p2.y);
  newMenuLayerCtx.stroke();
  newMenuLayerCtx.closePath();
  newMenuLayerCtx.globalCompositeOperation="source-over";
}

newMenuLayer.addEventListener("mousedown",(e)=>{
  newMenuDrawing=true;
  const p = newMenuPos(e,newMenuLayer);
  newMenuStroke = { tool:newMenuMode.value, width:parseInt(newMenuSize.value,10), points:[nmNorm(p)], pen:newMenuPenColor.value||"#000" };
});
newMenuLayer.addEventListener("mousemove",(e)=>{
  if(!newMenuDrawing || !newMenuStroke) return;
  const p = newMenuPos(e,newMenuLayer);
  newMenuStroke.points.push(nmNorm(p));
  drawNewMenuSeg(newMenuStroke);
});
function endNewMenu(){
  if(!newMenuDrawing) return;
  newMenuDrawing=false;
  if(newMenuStroke){
    newMenuStrokes.push(newMenuStroke);
    newMenuStroke=null;
  }
}
newMenuLayer.addEventListener("mouseup", endNewMenu);
newMenuLayer.addEventListener("mouseleave", endNewMenu);
newMenuLayer.addEventListener("touchstart",(e)=>{ e.preventDefault(); const t=e.touches[0]; newMenuLayer.dispatchEvent(new MouseEvent("mousedown",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
newMenuLayer.addEventListener("touchmove",(e)=>{ e.preventDefault(); const t=e.touches[0]; newMenuLayer.dispatchEvent(new MouseEvent("mousemove",{clientX:t.clientX,clientY:t.clientY})); }, {passive:false});
newMenuLayer.addEventListener("touchend",(e)=>{ e.preventDefault(); newMenuLayer.dispatchEvent(new MouseEvent("mouseup")); }, {passive:false});

newMenuClear.addEventListener("click", ()=>{
  initNewMenuCanvas();
  newMenuStrokes=[];
  newMenuStroke=null;
});

newMenuBgColor.addEventListener("input", ()=> initNewMenuCanvas());

openNewMenuBtn.addEventListener("click", ()=> show(modalNewMenuInfo));
cancelNewMenuInfo.addEventListener("click", ()=> hide(modalNewMenuInfo));
goNewMenuPaint.addEventListener("click", ()=>{
  hide(modalNewMenuInfo);
  newMenuSubmitHint.textContent = "";
  newMenuName.value = "";
  initNewMenuCanvas();
  newMenuStrokes=[];
  show(modalNewMenuPaint);
});
closeNewMenuPaint.addEventListener("click", ()=>{
  hide(modalNewMenuPaint);
  show(modalNewMenuInfo);
});

submitNewMenu.addEventListener("click", async ()=>{
  const name = newMenuName.value.trim();
  if(!name){ alert("名前を入力してください"); return; }

  // save to dataURL (軽め：jpeg 0.65 / 8秒更新などは今回は提出用なので単発保存)
  const out = document.createElement("canvas");
  out.width = 640; out.height = 640;
  const octx = out.getContext("2d");
  octx.fillStyle = newMenuBgColor.value || "#fff2e6";
  octx.fillRect(0,0,out.width,out.height);

  // draw strokes scaled
  octx.lineCap="round"; octx.lineJoin="round";
  for(const s of newMenuStrokes){
    octx.beginPath();
    octx.globalCompositeOperation = (s.tool==="draw") ? "source-over" : "destination-out";
    octx.strokeStyle = s.pen || "#000";
    octx.lineWidth = (s.width||6) * (out.width / newMenuLayer.width);
    const pts = s.points||[];
    for(let i=0;i<pts.length;i++){
      const x = pts[i].x * out.width;
      const y = pts[i].y * out.height;
      if(i===0) octx.moveTo(x,y); else octx.lineTo(x,y);
    }
    octx.stroke(); octx.closePath();
    octx.globalCompositeOperation="source-over";
  }

  const dataUrl = out.toDataURL("image/jpeg", 0.65);
  const createdAt = Date.now();
  const code = String(createdAt).slice(-6); // ✅ 数字になって表示（要件）
  const payload = { code, name, imageData: dataUrl, createdAt };

  submitNewMenu.disabled = true;
  submitNewMenu.textContent = "提出中…";

  try{
    if(db){
      await addDoc(newMenusCol, payload);
    }else{
      payload.id = uid("nm");
      state.newMenus.push(payload);
      try{ localStorage.setItem("reiji_state_newMenus", JSON.stringify(state.newMenus)); }catch(e){}
      renderNewMenuList();
    }
    newMenuSubmitHint.textContent = `提出しました！番号：${code}（スタッフ画面に表示されます）`;
    setTimeout(()=> hide(modalNewMenuPaint), 900);
  }catch(e){
    console.warn(e);
    alert("提出に失敗しました");
  }finally{
    submitNewMenu.disabled = false;
    submitNewMenu.textContent = "保存して提出";
  }
});

function renderNewMenuList(){
  newMenuList.innerHTML = "";

  if(state.currentUser.role !== "staff"){
    newMenuList.innerHTML = '<div class="small-info">※スタッフでログインすると表示されます</div>';
    return;
  }

  if(!state.newMenus || !state.newMenus.length){
    newMenuList.innerHTML = '<div class="small-info">提出はまだありません</div>';
    return;
  }

  // newest last (already orderBy asc). display newest top:
  const list = [...state.newMenus].sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));

  for(const m of list){
    const wrap = document.createElement("div");
    wrap.style.display="flex";
    wrap.style.gap="10px";
    wrap.style.alignItems="center";
    wrap.style.borderBottom="1px dashed #e6d0c6";
    wrap.style.padding="10px 0";

    const thumb = document.createElement("img");
    thumb.src = m.imageData || "";
    thumb.alt = "newmenu";
    thumb.style.width="110px";
    thumb.style.height="110px";
    thumb.style.objectFit="cover";
    thumb.style.borderRadius="10px";
    thumb.style.border="1px solid #e6d0c6";
    wrap.appendChild(thumb);

    const info = document.createElement("div");
    info.style.flex="1";
    info.innerHTML = `
      <div style="font-weight:900;">#${escapeHtml(m.code||"------")} <span class="small-info">提出者：${escapeHtml(m.name||"")}</span></div>
      <div class="small-info">作成: ${new Date(m.createdAt||0).toLocaleString()}</div>
    `;
    wrap.appendChild(info);

    const actions = document.createElement("div");
    actions.style.display="flex";
    actions.style.gap="8px";
    actions.style.flexWrap="wrap";
    actions.style.justifyContent="flex-end";

    const saveBtn = document.createElement("button");
    saveBtn.className="small";
    saveBtn.textContent="画像保存";
    saveBtn.onclick = ()=>{
      const a = document.createElement("a");
      a.href = m.imageData;
      a.download = `newmenu_${m.code||"item"}.jpg`;
      a.click();
    };

    const delBtn = document.createElement("button");
    delBtn.className="small";
    delBtn.textContent="削除";
    delBtn.onclick = async ()=>{
      if(!confirm("この提出を削除しますか？")) return;
      if(db){
        try{ await deleteDoc(doc(db,"newMenus",m.id)); }catch(e){ console.warn(e); }
      }else{
        state.newMenus = state.newMenus.filter(x=>x.id!==m.id);
        try{ localStorage.setItem("reiji_state_newMenus", JSON.stringify(state.newMenus)); }catch(e){}
        renderNewMenuList();
      }
    };

    actions.appendChild(saveBtn);
    actions.appendChild(delBtn);
    wrap.appendChild(actions);

    newMenuList.appendChild(wrap);
  }
}

/* ===== Signals (tyaimu broadcast) ===== */
if(db && signalsCol){
  let lastSignalTs=0;
  onSnapshot(query(signalsCol, orderBy("ts","asc")), snap=>{
    snap.docs.forEach(d=>{
      const v=d.data();
      if(!v || !v.ts) return;
      if(v.ts <= lastSignalTs) return;
      lastSignalTs = v.ts;
      if(v.type==="tyaimu"){
        try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{}); }catch(e){}
      }
    });
  });
}

/* ===== Init ===== */
function initAll(){
  initArtCanvas();
  initCardCanvas();
  initNewMenuCanvas();
  buildMenu().catch(()=>{});
  startRealtime();
  renderNewMenuList();

  // show sound overlay
  showSoundOverlay();
}
initAll();

/* When staff screen opens later, new menu list updates automatically by realtime; also keep non-staff hidden */
</script>

</body>
</html>
