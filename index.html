<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ゲームカフェ — 修正版（J/E/C/Kボタン、注文ごとの独立保存）</title>
<meta name="format-detection" content="telephone=no">
<style>
  :root{
    --bg:#f7efe7; --accent:#b33; --paper:#fff8ef; --dark:#3a2b20; --muted:#8b6d5c;
    --card-skin:#fff2e6;
  }
  html,body{height:100%;margin:0;font-family: "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background:linear-gradient(180deg,#fdf2ea 0%,#f7efe7 100%);}
  .container{max-width:1000px;margin:18px auto;padding:18px;background:var(--paper);box-shadow:0 6px 20px rgba(0,0,0,0.15);border-radius:10px;border:6px solid var(--accent);position:relative;min-height:720px;}
  header{display:flex;align-items:center;justify-content:space-between;padding:6px 12px;color:var(--dark);}
  h1{margin:0;font-size:18px;}
  .content{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;padding:12px;}
  .order-block{width:100%;max-width:520px;display:flex;flex-direction:column;align-items:center;gap:10px;}
  .status-line{font-weight:700;background:rgba(255,255,255,0.92);padding:8px 12px;border-radius:8px;border:2px solid #f0c6c6;text-align:center;}
  .order-btn{background:linear-gradient(180deg,#ffd4c4,#ffb38a);border:4px solid var(--accent);color:var(--dark);padding:22px 36px;border-radius:12px;font-size:34px;cursor:pointer;box-shadow:0 6px 0 #913;user-select:none;width:100%;max-width:420px;}
  .order-btn.disabled{opacity:0.4;cursor:not-allowed;box-shadow:none;}
  .menu-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;width:100%;max-width:760px;margin-top:12px;}
  .menu-item{padding:8px;border:2px solid #e0bdb5;background:#fff;border-radius:8px;text-align:center;cursor:pointer;position:relative;}
  .menu-thumb{width:100%;height:160px;object-fit:cover;border-radius:6px;}
  .menu-actions{display:flex;gap:6px;justify-content:center;margin-top:8px;}
  .flag-btn{width:44px;height:28px;border-radius:6px;border:1px solid #ddd;background:#fff;display:flex;align-items:center;justify-content:center;position:relative;cursor:pointer;}
  .flag-hint{position:absolute;right:4px;bottom:2px;font-size:9px;color:#666;}
  .small-info{font-size:12px;color:var(--muted);}
  .guest-mini{position:fixed;right:12px;bottom:12px;background:var(--paper);padding:8px;border-radius:8px;border:1px solid #e6d6cc;font-size:13px;box-shadow:0 6px 12px rgba(0,0,0,0.08);}
  .staff-full{position:fixed;inset:0;background:linear-gradient(180deg,#fff8f2,#fff3ec);padding:18px;z-index:90;display:none;flex-direction:column;overflow:auto;}
  .staff-full.show{display:flex;}
  .staff-top{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .big-toggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .big-toggle button{flex:1;padding:12px;border-radius:8px;font-size:16px;border:2px solid #c6b3b3;cursor:pointer;}
  .big-toggle .on{background:#2b8f4a;color:#fff;border-color:#2b8f4a;}
  .big-toggle .off{background:#f0f0f0;color:#666;}
  .staff-body{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;}
  .staff-panel{flex:1;min-width:280px;background:var(--paper);padding:12px;border-radius:8px;border:1px solid #e6d6cc;max-height:520px;overflow:auto;}
  .order-item{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;justify-content:space-between;align-items:center;}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:100;}
  .modal{background:#fff;padding:16px;border-radius:10px;width:760px;max-width:95%;box-shadow:0 8px 30px rgba(0,0,0,0.4);border:6px solid var(--accent);}
  .art-area{position:relative;width:240px;height:240px;border-radius:6px;overflow:hidden;border:1px solid #d4c0b8;background:#b36e3c;}
  .card-canvas{border:1px solid #e6d0c6;background:var(--card-skin);border-radius:8px;}
  .status-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:120;flex-direction:column;color:#111;}
  .status-card{width:80%;max-width:720px;background:rgba(255,255,255,0.98);padding:28px;border-radius:12px;border:4px solid var(--accent);text-align:center;font-size:26px;font-weight:700;}
  .status-sub{font-size:14px;color:#444;margin-top:8px;}
  .bgm-btn{font-size:12px;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.95);border:1px solid #e6d0c6;cursor:pointer;}
  .sound-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;background:rgba(0,0,0,0.6);color:#fff;flex-direction:column;}
  @media (max-width:600px){ .menu-grid{grid-template-columns:1fr;} .menu-thumb{height:140px;} }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>ゲームカフェ</h1>
    <div style="display:flex;align-items:center;gap:8px;">
      <div class="small-info">現在時刻: <span id="nowtime">--:--:--</span></div>
      <button id="bgmBtn" class="bgm-btn" title="BGM">BGM</button>
    </div>
  </header>

  <div class="content">
    <div class="order-block">
      <div id="shiftShort" class="status-line">読み込み中...</div>
      <button id="orderBtn" class="order-btn disabled">注文</button>
      <div id="helperSmall" class="small-info">①注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div>
    </div>

    <div id="menuGrid" class="menu-grid"></div>
  </div>

  <div class="guest-mini" id="guestMini">
    <div id="guestRole"><strong>あなたは現在：客</strong></div>
    <div class="small-info" style="margin-top:6px">スタッフは「1232」で入室</div>
  </div>

  <div class="small-pass">
    <label style="font-size:12px;margin:0">スタッフパス</label>
    <input id="staffPass" placeholder="小さい" />
    <button id="passOk" class="small">OK</button>
  </div>
</div>

<!-- Staff full screen (管理UIは除去、簡素化) -->
<div id="staffFull" class="staff-full" aria-hidden="true">
  <div class="staff-top">
    <div>
      <strong id="staffBadge">スタッフ</strong>
      <div class="small-info">全画面スタッフモード</div>
    </div>
    <div>
      <button id="logoutStaff" class="small">退室</button>
    </div>
  </div>

  <div style="margin-top:8px;">
    <div style="display:flex;gap:8px;align-items:center;">
      <label>シフト開始</label><input id="shiftStart" type="time" />
      <label>終了</label><input id="shiftEnd" type="time" />
      <button id="saveShift" class="small">保存</button>
    </div>

    <div class="big-toggle" style="margin-top:8px;">
      <button id="shiftBtn" class="off">シフト中</button>
      <button id="breakBtn" class="off">休憩中</button>
    </div>
  </div>

  <div class="staff-body">
    <div class="staff-panel">
      <strong>現在のシフト一覧</strong>
      <div id="shiftList" class="shift-list small-info" style="margin-top:8px">読み込み中…</div>
    </div>

    <div class="staff-panel">
      <strong>スタッフ用 注文一覧 <span id="pendingTasksSmall" class="small-info"></span></strong>
      <div id="staffOrderList" class="order-list" style="margin-top:8px"></div>
    </div>
  </div>
</div>

<!-- Sound enable overlay -->
<div id="soundOverlay" class="sound-overlay" style="display:none;">
  <div style="background:#fff;padding:18px;border-radius:12px;color:#111;border:3px solid var(--accent);width:360px;text-align:center;">
    <h3>サウンドを有効にしますか？</h3>
    <p>音声は通知や効果音に使われます。続行するには「有効にする」を押してください。</p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
      <button id="enableSoundBtn" class="btn-green">有効にする</button>
      <button id="disableSoundBtn" class="small">後で</button>
    </div>
  </div>
</div>

<!-- Order status overlay for client -->
<div id="orderStatusOverlay" class="status-overlay">
  <div class="status-card" id="orderStatusCard">
    <div id="orderStatusMain">状態</div>
    <div id="orderStatusSub" class="status-sub">①注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div>
  </div>
</div>

<!-- Modals (簡略化) -->
<div id="modalName" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal">
    <h3>名前を入力</h3>
    <input id="orderName" placeholder="名前を入力" />
    <div style="margin-top:10px;text-align:right;">
      <button id="cancelOrderName" class="small">キャンセル</button>
      <button id="okOrderName" class="btn-red">決定</button>
    </div>
  </div>
</div>

<div id="modalMakeLatte" class="modal-back" style="display:none;align-items:flex-start;overflow:auto;">
  <div class="modal" style="width:95%;max-width:920px;">
    <h3 id="makeTitle">カフェラテ制作（担当：<span id="makerName"></span>）</h3>
    <div style="display:flex;flex-wrap:wrap;gap:12px;">
      <div style="flex:1;min-width:280px;">
        <div style="height:220px;display:flex;align-items:center;justify-content:center;">
          <div style="width:180px;height:180px;border-radius:12px;background:#fff8f2;display:flex;align-items:center;justify-content:center;border:2px solid #d2b6ab;position:relative;">
            <div style="position:absolute;left:8px;top:8px;right:8px;bottom:8px;display:flex;align-items:center;justify-content:center;flex-direction:column;">
              <div id="espressoCup" style="width:120px;height:120px;border-radius:60px;overflow:hidden;position:relative;background:#6b3b24;">
                <canvas id="latteCanvas" width="120" height="120" style="display:block;"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="espressoLabel">エスプレッソ注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startEsp" class="small">注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="espBar" style="height:100%;width:0%;background:linear-gradient(90deg,#a7552b,#6b3);"></div>
                </div>
              </div>
              <div id="espPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%。120% 到達は注ぎ過ぎ（失敗）。</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="milkLabel">フームドミルク注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startMilk" class="small" disabled>注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="milkBar" style="height:100%;width:0%;background:linear-gradient(90deg,#fff,#eee);"></div>
                </div>
              </div>
              <div id="milkPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%。120% 到達は注ぎ過ぎ（失敗）。</div>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:300px;">
        <div style="background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong id="artLabel">ラテアート（白ペン）</strong>
          <div style="margin-top:8px;">
            <div class="art-area" id="artArea">
              <canvas id="artBg" width="240" height="240"></canvas>
              <canvas id="artLayer" width="240" height="240"></canvas>
            </div>
            <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
              <label>ツール</label>
              <select id="penMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
              <label>太さ</label>
              <select id="penSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
              <button id="clearArt" class="small">クリア</button>
            </div>
            <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
              <label style="font-size:12px;">背景色</label><input id="artBgColor" type="color" value="#6b3b24"/>
              <label style="font-size:12px;">ペン色</label><input id="artPenColor" type="color" value="#ffffff"/>
            </div>
            <div style="margin-top:8px;text-align:right;">
              <button id="saveArt" class="btn-green" disabled>アート保存</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>メッセージカード（手書き）</strong>
          <div style="margin-top:6px;">
            <canvas id="cardCanvas" class="card-canvas" width="320" height="120"></canvas>
          </div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
            <label>ツール</label>
            <select id="cardMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="cardSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="clearCard" class="small">クリア</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
            <label style="font-size:12px;">背景色</label><input id="cardBgColor" type="color" value="#fff2e6"/>
            <label style="font-size:12px;">ペン色</label><input id="cardPenColor" type="color" value="#000000"/>
          </div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveCard" class="small" disabled>カード保存</button>
          </div>
        </div>

        <div style="margin-top:8px;display:flex;justify-content:flex-end;align-items:center;gap:8px;">
          <div id="taskStatusSmall" class="small-info" style="margin-right:auto"></div>
          <button id="completeMake" class="btn-red" disabled>提供する（完了）</button>
          <button id="cancelMake" class="small">中止</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Eat modal -->
<div id="modalEat" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal">
    <h3>飲食画面</h3>
    <div style="display:flex;gap:12px;flex-wrap:wrap;">
      <div style="flex:1;min-width:320px;">
        <div style="width:100%;height:240px;border:1px solid #d4c0b8;border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;position:relative;">
          <img id="servedImage" src="" alt="商品画像" style="max-width:100%;max-height:100%;border-radius:8px;" />
        </div>
        <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
          <div id="eatSoundInfo" class="small-info">長押しで音（rate.mp3）</div>
          <button id="saveAllBtn" class="small" style="margin-left:auto">画像保存</button>
        </div>
      </div>

      <div style="width:260px;">
        <div style="border:1px solid #e2cfc8;padding:8px;border-radius:8px;background:#fff7f3;">
          <strong>ラテアート（小）</strong>
          <canvas id="servedArtMini" width="120" height="120" style="border:1px solid #d4c0b8;margin-top:8px;background:#6b3b24"></canvas>

          <strong style="display:block;margin-top:8px">メッセージカード</strong>
          <canvas id="servedCardMini" width="160" height="80" style="border:1px solid #d4c0b8;margin-top:8px;background:var(--card-skin)"></canvas>

          <div style="margin-top:8px;text-align:right;">
            <button id="homeFromEat" class="small">ホームへ</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* 変更版スクリプト（抜粋説明は冒頭コメント参照）
   反映内容要約:
   - ホームのメニューカードの下に J/E/C/K 画像ボタンを横並びで表示（GitHub raw を想定）
   - 管理UIは削除。スタッフ画面はシフト一覧と注文一覧のみ。
   - 注文ごとのアートデータはその注文に紐づける。配信（delivered）時のみ注文者に送る。
   - 注文者がホームへ戻ったら、その注文のアート/カードデータを Firestore 上でクリア（null）する。
   - シフト/休憩は押した人のボタンだけが緑になる（Firestore 更新）。
   - 長押しをやめたら rate.mp3 は確実に止める。
   - 注文者が飲食画面を開いたら cookbgm を注文者側で停止する。
   - MENUS 内に uiLabels を追加し、make modal の文言を商品ごとに変更可能にした。
*/

/* Firebase imports */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
import { getFirestore, collection, doc, addDoc, updateDoc, deleteDoc, onSnapshot, query, orderBy, getDoc } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

/* config */
const firebaseConfig = {
  apiKey: "AIzaSyCNm1bmsVG4uZIJaL-bwbIcLCghzJ-ejvM",
  authDomain: "reiji-cafr.firebaseapp.com",
  projectId: "reiji-cafr",
  storageBucket: "reiji-cafr.firebasestorage.app",
  messagingSenderId: "18020287382",
  appId: "1:18020287382:web:1a87e6378598697ea3d3b7",
  measurementId: "G-F35S7FGW9M"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
signInAnonymously(auth).catch(e=>console.warn('anonymous sign-in failed', e));

/* DOM refs */
const nowtimeEl = document.getElementById('nowtime');
const orderBtn = document.getElementById('orderBtn');
const shiftShort = document.getElementById('shiftShort');
const staffPass = document.getElementById('staffPass');
const passOk = document.getElementById('passOk');
const modalName = document.getElementById('modalName');
const orderName = document.getElementById('orderName');
const okOrderName = document.getElementById('okOrderName');
const menuGrid = document.getElementById('menuGrid');
const staffFull = document.getElementById('staffFull');
const staffBadge = document.getElementById('staffBadge');
const logoutStaff = document.getElementById('logoutStaff');
const shiftBtn = document.getElementById('shiftBtn');
const breakBtn = document.getElementById('breakBtn');
const shiftStart = document.getElementById('shiftStart');
const shiftEnd = document.getElementById('shiftEnd');
const saveShift = document.getElementById('saveShift');
const shiftList = document.getElementById('shiftList');
const staffOrderList = document.getElementById('staffOrderList');
const pendingTasksSmall = document.getElementById('pendingTasksSmall');

const modalMakeLatte = document.getElementById('modalMakeLatte');
const makerName = document.getElementById('makerName');
const makeTitleEl = document.getElementById('makeTitle');
const espressoLabelEl = document.getElementById('espressoLabel');
const milkLabelEl = document.getElementById('milkLabel');
const artLabelEl = document.getElementById('artLabel');

const artBg = document.getElementById('artBg');
const artLayer = document.getElementById('artLayer');
const artBgCtx = artBg.getContext('2d');
const artLayerCtx = artLayer.getContext('2d');
const penMode = document.getElementById('penMode');
const penSize = document.getElementById('penSize');
const clearArt = document.getElementById('clearArt');
const saveArt = document.getElementById('saveArt');
const artBgColor = document.getElementById('artBgColor');
const artPenColor = document.getElementById('artPenColor');

const cardCanvas = document.getElementById('cardCanvas');
const cardCtx = cardCanvas.getContext('2d');
const cardMode = document.getElementById('cardMode');
const cardSize = document.getElementById('cardSize');
const clearCard = document.getElementById('clearCard');
const saveCard = document.getElementById('saveCard');
const cardBgColor = document.getElementById('cardBgColor');
const cardPenColor = document.getElementById('cardPenColor');

const modalEat = document.getElementById('modalEat');
const servedImage = document.getElementById('servedImage');
const servedArtMini = document.getElementById('servedArtMini');
const servedCardMini = document.getElementById('servedCardMini');
const saveAllBtn = document.getElementById('saveAllBtn');
const homeFromEat = document.getElementById('homeFromEat');
const orderStatusOverlay = document.getElementById('orderStatusOverlay');
const orderStatusMain = document.getElementById('orderStatusMain');
const orderStatusSub = document.getElementById('orderStatusSub');

const bgmBtn = document.getElementById('bgmBtn');
const soundOverlay = document.getElementById('soundOverlay');
const enableSoundBtn = document.getElementById('enableSoundBtn');
const disableSoundBtn = document.getElementById('disableSoundBtn');

/* audio helper */
function getAssetUrl(path){
  if (!path) return '';
  if (path.startsWith('@')) return 'https://raw.githubusercontent.com/' + path.slice(1);
  try { return new URL(path).href; } catch(e){ return path; }
}
const audioTyaimu = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/tyaimu.mp3'));
const audioCookbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/cookbgm.mp3'));
const audioCookdbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/cookdbgm.mp3'));
const audioRate = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/rate.mp3'));
const audioJ = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/J.mp3'));
const audioE = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/E.mp3'));
const audioC = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/C.mp3'));
const audioK = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/K.mp3'));

/* Firestore cols */
const staffsCol = collection(db, 'staffs');
const ordersCol = collection(db, 'orders');

/* state */
const state = { staffs:[], orders:[], currentUser:{role:'guest', staffId:null}, currentOrderIdForClient:null, audioUnlocked:false, pendingPlayQueue:[] };

/* MENUS: include uiLabels for the 4 UI parts requested */
const MENUS = {
  rate: {
    id:'rate', title:'カフェラテ', imageBase:'@zzcafe2800/reiji_cafe/main/rate', frameCount:5, lastFrameRandom:true,
    password:'', longPressSound:'@zzcafe2800/reiji_cafe/main/rate.mp3', clickSound:'@zzcafe2800/reiji_cafe/main/rate.mp3',
    artBg:'#6b3b24', artPen:'#ffffff', cardBg:'#fff2e6', cardPen:'#000000',
    uiLabels: { makeTitle:'カフェラテ制作', espressoLabel:'エスプレッソ注ぎ', milkLabel:'フームドミルク注ぎ', artLabel:'ラテアート' }
  },
  omu: {
    id:'omu', title:'オムライス', imageBase:'@zzcafe2800/reiji_cafe/main/omu', frameCount:5, lastFrameRandom:true,
    password:'0000', longPressSound:'@zzcafe2800/reiji_cafe/main/omu.mp3', clickSound:'@zzcafe2800/reiji_cafe/main/omu.mp3',
    artBg:'#ffd66b', artPen:'#ff0000', cardBg:'#fff2e6', cardPen:'#000000',
    uiLabels: { makeTitle:'オムライス制作', espressoLabel:'調理行程①', milkLabel:'調理行程②', artLabel:'盛り付け' }
  }
};

/* --- realtime listeners --- */
try {
  const q = query(staffsCol, orderBy('createdAt','asc'));
  onSnapshot(q, snap=>{
    state.staffs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    renderShiftShort();
    renderShiftList();
    updateOrderButtonState();
  });
} catch(e){ console.warn(e); }
try {
  const q2 = query(ordersCol, orderBy('createdAt','asc'));
  onSnapshot(q2, snap=>{
    const prev = state.orders;
    state.orders = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    renderOrderLists();
    handleOrderNotifications(prev, state.orders);
    updateClientOverlay();
  });
} catch(e){ console.warn(e); }

/* helper functions */
setInterval(()=> nowtimeEl.textContent = new Date().toLocaleTimeString(), 1000);
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function uid(p='id'){ return p + Math.random().toString(36).slice(2,9); }

/* render menu grid (with J/E/C/K buttons) */
async function buildMenuGrid(){
  menuGrid.innerHTML = '';
  for (const id in MENUS){
    const it = MENUS[id];
    const card = document.createElement('div'); card.className='menu-item';
    const img = document.createElement('img'); img.className='menu-thumb';
    const url = getAssetUrl(it.imageBase + '1.png');
    try { const res = await fetch(url); if (res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = makePlaceholder(it.title); } catch(e){ img.src = makePlaceholder(it.title); }
    const title = document.createElement('div'); title.textContent = it.title;
    // action buttons row (J/E/C/K)
    const actions = document.createElement('div'); actions.className='menu-actions';
    const flags = [
      { key:'J', img:'@zzcafe2800/reiji_cafe/main/J.png', audio: audioJ },
      { key:'E', img:'@zzcafe2800/reiji_cafe/main/E.png', audio: audioE },
      { key:'C', img:'@zzcafe2800/reiji_cafe/main/C.png', audio: audioC },
      { key:'K', img:'@zzcafe2800/reiji_cafe/main/K.png', audio: audioK }
    ];
    for (const f of flags){
      const b = document.createElement('div'); b.className='flag-btn';
      const im = document.createElement('img'); im.src = getAssetUrl(f.img); im.style.maxHeight='22px'; im.style.maxWidth='36px'; b.appendChild(im);
      const hint = document.createElement('div'); hint.className='flag-hint'; hint.textContent = '使い方\nHow to use\n使用方法\n사용 방법'.split('\n')[0]; // 見た目のため1行（右下）
      b.appendChild(hint);
      b.onclick = (e)=>{
        e.stopPropagation();
        try { f.audio.currentTime = 0; f.audio.play().catch(()=>{}); } catch(e){ console.warn(e); }
        // additionally play each other once as perご要望: play the other three once
        for (const other of flags){
          if (other === f) continue;
          try { other.audio.currentTime = 0; other.audio.play().catch(()=>{}); } catch(e){}
        }
      };
      actions.appendChild(b);
    }
    // clicking the card opens menu selection/order (preserve previous flow)
    card.addEventListener('click', ()=> onMenuSelect(it));
    card.appendChild(img); card.appendChild(title); card.appendChild(actions);
    menuGrid.appendChild(card);
  }
}
function makePlaceholder(title){ const c=document.createElement('canvas');c.width=320;c.height=240;const ctx=c.getContext('2d');ctx.fillStyle='#fff8ef';ctx.fillRect(0,0,c.width,c.height);ctx.fillStyle='#6b3b24';ctx.beginPath();ctx.arc(160,110,60,0,Math.PI*2);ctx.fill();ctx.fillStyle='#fff';ctx.font='20px sans-serif';ctx.fillText(title,100,200);return c.toDataURL(); }

/* order flow */
orderBtn.addEventListener('click', ()=>{
  if (orderBtn.classList.contains('disabled')) return;
  if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'tyaimu' });
  else { try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{}); } catch(e){} }
  showModal(modalName);
  okOrderName.onclick = ()=> {
    const name = orderName.value.trim(); if (!name) { alert('名前を入力してください'); return; }
    hideModal(modalName);
    // open menu grid (we're already showing menuGrid)
  };
});
async function onMenuSelect(item){
  const name = orderName.value.trim() || '名無し';
  if (item.password && item.password.length){
    const entered = prompt('パスワードを入力してください');
    if (entered === null) return;
    if (entered !== item.password){ alert('パスワードが違います'); return; }
    if (state.audioUnlocked) { try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{});}catch(e){} }
  }
  const createdAt = Date.now(); const expiresAt = createdAt + 5*60*1000;
  const orderObj = { name, item:item.id, itemImageBase:item.imageBase, state:'waiting', createdAt, expiresAt, assignedTo:null, assignedToName:null, artStrokes:null, cardStrokes:null, artMeta:null, cardMeta:null, artDataUrl:null, cardDataUrl:null, servedImageData:null };
  try {
    const ref = await addDoc(ordersCol, orderObj);
    state.currentOrderIdForClient = ref.id;
    showClientStatus('現在対応待ち中');
    scheduleOrderTimeout(ref.id, expiresAt);
  } catch(e){ console.warn(e); alert('注文に失敗しました'); }
}

/* schedule timeout */
async function scheduleOrderTimeout(orderId, expiresAt){
  const remaining = (expiresAt || 0) - Date.now();
  if (remaining <= 0) return;
  setTimeout(async ()=>{
    try {
      const snap = await getDoc(doc(db,'orders',orderId));
      if (snap.exists()){
        const o = snap.data();
        if (o.state === 'waiting'){
          await updateDoc(doc(db,'orders',orderId), { state:'cancelled', cancelReason:'スタッフの応答がないため現在注文を取り消しになります' });
        }
      }
    } catch(e){ console.warn(e); }
  }, remaining);
}

/* assign & make */
async function assignOrderToCurrentStaff(orderId){
  const staffId = state.currentUser.staffId; if (!staffId) { alert('スタッフとしてログインしてください'); return; }
  const s = state.staffs.find(x=>x.id===staffId);
  try {
    await updateDoc(doc(db,'orders',orderId), { state:'inprogress', assignedTo: staffId, assignedToName: s.name });
    if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'cook', orderId });
    else { try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} }
  } catch(e){ console.warn(e); }
}

/* strokes helpers - normalized storage */
/* normalize/denorm */
function normPointInCanvas(pt, canvas){ return { x: pt.x / canvas.width, y: pt.y / canvas.height }; }
function denormPoint(p, canvas){ return { x: (p.x || 0) * canvas.width, y: (p.y || 0) * canvas.height }; }

/* init canvases */
function initArtCanvas(bg='#6b3b24'){
  artBgCtx.clearRect(0,0,artBg.width,artBg.height);
  artBgCtx.fillStyle = bg; artBgCtx.beginPath(); artBgCtx.arc(120,120,100,0,Math.PI*2); artBgCtx.fill();
  artLayerCtx.clearRect(0,0,artLayer.width,artLayer.height); artLayerCtx.lineCap='round'; artLayerCtx.lineJoin='round';
}
function initCardCanvas(bg='#fff2e6'){
  cardCtx.clearRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.fillStyle = bg; cardCtx.fillRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.lineCap='round'; cardCtx.lineJoin='round';
}
initArtCanvas(); initCardCanvas();

/* maintain per-modal local strokes only for the order */
let localArtStrokes = [], localCardStrokes = [], localSavedArtMeta = null, localSavedCardMeta = null;
let artDrawing=false, cardDrawing=false, currentArtStroke=null, currentCardStroke=null;

function getEventPos(e, canvas){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : null;
  const cx = t ? t.clientX : e.clientX;
  const cy = t ? t.clientY : e.clientY;
  return { x: (cx - r.left) * (canvas.width / r.width), y: (cy - r.top) * (canvas.height / r.height) };
}

/* art handlers (local) */
artLayer.addEventListener('mousedown', (e)=>{
  artDrawing = true;
  const p = getEventPos(e, artLayer);
  currentArtStroke = { tool: penMode.value, width: parseInt(penSize.value,10), points:[ normPointInCanvas(p, artLayer) ], pen: artPenColor.value };
});
artLayer.addEventListener('mousemove', (e)=>{
  if (!artDrawing || !currentArtStroke) return;
  const p = getEventPos(e, artLayer); currentArtStroke.points.push(normPointInCanvas(p, artLayer)); renderLatestArtStrokeSegment(currentArtStroke);
});
artLayer.addEventListener('mouseup', ()=>{ if (!artDrawing) return; artDrawing=false; if (currentArtStroke){ localArtStrokes.push(currentArtStroke); currentArtStroke=null; saveArt.disabled=false; updateTaskStatus(); } });
artLayer.addEventListener('mouseleave', ()=>{ if (artDrawing){ artDrawing=false; if (currentArtStroke){ localArtStrokes.push(currentArtStroke); currentArtStroke=null; saveArt.disabled=false; updateTaskStatus(); } } });
artLayer.addEventListener('touchstart',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousedown', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
artLayer.addEventListener('touchmove',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousemove', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
artLayer.addEventListener('touchend',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mouseup')); });

function renderLatestArtStrokeSegment(stroke){
  if (!stroke || stroke.points.length < 2) return;
  const p1 = denormPoint(stroke.points[stroke.points.length-2], artLayer);
  const p2 = denormPoint(stroke.points[stroke.points.length-1], artLayer);
  if (stroke.tool === 'draw'){ artLayerCtx.globalCompositeOperation='source-over'; artLayerCtx.strokeStyle=stroke.pen||'#fff'; artLayerCtx.lineWidth=stroke.width; }
  else { artLayerCtx.globalCompositeOperation='destination-out'; artLayerCtx.lineWidth=stroke.width; }
  artLayerCtx.beginPath(); artLayerCtx.moveTo(p1.x,p1.y); artLayerCtx.lineTo(p2.x,p2.y); artLayerCtx.stroke();
}

/* card handlers (local) */
cardCanvas.addEventListener('mousedown', (e)=>{
  cardDrawing = true;
  const p = getEventPos(e, cardCanvas);
  currentCardStroke = { tool: cardMode.value, width: parseInt(cardSize.value,10), points:[ normPointInCanvas(p, cardCanvas) ], pen: cardPenColor.value };
});
cardCanvas.addEventListener('mousemove', (e)=>{
  if (!cardDrawing || !currentCardStroke) return;
  const p = getEventPos(e, cardCanvas); currentCardStroke.points.push(normPointInCanvas(p, cardCanvas)); renderLatestCardStrokeSegment(currentCardStroke);
});
cardCanvas.addEventListener('mouseup', ()=>{ if (!cardDrawing) return; cardDrawing=false; if (currentCardStroke){ localCardStrokes.push(currentCardStroke); currentCardStroke=null; saveCard.disabled=false; updateTaskStatus(); } });
cardCanvas.addEventListener('mouseleave', ()=>{ if (cardDrawing){ cardDrawing=false; if (currentCardStroke){ localCardStrokes.push(currentCardStroke); currentCardStroke=null; saveCard.disabled=false; updateTaskStatus(); } } });
cardCanvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousedown', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
cardCanvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousemove', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
cardCanvas.addEventListener('touchend',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mouseup')); });

function renderLatestCardStrokeSegment(stroke){
  if (!stroke || stroke.points.length < 2) return;
  const p1 = denormPoint(stroke.points[stroke.points.length-2], cardCanvas);
  const p2 = denormPoint(stroke.points[stroke.points.length-1], cardCanvas);
  if (stroke.tool === 'draw'){ cardCtx.globalCompositeOperation='source-over'; cardCtx.strokeStyle=stroke.pen||'#000'; cardCtx.lineWidth=stroke.width; }
  else { cardCtx.globalCompositeOperation='destination-out'; cardCtx.lineWidth=stroke.width; }
  cardCtx.beginPath(); cardCtx.moveTo(p1.x,p1.y); cardCtx.lineTo(p2.x,p2.y); cardCtx.stroke();
}

/* clear/save local */
clearArt.addEventListener('click', ()=>{ initArtCanvas(artBgColor.value); localArtStrokes=[]; saveArt.disabled=true; updateTaskStatus(); });
clearCard.addEventListener('click', ()=>{ initCardCanvas(cardBgColor.value); localCardStrokes=[]; saveCard.disabled=true; updateTaskStatus(); });

let currentMakingOrderId = null;

/* saveArt: create high-res PNG + save strokes and meta to local variables for this order only */
saveArt.addEventListener('click', ()=>{
  const scale=2;
  const tmp=document.createElement('canvas'); tmp.width = artLayer.width*scale; tmp.height=artLayer.height*scale; const t = tmp.getContext('2d');
  t.fillStyle = artBgColor.value; t.fillRect(0,0,tmp.width,tmp.height);
  // draw strokes scaled
  for (const s of localArtStrokes){
    t.beginPath(); t.globalCompositeOperation = s.tool==='draw'?'source-over':'destination-out'; t.strokeStyle = s.pen || artPenColor.value; t.lineWidth = (s.width||4)*scale;
    for (let i=0;i<s.points.length;i++){ const p=s.points[i]; const x = p.x*tmp.width, y = p.y*tmp.height; if (i===0) t.moveTo(x,y); else t.lineTo(x,y); }
    t.stroke(); t.globalCompositeOperation='source-over';
  }
  localSavedArtMeta = { origW: artLayer.width, origH: artLayer.height, savedW: tmp.width, savedH: tmp.height, bg: artBgColor.value, penDefault: artPenColor.value, scale };
  const dataUrl = tmp.toDataURL('image/png');
  // keep local until completeMake writes to Firestore for the specific order
  window.__lastSavedArt = { strokes: JSON.parse(JSON.stringify(localArtStrokes)), dataUrl, meta: localSavedArtMeta };
  saveArt.disabled=true; updateTaskStatus(); alert('アートをローカル保存しました。提供でFirestoreへ書き込みます。');
});

/* saveCard */
saveCard.addEventListener('click', ()=>{
  const scale=2;
  const tmp=document.createElement('canvas'); tmp.width = cardCanvas.width*scale; tmp.height = cardCanvas.height*scale; const t = tmp.getContext('2d');
  t.fillStyle = cardBgColor.value; t.fillRect(0,0,tmp.width,tmp.height);
  for (const s of localCardStrokes){
    t.beginPath(); t.globalCompositeOperation = s.tool==='draw'?'source-over':'destination-out'; t.strokeStyle = s.pen || cardPenColor.value; t.lineWidth = (s.width||3)*scale;
    for (let i=0;i<s.points.length;i++){ const p=s.points[i]; const x=p.x*tmp.width, y=p.y*tmp.height; if (i===0) t.moveTo(x,y); else t.lineTo(x,y); }
    t.stroke(); t.globalCompositeOperation='source-over';
  }
  localSavedCardMeta = { origW: cardCanvas.width, origH: cardCanvas.height, savedW: tmp.width, savedH: tmp.height, bg: cardBgColor.value, penDefault: cardPenColor.value, scale };
  const dataUrl = tmp.toDataURL('image/png');
  window.__lastSavedCard = { strokes: JSON.parse(JSON.stringify(localCardStrokes)), dataUrl, meta: localSavedCardMeta };
  saveCard.disabled=true; updateTaskStatus(); alert('カードをローカル保存しました。提供でFirestoreへ書き込みします。');
});

/* updateTaskStatus */
function updateTaskStatus(){
  const parts=[];
  // pouring not fully tracked here, keep simple
  if ((!window.__lastSavedArt || !window.__lastSavedArt.strokes) && localArtStrokes.length===0) parts.push('アート');
  if ((!window.__lastSavedCard || !window.__lastSavedCard.strokes) && localCardStrokes.length===0) parts.push('カード');
  taskStatusSmall.textContent = parts.length ? '未完了: '+parts.join(', ') : 'すべて完了';
  completeMake.disabled = parts.length !== 0;
}

/* openMakeModal: prepare local canvases for the specific order (do NOT reuse other orders' data) */
function openMakeModal(order){
  currentMakingOrderId = order.id;
  makerName.textContent = order.assignedToName || order.assignedTo || '';
  // set UI labels from menu config if available
  const cfg = MENUS[order.item] || {};
  makeTitleEl.textContent = (cfg.uiLabels?.makeTitle || 'カフェラテ制作') + '（担当：' + (order.assignedToName||'') + '）';
  espressoLabelEl.textContent = cfg.uiLabels?.espressoLabel || 'エスプレッソ注ぎ';
  milkLabelEl.textContent = cfg.uiLabels?.milkLabel || 'フームドミルク注ぎ';
  artLabelEl.textContent = cfg.uiLabels?.artLabel || 'ラテアート';
  // clear local strokes and initialize canvas based on order.meta if present
  localArtStrokes = []; localCardStrokes = []; localSavedArtMeta = null; localSavedCardMeta = null; window.__lastSavedArt = null; window.__lastSavedCard = null;
  if (order.artMeta){
    initArtCanvas(order.artMeta.bg || cfg.artBg);
    // if order already has artStrokes (shouldn't for new orders), show preview but do NOT make it global
    if (order.artStrokes){ replayStrokesOnCanvasImmediate(order.artStrokes, artLayer, artLayerCtx, order.artMeta); }
  } else { initArtCanvas(cfg.artBg || '#6b3b24'); }
  if (order.cardMeta){
    initCardCanvas(order.cardMeta.bg || cfg.cardBg);
    if (order.cardStrokes){ replayStrokesOnCanvasImmediate(order.cardStrokes, cardCanvas, cardCtx, order.cardMeta); }
  } else { initCardCanvas(cfg.cardBg || '#fff2e6'); }
  saveArt.disabled=true; saveCard.disabled=true; updateTaskStatus();
  modalMakeLatte.style.display = 'flex';
}

/* replay strokes helper (used for preview) */
function replayStrokesOnCanvasImmediate(strokes, canvasEl, ctx, meta){
  if (!strokes || !strokes.length) return;
  ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
  if (meta && meta.bg){ ctx.fillStyle = meta.bg; ctx.fillRect(0,0,canvasEl.width,canvasEl.height); }
  ctx.lineCap='round'; ctx.lineJoin='round';
  for (const s of strokes){
    ctx.beginPath();
    ctx.strokeStyle = s.pen || (meta?.penDefault) || '#000';
    ctx.lineWidth = (s.width || 3) * ((canvasEl.width/(meta?.origW||canvasEl.width)));
    if (s.tool === 'draw') ctx.globalCompositeOperation='source-over'; else ctx.globalCompositeOperation='destination-out';
    for (let i=0;i<s.points.length;i++){
      const p=s.points[i]; const x = p.x * canvasEl.width; const y = p.y * canvasEl.height;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke(); ctx.closePath(); ctx.globalCompositeOperation='source-over';
  }
}

/* completeMake: write art/card strokes+meta+dataUrl into the specific order doc and set state delivered */
document.getElementById('completeMake').addEventListener('click', async ()=>{
  if (!currentMakingOrderId){ alert('対象注文がありません'); return; }
  const artToSave = window.__lastSavedArt ? window.__lastSavedArt.strokes : localArtStrokes;
  const cardToSave = window.__lastSavedCard ? window.__lastSavedCard.strokes : localCardStrokes;
  const artMeta = window.__lastSavedArt ? window.__lastSavedArt.meta : (localSavedArtMeta || null);
  const cardMeta = window.__lastSavedCard ? window.__lastSavedCard.meta : (localSavedCardMeta || null);
  const artDataUrl = window.__lastSavedArt ? window.__lastSavedArt.dataUrl : null;
  const cardDataUrl = window.__lastSavedCard ? window.__lastSavedCard.dataUrl : null;
  // compose servedImage into high-res
  const tmp = document.createElement('canvas'); tmp.width=800; tmp.height=800; const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff8ef'; tctx.fillRect(0,0,tmp.width,tmp.height);
  // draw saved art or strokes
  if (artDataUrl){ const img = new Image(); img.src = artDataUrl; await new Promise(r=>{ img.onload=r; img.onerror=r; }); tctx.drawImage(img, 220,80,360,360); }
  else if (artToSave && artToSave.length){ const artTmp = document.createElement('canvas'); artTmp.width=360; artTmp.height=360; const actx = artTmp.getContext('2d'); actx.fillStyle = artMeta?.bg || '#6b3b24'; actx.fillRect(0,0,artTmp.width,artTmp.height); replayStrokesOnCanvasImmediate(artToSave, artTmp, actx, artMeta); tctx.drawImage(artTmp,220,80,360,360); }
  // draw card
  if (cardDataUrl){ const img2 = new Image(); img2.src = cardDataUrl; await new Promise(r=>{ img2.onload=r; img2.onerror=r; }); tctx.drawImage(img2, 200,500,400,160); }
  else if (cardToSave && cardToSave.length){ const cardTmp = document.createElement('canvas'); cardTmp.width=400; cardTmp.height=160; const cctx = cardTmp.getContext('2d'); cctx.fillStyle = cardMeta?.bg || '#fff2e6'; cctx.fillRect(0,0,cardTmp.width,cardTmp.height); replayStrokesOnCanvasImmediate(cardToSave, cardTmp, cctx, cardMeta); tctx.drawImage(cardTmp,200,500,400,160); }
  const servedDataUrl = tmp.toDataURL('image/png');
  try {
    await updateDoc(doc(db,'orders',currentMakingOrderId), {
      state:'delivered', deliveredAt: Date.now(),
      servedImageData: servedDataUrl,
      artStrokes: artToSave || null, cardStrokes: cardToSave || null,
      artMeta: artMeta || null, cardMeta: cardMeta || null,
      artDataUrl: artDataUrl || null, cardDataUrl: cardDataUrl || null
    });
    // stop cookbgm for staff who created it
    try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
    modalMakeLatte.style.display = 'none';
    currentMakingOrderId = null;
    localArtStrokes=[]; localCardStrokes=[]; window.__lastSavedArt=null; window.__lastSavedCard=null;
    alert('提供しました（Firestoreへ保存）');
  } catch(e){ console.warn(e); alert('提供の保存に失敗しました'); }
});

/* client overlay update */
function showClientStatus(text){ orderStatusMain.textContent = text; orderStatusSub.textContent = '①注意：事故として必ずスタッフ（店員）が対応できない場合もございます'; orderStatusOverlay.style.display = 'flex'; }
function hideClientStatus(){ orderStatusOverlay.style.display = 'none'; }

function updateClientOverlay(){
  if (!state.currentOrderIdForClient) return;
  const o = state.orders.find(x=>x.id===state.currentOrderIdForClient);
  if (!o) return;
  if (o.state === 'waiting'){ showClientStatus('現在対応待ち中'); }
  else if (o.state === 'inprogress'){ showClientStatus('現在調理中…'); if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'cook', orderId: o.id }); else { try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} } }
  else if (o.state === 'delivered'){ showClientServed(o); hideClientStatus(); }
  else if (o.state === 'cancelled'){ showClientStatus('スタッフの応答がないため現在注文を取り消しになります'); setTimeout(()=>{ hideClientStatus(); state.currentOrderIdForClient=null; }, 10000); }
}

/* show served to the order client only; reconstruct from strokes/meta or use servedImageData */
async function showClientServed(order){
  // stop cookbgm for client when entering eat screen
  try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
  if (order.servedImageData){ servedImage.src = order.servedImageData; }
  else { servedImage.src = getAssetUrl(order.itemImageBase + '1.png'); }
  // art mini
  const artCtx = servedArtMini.getContext('2d'); artCtx.clearRect(0,0,servedArtMini.width,servedArtMini.height);
  artCtx.fillStyle = (order.artMeta && order.artMeta.bg) || MENUS[order.item]?.artBg || '#6b3b24'; artCtx.fillRect(0,0,servedArtMini.width,servedArtMini.height);
  if (order.artStrokes && order.artStrokes.length) replayStrokesOnCanvasImmediate(order.artStrokes, servedArtMini, artCtx, order.artMeta);
  else if (order.artDataUrl){ const i=new Image(); i.src=order.artDataUrl; await new Promise(r=>{ i.onload=r; i.onerror=r; }); artCtx.drawImage(i,0,0,servedArtMini.width,servedArtMini.height); }
  // card mini
  const cardCtxMini = servedCardMini.getContext('2d'); cardCtxMini.clearRect(0,0,servedCardMini.width,servedCardMini.height);
  cardCtxMini.fillStyle = (order.cardMeta && order.cardMeta.bg) || MENUS[order.item]?.cardBg || '#fff2e6'; cardCtxMini.fillRect(0,0,servedCardMini.width,servedCardMini.height);
  if (order.cardStrokes && order.cardStrokes.length) replayStrokesOnCanvasImmediate(order.cardStrokes, servedCardMini, cardCtxMini, order.cardMeta);
  else if (order.cardDataUrl){ const im=new Image(); im.src=order.cardDataUrl; await new Promise(r=>{ im.onload=r; im.onerror=r; }); cardCtxMini.drawImage(im,0,0,servedCardMini.width,servedCardMini.height); }
  document.getElementById('modalEat').style.display = 'flex';
}

/* preload frames simplified */
async function preloadFrames(basePath, frameCount=5, lastRandom=false){
  const arr=[];
  for (let i=1;i<=frameCount;i++){
    let name = i;
    if (i===frameCount && lastRandom){ name = (Math.random()<0.5?String(frameCount):('0'+frameCount)); }
    const url = getAssetUrl(basePath + name + '.png');
    try { const res = await fetch(url); if (!res.ok) continue; const blob = await res.blob(); arr.push(URL.createObjectURL(blob)); } catch(e){ continue; }
  }
  return arr;
}

/* served image long-press loop with reliable stop */
let servedLoopAudio = null;
let servedLoopRunning = false;
async function startServedPress(e){
  e.preventDefault();
  if (servedLoopRunning) return;
  servedLoopRunning = true;
  const order = state.orders.find(o=>o.id===state.currentOrderIdForClient);
  const soundUrl = order ? (MENUS[order.item]?.longPressSound || MENUS['rate'].longPressSound) : MENUS['rate'].longPressSound;
  if (!state.audioUnlocked){ state.pendingPlayQueue.push({ type:'longpress', orderId: state.currentOrderIdForClient, soundUrl }); servedLoopRunning=false; return; }
  servedLoopAudio = new Audio(getAssetUrl(soundUrl));
  servedLoopAudio.preload = 'auto';
  // loop with 1.5s gap
  while(servedLoopRunning){
    try { await servedLoopAudio.play().catch(()=>{}); await new Promise(r=>{ servedLoopAudio.onended = ()=> r(); setTimeout(()=>r(), 6000); }); } catch(e){ console.warn(e); await new Promise(r=>setTimeout(r,1500)); }
    if (!servedLoopRunning) break;
    await new Promise(r=>setTimeout(r,1500));
    if (!servedLoopRunning) break;
    // create a fresh audio instance to ensure replay reliability
    servedLoopAudio = new Audio(getAssetUrl(soundUrl));
  }
}
function endServedPress(e){
  e && e.preventDefault();
  if (!servedLoopRunning) return;
  servedLoopRunning = false;
  // stop audio
  if (servedLoopAudio){ try{ servedLoopAudio.pause(); servedLoopAudio.currentTime = 0; } catch(e){} servedLoopAudio = null; }
  // advance image once
  if (servedSequence && servedSequence.length && servedSequenceIndex < servedSequence.length - 1){
    servedSequenceIndex++; servedImage.src = servedSequence[servedSequenceIndex];
  }
}
servedImage.addEventListener('mousedown', startServedPress);
servedImage.addEventListener('mouseup', endServedPress);
servedImage.addEventListener('mouseleave', endServedPress);
servedImage.addEventListener('touchstart', (e)=>{ e.preventDefault(); startServedPress(e); }, {passive:false});
servedImage.addEventListener('touchend', (e)=>{ e.preventDefault(); endServedPress(e); }, {passive:false});

/* ensure rate.mp3 stops on release (extra guard) */
function stopAllRateAudio(){ try{ audioRate.pause(); audioRate.currentTime=0; }catch(e){} if (servedLoopAudio){ try{ servedLoopAudio.pause(); servedLoopAudio.currentTime=0; }catch(e){} servedLoopAudio=null; servedLoopRunning=false; } }
document.addEventListener('mouseup', stopAllRateAudio);
document.addEventListener('touchend', stopAllRateAudio);

/* homeFromEat: when client returns home, clear its order's art/card data from Firestore */
homeFromEat.addEventListener('click', async ()=>{
  document.getElementById('modalEat').style.display = 'none';
  const id = state.currentOrderIdForClient;
  if (!id) return;
  try {
    await updateDoc(doc(db,'orders',id), {
      artStrokes: null, cardStrokes: null, artMeta: null, cardMeta: null, artDataUrl: null, cardDataUrl: null, servedImageData: null
    });
  } catch(e){ console.warn('failed to clear art data', e); }
  state.currentOrderIdForClient = null;
});

/* handle notifications: play tyaimu/cook/delivered to appropriate clients (queued if not unlocked) */
function handleOrderNotifications(prev, curr){
  const prevMap = new Map(prev.map(o=>[o.id,o]));
  for (const o of curr){
    if (o.state === 'waiting' && !prevMap.has(o.id)){
      if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'tyaimu', orderId:o.id }); else { try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{});}catch(e){} }
    }
    if (o.state === 'inprogress'){
      if (state.currentOrderIdForClient === o.id){ if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'cook', orderId:o.id }); else { try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} } }
    }
    if (o.state === 'delivered'){
      if (state.currentOrderIdForClient === o.id){ if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'delivered', orderId:o.id }); else { try{ audioCookdbgm.currentTime=0; audioCookdbgm.play().catch(()=>{}); } catch(e){} } }
    }
  }
}

/* flush pending plays once user enables sound */
enableSoundBtn.addEventListener('click', ()=>{
  state.audioUnlocked = true;
  try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); ctx.resume && ctx.resume(); ctx.close && ctx.close(); } catch(e){}
  soundOverlay.style.display = 'none';
  for (const r of state.pendingPlayQueue){
    if (r.type === 'tyaimu'){ try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{});}catch(e){} }
    if (r.type === 'cook'){ try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{});}catch(e){} }
    if (r.type === 'delivered'){ try{ audioCookdbgm.currentTime=0; audioCookdbgm.play().catch(()=>{});}catch(e){} }
  }
  state.pendingPlayQueue = [];
});
disableSoundBtn.addEventListener('click', ()=>{ soundOverlay.style.display='none'; });

/* staff login & shift toggles */
passOk.addEventListener('click', ()=> {
  if (staffPass.value === '1232'){ showModal(modalName); okOrderName.onclick = async ()=>{ const name = orderName.value.trim(); if(!name){ alert('名前'); return; } hideModal(modalName); try{ const ref = await addDoc(staffsCol, { name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt:Date.now() }); enterStaff(ref.id,name); }catch(e){ console.warn(e); enterStaff(uid('s'), name); } }; } else alert('パスワードが違います');
});
function enterStaff(id,name){ state.currentUser = { role:'staff', staffId:id }; staffBadge.textContent = name; staffFull.classList.add('show'); renderShiftList(); renderOrderLists(); }
logoutStaff.addEventListener('click', async ()=> { const id=state.currentUser.staffId; if (id){ try{ await deleteDoc(doc(db,'staffs',id)); }catch(e){} } state.currentUser={role:'guest',staffId:null}; staffFull.classList.remove('show'); });

shiftBtn.addEventListener('click', async ()=>{
  const id = state.currentUser.staffId; if (!id) return;
  try { await updateDoc(doc(db,'staffs',id), { onShift:true, breaking:false }); shiftBtn.classList.add('on'); shiftBtn.classList.remove('off'); breakBtn.classList.remove('on'); breakBtn.classList.add('off'); } catch(e){ console.warn(e); }
});
breakBtn.addEventListener('click', async ()=>{
  const id = state.currentUser.staffId; if (!id) return;
  try { await updateDoc(doc(db,'staffs',id), { onShift:false, breaking:true }); breakBtn.classList.add('on'); breakBtn.classList.remove('off'); shiftBtn.classList.remove('on'); shiftBtn.classList.add('off'); } catch(e){ console.warn(e); }
});

/* render shifts and orders */
function renderShiftShort(){
  const now = new Date();
  const active = state.staffs.filter(s=>s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  shiftShort.textContent = !active.length ? '状況①：現在、スタッフ対応不可（シフト外／休憩中）' : '状況①：' + active.map(s=>`${s.name} (${s.shiftStart}〜${s.shiftEnd})`).join(' / ');
}
function renderShiftList(){ shiftList.innerHTML=''; const now=new Date(); state.staffs.forEach(s=>{ const div=document.createElement('div'); const onNow=isNowWithinShift(s.shiftStart,s.shiftEnd,now); div.innerHTML=`<strong>${escapeHtml(s.name)}</strong> ${s.shiftStart||''}〜${s.shiftEnd||''} ${s.onShift?'<span style="color:green">シフト中</span>':'<span style="color:gray">-</span>'} ${s.breaking?'<span style="color:orange">休憩中</span>':''} ${onNow?'<span class="small-info">（現在この時間）</span>':''}`; shiftList.appendChild(div); }); }
function isNowWithinShift(start,end,dateObj){ if(!start||!end) return false; const [sh,sm]=start.split(':').map(Number); const [eh,em]=end.split(':').map(Number); const sDate=new Date(dateObj); sDate.setHours(sh,sm,0,0); const eDate=new Date(dateObj); eDate.setHours(eh,em,0,0); if (eDate<=sDate) eDate.setDate(eDate.getDate()+1); return dateObj>=sDate && dateObj<=eDate; }
function renderOrderLists(){ staffOrderList.innerHTML=''; state.orders.forEach(o=>{ if (!o || o.state==='cancelled' || o.state==='delivered' || o.state==='served') return; const div=document.createElement('div'); div.className='order-item'; const left=document.createElement('div'); left.innerHTML=`<strong>${escapeHtml(o.name)}</strong><div class="small-info">${escapeHtml(o.item)} - 状態:${escapeHtml(o.state)} - 作成:${new Date(o.createdAt||0).toLocaleTimeString()}</div>`; const right=document.createElement('div'); if (o.state==='waiting'){ const btn=document.createElement('button'); btn.textContent='対応'; btn.className='small btn-green'; btn.onclick=()=>assignOrderToCurrentStaff(o.id); right.appendChild(btn);} else if (o.state==='inprogress'){ const info=document.createElement('div'); info.className='small-info'; info.textContent=`担当:${escapeHtml(o.assignedToName||o.assignedTo||'')}`; right.appendChild(info); const makeBtn=document.createElement('button'); makeBtn.textContent='制作開始'; makeBtn.className='small'; makeBtn.onclick=()=>openMakeModal(o); right.appendChild(makeBtn);} div.appendChild(left); div.appendChild(right); staffOrderList.appendChild(div); }); pendingTasksSmall.textContent = state.orders.filter(o=>o.state==='waiting' || o.state==='inprogress').length ? ` 未処理:${state.orders.filter(o=>o.state==='waiting' || o.state==='inprogress').length}` : ''; }

/* utility show/hide modal */
function showModal(el){ el.style.display='flex'; }
function hideModal(el){ el.style.display='none'; }

/* menu building and initial setup */
buildMenuGrid().catch(()=>{});
showModal(soundOverlay); // ask for audio unlock by default

/* basic helpers for long-press served sequence (kept simple) */
let servedSequence = [], servedSequenceIndex = 0;

/* stop cookbgm when modalEat opened - already done in showClientServed */

/* initial */
initArtCanvas(); initCardCanvas();

window.__reiji = { state };

</script>
</body>
</html>
