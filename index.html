<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>仮想飲食システム（０時カフェ・ズズカフェ店用）</title>
<meta name="format-detection" content="telephone=no">
<style>
  :root{
    --bg:#f7efe7; --accent:#b33; --paper:#fff8ef; --dark:#3a2b20; --muted:#8b6d5c;
    --card-skin:#fff2e6;
  }
  html,body{height:100%;margin:0;font-family: "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background:linear-gradient(180deg,#fdf2ea 0%,#f7efe7 100%);}

.container{
  width:100%;
  max-width:420px;     /* ← スマホ基準で制限 */
  margin:12px auto;
  padding:0;
  position:relative;
  perspective:2000px;

  aspect-ratio: 3 / 5; /* 縦長本 */
}


/*container{max-width:1100px;margin:18px auto;padding:0;background:none;position:relative; min-height:720px;perspective:2000px;} *//* ====== book ====== */*/
/*.book{position:relative;width:100%;min-height:720px;}*//* 共通ページ */
/*.page{position:absolute;inset:0;border-radius:10px;backface-visibility:hidden;overflow:hidden}*/
.book{
  position:relative;
  width:100%;
  height:100%;
}

.page{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  overflow:hidden;
}

/* 表紙 
.cover{
  background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/menuh1.png")
    center/cover no-repeat;
  transform-origin:right center;
  z-index:2;
}*/

/* OK押した時だけ動く 
.cover.open{
  animation:flip 2.2s ease-in-out forwards;
}*/

  .cover{
  background:url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/menuh1.png")
    center/cover no-repeat;
  transform-origin:right center;
  z-index:2;
  pointer-events:auto;
}

/* 開く前 */
.cover:not(.open){
  transform:rotateY(0deg);
}

/* 開いた後 */
.cover.open{
  animation:flip 2.2s ease-in-out forwards;
  pointer-events:none;
}

/* 完全に影響を断つ */
.cover.open.finished{
  display:none;
}


/* 中ページ（今までのカード） */
.inner{
  position: absolute;
  inset: 0; /* ← 親(.book)いっぱい */
  
  background: url("https://raw.githubusercontent.com/zzcafe2800/reiji_cafe/main/menuh.png")
    center / cover no-repeat;

  box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  border-radius: 10px;
  border: 6px solid var(--accent);
  z-index: 1;

  display: flex;
  flex-direction: column;
  overflow: hidden;
}


/* headerはそのまま使える */
header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px;
  color:var(--dark);
  background:rgba(255,255,255,0.6);
  backdrop-filter:blur(4px);
}

/* ====== アニメーション ====== */
@keyframes flip{
  0%{
    transform:rotateY(0deg);
    box-shadow:0 20px 40px rgba(0,0,0,.25);
  }
  40%{
    transform:rotateY(-55deg);
  }
  70%{
    transform:rotateY(-130deg);
  }
  100%{
    transform:rotateY(-180deg);
    box-shadow:none;
  }
}

/* ====== スマホ対応 ====== */
/*@media (max-width:768px){.container{ min-height:560px;}.book{min-height:560px;}}*/
@media (min-width:768px){.container{width:94vw;margin:12px auto;aspect-ratio: 3 / 5;}}



  .content{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;padding:12px;}
  .order-block{width:100%;max-width:520px;display:flex;flex-direction:column;align-items:center;gap:10px;}
  .status-line{font-weight:700;background:rgba(255,255,255,0.92);padding:8px 12px;border-radius:8px;border:2px solid #f0c6c6;text-align:center;}
  .order-btn{
  background:linear-gradient(180deg,#ffd4c4,#ffb38a);
  border:4px solid var(--accent);
  color:var(--dark);
  padding:22px 36px;
  border-radius:12px;
  font-size:34px;
  cursor:pointer;
  box-shadow:0 6px 0 #913;
  user-select:none;

  width:100%;
  max-width:420px;

  /* 追加：横 5：縦 3 */
  aspect-ratio: 5 / 3;
}

  .order-btn.disabled{opacity:0.4;cursor:not-allowed;box-shadow:none;}
  .small-pass{position:fixed;left:12px;bottom:12px;background:rgba(255,255,255,0.95);padding:6px;border-radius:6px;border:1px dashed #c66;display:flex;align-items:center;gap:6px;z-index:60;}
  .small-pass input{width:100px;padding:4px;}
  .guest-mini{position:fixed;right:12px;bottom:12px;background:var(--paper);padding:8px;border-radius:8px;border:1px solid #e6d6cc;font-size:13px;box-shadow:0 6px 12px rgba(0,0,0,0.08);}
  .staff-full{position:fixed;inset:0;background:linear-gradient(180deg,#fff8f2,#fff3ec);padding:18px;z-index:90;display:none;flex-direction:column;overflow:auto;}
  .staff-full.show{display:flex;}
  .staff-top{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .big-toggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .big-toggle button{flex:1;padding:12px;border-radius:8px;font-size:16px;border:2px solid #c6b3b3;cursor:pointer;}
  .big-toggle .on{background:#2b8f4a;color:#fff;border-color:#2b8f4a;}
  .big-toggle .off{background:#f0f0f0;color:#666;}
  .staff-body{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;}
  .staff-panel{flex:1;min-width:280px;background:var(--paper);padding:12px;border-radius:8px;border:1px solid #e6d6cc;max-height:520px;overflow:auto;}
  .order-item{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;justify-content:space-between;align-items:center;}
  .menu-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;}
  .menu-item{padding:8px;border:2px solid #e0bdb5;background:#fff;border-radius:8px;text-align:center;cursor:pointer;}
  img.menu-thumb{width:100%;height:120px;object-fit:cover;border-radius:6px;}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:100;}
  .modal{background:#fff;padding:16px;border-radius:10px;width:780px;max-width:95%;box-shadow:0 8px 30px rgba(0,0,0,0.4);border:6px solid var(--accent);}
  .art-area{position:relative;width:240px;height:240px;border-radius:6px;overflow:hidden;border:1px solid #d4c0b8;background:#b36e3c;}
  .art-area canvas{position:absolute;left:0;top:0;width:240px;height:240px;}
  .card-canvas{border:1px solid #e6d0c6;background:var(--card-skin);border-radius:8px;}
  .small-info{font-size:12px;color:var(--muted);}
  .status-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:120;flex-direction:column;color:#111;}
  .status-card{width:80%;max-width:720px;background:rgba(255,255,255,0.98);padding:28px;border-radius:12px;border:4px solid var(--accent);text-align:center;font-size:26px;font-weight:700;}
  .status-sub{font-size:14px;color:#444;margin-top:8px;}
  .bgm-btn{font-size:12px;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.95);border:1px solid #e6d0c6;cursor:pointer;}
  .sound-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;background:rgba(0,0,0,0.6);color:#fff;flex-direction:column;}
  .sound-panel{background:#fff;padding:18px;border-radius:12px;color:#111;border:3px solid var(--accent);width:360px;text-align:center;}
  .jukebox{display:flex;gap:8px;align-items:center}
  .jukebox img{width:56px;height:56px;object-fit:cover;border-radius:6px;cursor:pointer;position:relative;}
  .jukebox .hint{position:absolute;right:2px;bottom:2px;font-size:9px;background:rgba(255,255,255,0.9);padding:2px;border-radius:3px;}
  .jukebox .wrapper{position:relative;display:inline-block;}
  @media (max-width:600px){
    .order-btn{font-size:28px;padding:18px 28px;}
    .modal{width:94%;}
    .staff-body{flex-direction:column;}
    .staff-panel{max-height:none;}
    .guest-mini{right:8px;bottom:8px;font-size:12px;padding:6px;}
  }
</style>
</head>
<body>



  
<div class="container">
  <div class="book">

    <!-- 表紙 -->
    <div class="page cover"></div>

    <!-- 2ページ目（今までの.container中身） -->
    <div class="page inner">

      <header>
        <h1>０時過ぎの飲食</h1>
        <div style="display:flex;align-items:center;gap:8px;">
          <div class="small-info">時刻: <span id="nowtime">--:--:--</span></div>
          <button id="bgmBtn" class="bgm-btn" title="BGM">BGM</button>
        </div>
      </header>

   <div class="content">
  <div class="order-block">
    <div id="shiftShort" class="status-line">読み込み中...</div>

    <button id="orderBtn" class="order-btn disabled">注文</button>

 <div style="  position:absolute; left:50%; bottom:23px; transform:translateX(-50%);
    width:100%;  max-width:360px;  display:flex; flex-direction:column; align-items:center; gap:12px; text-align:center; ">
    <div id="helperSmall" class="small-info">
    実際の支払いはありません。のんびり雰囲気を楽しんでね
  </div>
  <div id="jukeboxArea"style="display:flex;gap:8px;justify-content:center;" ></div>

</div>


 </div> <!-- ← order-block -->
</div>   <!-- ← content -->

</div> <!-- ← ★ page inner を閉じる -->
</div> <!-- ← ★ book を閉じる -->


</div>
  <div class="guest-mini" id="guestMini">
    <div id="guestRole"><strong>あなた：客</strong></div>
    <div class="small-info" style="margin-top:6px">目的：注文する</div>
  </div>
  <!-- J/E/C/K ボタン -->
   





  
  <div class="small-pass">
    <label style="font-size:12px;margin:0">店員用</label>
    <input id="staffPass" placeholder="　" />
    <button id="passOk" class="small">OK</button>
  </div>
<!-- Staff full -->
<div id="staffFull" class="staff-full" aria-hidden="true">
  <div class="staff-top">
    <div>
      <strong id="staffBadge">店員</strong>
      <div class="small-info">店員控室</div>
    </div>
    <div>
      <button id="logoutStaff" class="small">退室</button>
    </div>
  </div>

  <div style="margin-top:8px;">
    <div style="display:flex;gap:8px;align-items:center;">
      <label>シフト開始時間</label><input id="shiftStart" type="time" />
      <label>終了時間</label><input id="shiftEnd" type="time" />
      <button id="saveShift" class="small">保存</button>
    </div>

    <div class="big-toggle" style="margin-top:8px;">
      <button id="shiftBtn" class="off">シフト中</button>
      <button id="breakBtn" class="off">休憩中</button>
    </div>
  </div>

  <div class="staff-body">
    <div class="staff-panel">
      <strong>全員のシフト一覧</strong>
      <div id="shiftList" class="shift-list small-info" style="margin-top:8px">読み込み中…</div>
    </div>

    <div class="staff-panel">
      <strong> 注文一覧 <span id="pendingTasksSmall" class="small-info"></span></strong>
      <div id="staffOrderList" class="order-list" style="margin-top:8px"></div>
    </div>
  </div>
</div>

<!-- Sound enable overlay -->
<div id="soundOverlay" class="sound-overlay" style="display:none;">
  <div class="sound-panel">
    <h3>効果音など流しますか？</h3>
  <p style="font-size:12px;">
  音声、効果音が流れます
</p>

    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
      <button id="enableSoundBtn" class="btn-green">OK</button>
      <button id="disableSoundBtn" class="small">NO</button>
    </div>
  </div>
</div>

<!-- Order status overlay -->
<div id="orderStatusOverlay" class="status-overlay">
  <div class="status-card" id="orderStatusCard">
    <div id="orderStatusMain">状態</div>
    <div id="orderStatusSub" class="status-sub">対応されない場合再度注文</div>
  </div>
</div>

<!-- Modals -->
<div id="modalName" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal">
    <h3>ゲーム内の名前</h3>
 <input id="orderName" placeholder="名前を入力" style="width: 300px; height: 60px;" />
    <div style="margin-top:10px;text-align:right;">
      <button id="cancelOrderName" class="small">キャンセル</button>
      <button id="okOrderName" class="btn-red">決定</button>
    </div>
  </div>
</div>

<div id="modalMenu" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal">
    <h3>メニューを選択</h3>
    <div class="menu-grid" id="menuGrid"></div>
    <div style="margin-top:10px;text-align:right;">
      <button id="backMenu" class="small">戻る</button>
    </div>
  </div>
</div>

<div id="modalMakeLatte" class="modal-back" style="display:none;align-items:flex-start;overflow:auto;">
  <div class="modal" style="width:95%;max-width:920px;">
    <h3 id="makeTitle">カフェラテ制作（担当：<span id="makerName"></span>）</h3>
    <div style="display:flex;flex-wrap:wrap;gap:12px;">
      <div style="flex:1;min-width:280px;">
        <div style="height:220px;display:flex;align-items:center;justify-content:center;">
          <div style="width:180px;height:180px;border-radius:12px;background:#fff8f2;display:flex;align-items:center;justify-content:center;border:2px solid #d2b6ab;position:relative;">
            <div style="position:absolute;left:8px;top:8px;right:8px;bottom:8px;display:flex;align-items:center;justify-content:center;flex-direction:column;">
              <div id="espressoCup" style="width:120px;height:120px;border-radius:60px;overflow:hidden;position:relative;background:#6b3b24;">
                <canvas id="latteCanvas" width="120" height="120" style="display:block;"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="espressoLabel">エスプレッソ注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startEsp" class="small">注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="espBar" style="height:100%;width:0%;background:linear-gradient(90deg,#a7552b,#6b3);"></div>
                </div>
              </div>
              <div id="espPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label id="milkLabel">フームドミルク注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startMilk" class="small" disabled>注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="milkBar" style="height:100%;width:0%;background:linear-gradient(90deg,#fff,#eee);"></div>
                </div>
              </div>
              <div id="milkPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格ゾーン: 95%〜105%</div>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:300px;">
        <div style="background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong id="latteArtLabel">ラテアート（似顔絵など）</strong>
          <div style="margin-top:8px;">
            <div class="art-area" id="artArea">
              <canvas id="artBg" width="240" height="240"></canvas>
              <canvas id="artLayer" width="240" height="240"></canvas>
            </div>
            <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
              <label>ツール</label>
              <select id="penMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
              <label>太さ</label>
              <select id="penSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
              <button id="clearArt" class="small">クリア</button>
            </div>
            <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
              <label style="font-size:12px;">背景色</label><input id="artBgColor" type="color" value="#6b3b24"/>
              <label style="font-size:12px;">ペン色</label><input id="artPenColor" type="color" value="#ffffff"/>
            </div>
            <div style="margin-top:8px;text-align:right;">
              <button id="saveArt" class="btn-green" disabled>アート保存</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>メッセージカード（応援等々…）</strong>
          <div style="margin-top:6px;">
            <canvas id="cardCanvas" class="card-canvas" width="320" height="120"></canvas>
          </div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
            <label>ツール</label>
            <select id="cardMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="cardSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="clearCard" class="small">クリア</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
            <label style="font-size:12px;">背景色</label><input id="cardBgColor" type="color" value="#fff2e6"/>
            <label style="font-size:12px;">ペン色</label><input id="cardPenColor" type="color" value="#000000"/>
          </div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveCard" class="small" disabled>保存</button>
          </div>
        </div>

        <div style="margin-top:8px;display:flex;justify-content:flex-end;align-items:center;gap:8px;">
          <div id="taskStatusSmall" class="small-info" style="margin-right:auto"></div>
          <button id="completeMake" class="btn-red" disabled>提供する</button>
          <button id="cancelMake" class="small">中止</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Eat modal -->
<div id="modalEat" class="modal-back" style="display:none;align-items:center;justify-content:center;">
  <div class="modal" style="width:95%;max-width:960px;">
    <h3>飲食</h3>
    <div style="display:flex;gap:12px;flex-wrap:wrap;">
      <div style="flex:1;min-width:420px;">
        <div id="eatMainWrap" style="width:100%;height:520px;border:1px solid #d4c0b8;border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;position:relative;">
          <img id="servedImage" src="" alt="商品画像" style="max-width:100%;max-height:100%;border-radius:8px;" />
          <div id="serveHint" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.85);padding:8px;border-radius:8px;display:none;">長押しで音を鳴らし、離すと次へ</div>
        </div>
        <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
          <button id="eatNext" class="small" style="display:none"></button>
          <div id="eatSoundInfo" class="small-info">長押し・クリック（４クリック目：完食）</div>
          <button id="saveAllBtn" class="small" style="margin-left:auto">画像保存</button>
        </div>
      </div>

      <div style="width:320px;">
        <div style="border:1px solid #e2cfc8;padding:8px;border-radius:8px;background:#fff7f3;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong>ラテアート</strong>
            <span id="artLabelMini" style="font-size:12px;color:#777;"></span>
          </div>
          <canvas id="servedArtMini" width="220" height="220" style="border:1px solid #d4c0b8;margin-top:8px;background:#6b3b24;display:block;"></canvas>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;">
            <strong style="display:block;">メッセージカード</strong>
            <span id="cardLabelMini" style="font-size:12px;color:#777;"></span>
          </div>
          <canvas id="servedCardMini" width="260" height="120" style="border:1px solid #d4c0b8;margin-top:8px;background:var(--card-skin)"></canvas>

          <div style="margin-top:8px;text-align:right;">
            <button id="homeFromEat" class="small">ホームへ</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/*
  修正版 完全版スクリプト
  - 重要バグ修正: openMakeModal() で artStrokes/cardStrokes を「その注文専用」に初期化（深いコピーまたは空配列）。
    これにより異なる注文での描画が混在する不具合を解消。
  - 注文者(clientId) のみ自分の描画を復元して表示。
  - ホームへ戻ったらその注文の描画データは Firestore 上から消す（他に流れない）。
  - 長押しで rate.mp3 を再生 → 離すと完全に停止して次フレームへ。
  - cookbgm は飲食画面を開いた時に注文者側で停止される。
  - J/E/C/K ジュークボタン追加。
  - サウンドのアンロックオーバーレイを表示。
  - MENUS に UI ラベルを入れて制作画面の文言を変更できるように。
*/

/* Firebase (既存設定) */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
import { getFirestore, collection, doc, addDoc, updateDoc, deleteDoc, onSnapshot, query, orderBy, getDoc } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCNm1bmsVG4uZIJaL-bwbIcLCghzJ-ejvM",
  authDomain: "reiji-cafr.firebaseapp.com",
  projectId: "reiji-cafr",
  storageBucket: "reiji-cafr.firebasestorage.app",
  messagingSenderId: "18020287382",
  appId: "1:18020287382:web:1a87e6378598697ea3d3b7",
  measurementId: "G-F35S7FGW9M"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
signInAnonymously(auth).catch(e=>console.warn('anonymous sign-in failed', e));

/* DOM refs (shortened variables) */
const nowtimeEl = document.getElementById('nowtime');
const orderBtn = document.getElementById('orderBtn');
const shiftShort = document.getElementById('shiftShort');
const staffPass = document.getElementById('staffPass');
const passOk = document.getElementById('passOk');
const modalName = document.getElementById('modalName');
const orderName = document.getElementById('orderName');
const okOrderName = document.getElementById('okOrderName');
const modalMenu = document.getElementById('modalMenu');
const menuGrid = document.getElementById('menuGrid');
const backMenu = document.getElementById('backMenu');
const staffFull = document.getElementById('staffFull');
const staffBadge = document.getElementById('staffBadge');
const logoutStaff = document.getElementById('logoutStaff');
const shiftBtn = document.getElementById('shiftBtn');
const breakBtn = document.getElementById('breakBtn');
const shiftStart = document.getElementById('shiftStart');
const shiftEnd = document.getElementById('shiftEnd');
const saveShift = document.getElementById('saveShift');
const shiftList = document.getElementById('shiftList');
const staffOrderList = document.getElementById('staffOrderList');
const pendingTasksSmall = document.getElementById('pendingTasksSmall');

const modalMakeLatte = document.getElementById('modalMakeLatte');
const makerName = document.getElementById('makerName');
const startEsp = document.getElementById('startEsp');
const espBar = document.getElementById('espBar');
const espPct = document.getElementById('espPct');
const startMilk = document.getElementById('startMilk');
const milkBar = document.getElementById('milkBar');
const milkPct = document.getElementById('milkPct');

const artBg = document.getElementById('artBg');
const artLayer = document.getElementById('artLayer');
const artBgCtx = artBg.getContext('2d');
const artLayerCtx = artLayer.getContext('2d');
const penMode = document.getElementById('penMode');
const penSize = document.getElementById('penSize');
const clearArt = document.getElementById('clearArt');
const saveArt = document.getElementById('saveArt');
const artBgColor = document.getElementById('artBgColor');
const artPenColor = document.getElementById('artPenColor');

const cardCanvas = document.getElementById('cardCanvas');
const cardCtx = cardCanvas.getContext('2d');
const cardMode = document.getElementById('cardMode');
const cardSize = document.getElementById('cardSize');
const clearCard = document.getElementById('clearCard');
const saveCard = document.getElementById('saveCard');
const cardBgColor = document.getElementById('cardBgColor');
const cardPenColor = document.getElementById('cardPenColor');

const taskStatusSmall = document.getElementById('taskStatusSmall');
const completeMake = document.getElementById('completeMake');
const cancelMake = document.getElementById('cancelMake');

const modalEat = document.getElementById('modalEat');
const servedImage = document.getElementById('servedImage');
const servedArtMini = document.getElementById('servedArtMini');
const servedCardMini = document.getElementById('servedCardMini');
const eatNext = document.getElementById('eatNext');
const saveAllBtn = document.getElementById('saveAllBtn');
const homeFromEat = document.getElementById('homeFromEat');
const orderStatusOverlay = document.getElementById('orderStatusOverlay');
const orderStatusMain = document.getElementById('orderStatusMain');
const orderStatusSub = document.getElementById('orderStatusSub');
const bgmBtn = document.getElementById('bgmBtn');
const jukeboxArea = document.getElementById('jukeboxArea');

const soundOverlay = document.getElementById('soundOverlay');
const enableSoundBtn = document.getElementById('enableSoundBtn');
const disableSoundBtn = document.getElementById('disableSoundBtn');

const makeTitle = document.getElementById('makeTitle');
const espressoLabelEl = document.getElementById('espressoLabel');
const milkLabelEl = document.getElementById('milkLabel');
const latteArtLabelEl = document.getElementById('latteArtLabel');

let servedSequence = [], servedSequenceIndex = 0;

/* helper for raw GitHub -> URL */
function getAssetUrl(path){
  if (!path) return '';
  if (path.startsWith('@')) return 'https://raw.githubusercontent.com/' + path.slice(1);
  try { return new URL(path).href; } catch(e){ return path; }
}

/* audio assets (paths, adjust if actual paths differ) */
const audioTyaimu = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/tyaimu.mp3'));
const audioCookbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/cookbgm.mp3'));
const audioCookdbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/cookdbgm.mp3'));
const audioRate = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/rate.mp3'));
const audioJ = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/J.mp3'));
const audioE = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/E.mp3'));
const audioC = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/C.mp3'));
const audioK = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/main/K.mp3'));

/* firestore collections */
const staffsCol = collection(db, 'staffs');
const ordersCol = collection(db, 'orders');

/* app state */
const state = { staffs:[], orders:[], currentUser:{role:'guest', staffId:null}, currentOrderIdForClient:null, audioUnlocked:false, pendingPlayQueue:[] };

  
  // 既存の state 宣言の直後あたりに追加してください
// state が既にある場合はその直後に入れると見つけやすいです
const dismissedOrdersStored = JSON.parse(localStorage.getItem('reiji_dismissed_orders') || '[]');
const dismissedOrders = new Set(dismissedOrdersStored);



  
/* client id (local) */
let clientId = localStorage.getItem('reiji_clientId');
if (!clientId){ clientId = 'c_' + Math.random().toString(36).slice(2,9); localStorage.setItem('reiji_clientId', clientId); }

/* menu config data-driven */
const MENUS = {
  rate: {
    id: 'rate', title: 'カフェ・ラテ（150zz）', imageBase: '@zzcafe2800/reiji_cafe/main/rate', frameCount:6, lastFrameRandom:true,
    password:'', longPressSound:'@zzcafe2800/reiji_cafe/main/rate.mp3', clickSound:'@zzcafe2800/reiji_cafe/main/rate1.mp3',
    artBg:'#6b3b24', artPen:'#ffffff', cardBg:'#fff2e6', cardPen:'#000000',
    ui:{ makeTitle:'カフェラテ制作', espressoLabel:'エスプレッソ注ぎ', milkLabel:'フームドミルク注ぎ', latteArtLabel:'ラテアート' }
  },
  omu: {
    id: 'omu', title: 'オムライス（620zz）', imageBase: '@zzcafe2800/reiji_cafe/main/omu', frameCount:6, lastFrameRandom:true,
    password:'', longPressSound:'@zzcafe2800/reiji_cafe/main/omu.mp3', clickSound:'@zzcafe2800/reiji_cafe/main/omu1.mp3',
    artBg:'#ffd66b', artPen:'#ff0000', cardBg:'#fff2e6', cardPen:'#000000',
    ui:{ makeTitle:'オムライス制作', espressoLabel:'ケチャップライス', milkLabel:'卵で包む', latteArtLabel:'ケチャップアート' }
  }
};

  
  
  // --- 追加: ランダム商品定義（MENUS の中に入れても良いし、ここで separate にしてもOK） ---
// 既に MENUS があるので、その中に 'random' を追加する場合は MENUS['random']=... としてください。
// 例: MENUS 定義直後に追加する場合:
MENUS.random = {
  id: 'random',
  title: 'ランダム',
  // random.png をリポジトリに配置してください（例: files/random.png）
  imageBase: '@zzcafe2800/reiji_cafe/main/random', // ← getAssetUrl(imageBase + '.png') で参照します
  frameCount: 1,
  lastFrameRandom: false,
  password: '',
  longPressSound: '', clickSound: '',
  artBg: '#cccccc', artPen: '#000000', cardBg: '#fff2e6', cardPen: '#000000',
  ui: { makeTitle:'ランダム', espressoLabel:'', milkLabel:'', latteArtLabel:'' }
};



  
/* --- helper functions --- */
function uid(p='id'){ return p + Math.random().toString(36).slice(2,9); }
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function showModal(el){ el.style.display = 'flex'; }
function hideModal(el){ el.style.display = 'none'; }
function playTone(freq=440,dur=0.12){ try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination); g.gain.value=0.12; o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, dur*1000); } catch(e){} }

/* realtime listeners */
function startRealtime(){
  try {
    const q = query(staffsCol, orderBy('createdAt','asc'));
    onSnapshot(q, snap=>{
      state.staffs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
      renderShiftShort();
      renderShiftList();
      updateOrderButtonState();
      updateStaffToggleUI();
    }, e=>console.warn(e));
  } catch(e){ console.warn(e); }
  try {
    const q2 = query(ordersCol, orderBy('createdAt','asc'));
    onSnapshot(q2, snap=>{
      const prev = state.orders.slice();
      state.orders = snap.docs.map(d=>({ id:d.id, ...d.data() }));
      renderOrderLists();
      handleOrderNotifications(prev, state.orders);
      updateClientOverlay();
    }, e=>console.warn(e));
  } catch(e){ console.warn(e); }
}

/* notification handling (tyaimu / cook / delivered) */
function handleOrderNotifications(prevOrders, currOrders){
  const prevMap = new Map(prevOrders.map(o=>[o.id,o]));
  for (const o of currOrders){
    if (o.state === 'waiting' && !prevMap.has(o.id)){
      if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'tyaimu' });
      else { try{ audioTyaimu.currentTime = 0; audioTyaimu.play().catch(()=>{}); } catch(e){} }
    }
    if (o.state === 'inprogress' && state.currentOrderIdForClient === o.id){
      if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'cook' });
      else { try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} }
    }
    if (o.state === 'delivered' && state.currentOrderIdForClient === o.id){
      if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'delivered' });
      else { try{ audioCookdbgm.currentTime=0; audioCookdbgm.play().catch(()=>{}); } catch(e){} }
    }
  }
}
function flushPendingPlays(){
  while(state.pendingPlayQueue.length){
    const req = state.pendingPlayQueue.shift();
    if (req.type === 'tyaimu'){ try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{}); } catch(e){} }
    if (req.type === 'cook'){ try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} }
    if (req.type === 'delivered'){ try{ audioCookdbgm.currentTime=0; audioCookdbgm.play().catch(()=>{}); } catch(e){} }
  }
}

/* --- UI helpers --- */
setInterval(()=> nowtimeEl.textContent = new Date().toLocaleTimeString(), 1000);

function renderShiftShort(){
  const now = new Date();
  const active = state.staffs.filter(s => s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if (!active.length) shiftShort.textContent = '注文”できない”　：　現在対応できる店員がおりません　';
  else shiftShort.textContent = '注文”できる”：' + active.map(s=>`${s.name} (${s.shiftStart}〜${s.shiftEnd})`).join(' / ');
}
function renderShiftList(){
  shiftList.innerHTML = '';
  const now = new Date();
  state.staffs.forEach(s => {
    const div = document.createElement('div');
    const onNow = isNowWithinShift(s.shiftStart,s.shiftEnd,now);
    div.innerHTML = `<strong>${escapeHtml(s.name)}</strong> ${s.shiftStart||''}〜${s.shiftEnd||''} ${s.onShift?'<span style="color:green">シフト中</span>':'<span style="color:gray">-</span>'} ${s.breaking?'<span style="color:orange">休憩中</span>':''} ${onNow?'<span class="small-info">（現在この時間）</span>':''}`;
    shiftList.appendChild(div);
  });
}
function isNowWithinShift(start,end,dateObj){
  if (!start || !end) return false;
  const [sh,sm] = start.split(':').map(Number); const [eh,em] = end.split(':').map(Number);
  const sDate = new Date(dateObj); sDate.setHours(sh,sm,0,0);
  const eDate = new Date(dateObj); eDate.setHours(eh,em,0,0);
  if (eDate <= sDate) eDate.setDate(eDate.getDate()+1);
  return dateObj >= sDate && dateObj <= eDate;
}

/* staff toggle UI per current user */
function updateStaffToggleUI(){
  if (state.currentUser && state.currentUser.role === 'staff' && state.currentUser.staffId){
    const my = state.staffs.find(s=>s.id === state.currentUser.staffId);
    if (my){
      if (my.onShift && !my.breaking){ shiftBtn.classList.add('on'); shiftBtn.classList.remove('off'); breakBtn.classList.remove('on'); breakBtn.classList.add('off'); }
      else if (my.breaking){ breakBtn.classList.add('on'); breakBtn.classList.remove('off'); shiftBtn.classList.remove('on'); shiftBtn.classList.add('off'); }
      else { shiftBtn.classList.remove('on'); shiftBtn.classList.add('off'); breakBtn.classList.remove('on'); breakBtn.classList.add('off'); }
    }
  } else {
    shiftBtn.classList.remove('on'); shiftBtn.classList.add('off'); breakBtn.classList.remove('on'); breakBtn.classList.add('off');
  }
}

/* orders rendering for staff */
function renderOrderLists(){
  staffOrderList.innerHTML = '';
  state.orders.forEach(o=>{
    if (!o) return;
    if (o.state === 'cancelled' || o.state === 'delivered' || o.state === 'served') return;
    const div = document.createElement('div'); div.className = 'order-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${escapeHtml(o.name)}</strong><div class="small-info">${escapeHtml(o.item)} - 状態:${escapeHtml(o.state)} - 作成:${new Date(o.createdAt||0).toLocaleTimeString()}</div>`;
    const right = document.createElement('div');
    const tasks = computeOrderTasks(o);
    if (tasks.length) { const span = document.createElement('span'); span.className='small-info'; span.textContent = '未: ' + tasks.join(', '); right.appendChild(span); }
    if (o.state === 'waiting'){
      const btn = document.createElement('button'); btn.textContent='対応'; btn.className='small btn-green';
      btn.onclick = ()=> assignOrderToCurrentStaff(o.id);
      right.appendChild(btn);
    } else if (o.state === 'inprogress'){
      const info = document.createElement('div'); info.className='small-info'; info.textContent = `担当:${escapeHtml(o.assignedToName||o.assignedTo||'')}`;
      right.appendChild(info);
      const makeBtn = document.createElement('button'); makeBtn.textContent='制作開始'; makeBtn.className='small';
      makeBtn.onclick = ()=> openMakeModal(o);
      right.appendChild(makeBtn);
    } else if (o.state === 'done'){
      const provideBtn = document.createElement('button'); provideBtn.textContent='提供'; provideBtn.className='small btn-green';
      provideBtn.onclick = ()=> openMakeModal(o);
      right.appendChild(provideBtn);
    }
    div.appendChild(left); div.appendChild(right);
    staffOrderList.appendChild(div);
  });
  pendingTasksSmall.textContent = (state.orders||[]).filter(o=>o.state==='waiting' || o.state==='inprogress').length ? ` 未処理:${(state.orders||[]).filter(o=>o.state==='waiting' || o.state==='inprogress').length}` : '';
}
function computeOrderTasks(order){
  const pending = [];
  if (!order) return pending;
  if (order.state === 'waiting') pending.push('対応待ち');
  if (order.state === 'inprogress' || order.state === 'done'){
    if (!order.artStrokes && !order.artDataUrl) pending.push('アート');
    if (!order.cardStrokes && !order.cardDataUrl) pending.push('カード');
  }
  return pending;
}

/* staff login */
passOk.addEventListener('click', ()=> {
  if (staffPass.value === '1232'){ showStaffNameModal(); } else alert('パスワードが違います');
});
function showStaffNameModal(){
  showModal(modalName);
  okOrderName.onclick = async ()=>{
    const name = orderName.value.trim(); if (!name) { alert('名前'); return; }
    hideModal(modalName);
    try {
      const ref = await addDoc(staffsCol, { name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() });
      enterStaffFull(name, ref.id);
    } catch(e){
      console.warn(e);
      const s = { id: uid('s'), name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() };
      state.staffs.push(s);
      enterStaffFull(name, s.id);
    }
  };
}
function enterStaffFull(name, staffId){ state.currentUser = { role:'staff', staffId }; staffBadge.textContent = name; staffFull.classList.add('show'); renderShiftList(); renderOrderLists(); updateStaffToggleUI(); }
logoutStaff.addEventListener('click', async ()=> {
  const id = state.currentUser.staffId;
  if (id){
    try { await deleteDoc(doc(db,'staffs',id)); } catch(e){}
  }
  state.currentUser = { role:'guest', staffId:null }; staffFull.classList.remove('show');
});

/* shift toggle */
shiftBtn.addEventListener('click', async ()=> {
  const id = state.currentUser.staffId; if (!id) return;
  try { await updateDoc(doc(db,'staffs',id), { onShift:true, breaking:false }); } catch(e){}
  updateStaffToggleUI();
});
breakBtn.addEventListener('click', async ()=> {
  const id = state.currentUser.staffId; if (!id) return;
  try { await updateDoc(doc(db,'staffs',id), { onShift:false, breaking:true }); } catch(e){}
  updateStaffToggleUI();
});
saveShift.addEventListener('click', async ()=> {
  const id = state.currentUser.staffId; if (!id) return;
  try { await updateDoc(doc(db,'staffs',id), { shiftStart:shiftStart.value || '09:00', shiftEnd:shiftEnd.value || '17:00' }); } catch(e){ console.warn(e); }
});

/* menu & ordering */
//async function buildMenu(){
 // menuGrid.innerHTML = '';
  //for(const id in MENUS){
    //const it = MENUS[id];
    //const div = document.createElement('div'); div.className='menu-item';
    //const img = document.createElement('img'); img.className='menu-thumb';
    //const url = getAssetUrl(it.imageBase + '1.png');
    //try { const res = await fetch(url); if (res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = makePlaceholder(it.title); } catch(e){ img.src = makePlaceholder(it.title); }
//div.appendChild(img); div.appendChild(document.createElement('div')).textContent = it.title;
//div.addEventListener('click', ()=> onMenuSelect(it));
//menuGrid.appendChild(div);
 // }
//}

async function buildMenu(){
  menuGrid.innerHTML = '';

  // If 'random' exists in MENUS, render it first as the left-most item
  if (MENUS.random){
    const it = MENUS.random;
    const div = document.createElement('div'); div.className='menu-item';
    const img = document.createElement('img'); img.className='menu-thumb';
    // random uses single png: imageBase + '.png'
    const url = getAssetUrl(it.imageBase + '.png');
    try { const res = await fetch(url); if (res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = makePlaceholder(it.title); } catch(e){ img.src = makePlaceholder(it.title); }
    div.appendChild(img);
    div.appendChild(document.createElement('div')).textContent = it.title;
    // override click: call chooseRandomAndOrder() instead of onMenuSelect
    div.addEventListener('click', ()=> chooseRandomAndOrder());
    menuGrid.appendChild(div);
  }

  // render the rest of MENUS (skip 'random' if present)
  for(const id in MENUS){
    if (id === 'random') continue;
    const it = MENUS[id];
    const div = document.createElement('div'); div.className='menu-item';
    const img = document.createElement('img'); img.className='menu-thumb';
    // use first frame image by default
    const url = getAssetUrl(it.imageBase + '1.png');
    try { const res = await fetch(url); if (res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = makePlaceholder(it.title); } catch(e){ img.src = makePlaceholder(it.title); }
    div.appendChild(img); div.appendChild(document.createElement('div')).textContent = it.title;
    div.addEventListener('click', ()=> onMenuSelect(it));
    menuGrid.appendChild(div);
  }
}





  
  
function makePlaceholder(title){ const c=document.createElement('canvas');c.width=320;c.height=240;const ctx=c.getContext('2d');ctx.fillStyle='#fff8ef';ctx.fillRect(0,0,c.width,c.height);ctx.fillStyle='#6b3b24';ctx.beginPath();ctx.arc(160,110,60,0,Math.PI*2);ctx.fill();ctx.fillStyle='#fff';ctx.font='20px sans-serif';ctx.fillText(title,100,200);return c.toDataURL(); }

orderBtn.addEventListener('click', ()=> {
  if (orderBtn.classList.contains('disabled')) return;
  if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'tyaimu' });
  else { try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{}); } catch(e){} }
  showModal(modalName);
  okOrderName.onclick = () => {
    const name = orderName.value.trim();
    if (!name) { alert('名前を入力してください'); return; }
    hideModal(modalName);
    buildMenu(); showModal(modalMenu);
  };
});
backMenu.addEventListener('click', ()=> hideModal(modalMenu));

async function onMenuSelect(item){
  hideModal(modalMenu);
  const name = orderName.value.trim() || '名無し';
  if (item.password && item.password.length){
    const entered = prompt('パスワードを入力してください');
    if (entered === null) return;
    if (entered !== item.password){ alert('パスワードが違います'); return; }
    if (state.audioUnlocked){ try{ audioTyaimu.currentTime=0; audioTyaimu.play().catch(()=>{});}catch(e){} }
  }
  const createdAt = Date.now(); const expiresAt = createdAt + 5*60*1000;
  const orderObj = { name, item:item.id, itemImageBase: item.imageBase, state:'waiting', createdAt, expiresAt, assignedTo:null, assignedToName:null, artStrokes:null, cardStrokes:null, artMeta:null, cardMeta:null, artDataUrl:null, cardDataUrl:null, servedImageData:null, clientId };
  try {
    const ref = await addDoc(ordersCol, orderObj);
    state.currentOrderIdForClient = ref.id;
    showClientStatus('現在対応待ち中');
    scheduleOrderTimeout(ref.id, expiresAt);
  } catch(e){
    console.warn('add order failed', e);
    orderObj.id = uid('o'); state.orders.push(orderObj);
    state.currentOrderIdForClient = orderObj.id;
    showClientStatus('現在対応待ち中');
  }
}









// ☆ランダム選択して注文する関数
function chooseRandomAndOrder(){
  // 集合から 'random' キーを除いた候補リストを作る
  const keys = Object.keys(MENUS).filter(k => k !== 'random');
  if (!keys.length){
    alert('ランダム対象のメニューがありません');
    return;
  }
  // 完全ランダムに1つ選ぶ
  const chosenKey = keys[Math.floor(Math.random() * keys.length)];
  const chosenMenu = MENUS[chosenKey];
  if (!chosenMenu){
    alert('選択に失敗しました');
    return;
  }
  // メニューを選択した時と同じフローを呼ぶ（既存 onMenuSelect を流用）
  onMenuSelect(chosenMenu);
}

















  
async function scheduleOrderTimeout(orderId, expiresAt){
  const remaining = (expiresAt || 0) - Date.now();
  if (remaining <= 0) return;
  setTimeout(async ()=>{
    try {
      const snap = await getDoc(doc(db,'orders',orderId));
      if (snap.exists()){
        const o = snap.data();
        if (o.state === 'waiting'){
          await updateDoc(doc(db,'orders',orderId), { state:'cancelled', cancelReason:'スタッフの応答がないため現在注文を取り消しになります' });
        }
      }
    } catch(e){ console.warn(e); }
  }, remaining);
}

/* assign order to staff */
async function assignOrderToCurrentStaff(orderId){
  const staffId = state.currentUser.staffId; if (!staffId) { alert('スタッフとしてログインしてください'); return; }
  const s = state.staffs.find(x=>x.id===staffId);
  try {
    await updateDoc(doc(db,'orders',orderId), { state:'inprogress', assignedTo: staffId, assignedToName: s.name });
    if (!state.audioUnlocked) state.pendingPlayQueue.push({ type:'cook' });
    else { try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} }
  } catch(e){ console.warn(e); }
}

/* --- STROKES handling with per-order isolation --- */

/*
  KEY FIX:
  - artStrokes and cardStrokes are treated as the current-edit arrays for the order opened by openMakeModal.
  - When openMakeModal(order) is called:
      * artStrokes/cardStrokes are replaced by deep copy of order.artStrokes/order.cardStrokes if present,
        OR set to [] if no existing strokes.
      * savedArt... variables are set accordingly.
    This guarantees that previous order's strokes are never left in the arrays.
  - After completeMake or closing the modal, these arrays are cleared.
*/

/* normalized helpers */
function normPointInCanvas(pt, canvas){ return { x: pt.x / canvas.width, y: pt.y / canvas.height }; }
function denormPoint(p, canvas){ return { x: (p.x || 0) * canvas.width, y: (p.y || 0) * canvas.height }; }

/* initialize canvases */
function initArtCanvas(bgColor){
  artBgCtx.clearRect(0,0,artBg.width,artBg.height);
  artBgCtx.fillStyle = bgColor || artBgColor.value || '#6b3b24';
  artBgCtx.beginPath(); artBgCtx.arc(120,120,100,0,Math.PI*2); artBgCtx.fill();
  artLayerCtx.clearRect(0,0,artLayer.width,artLayer.height); artLayerCtx.lineCap='round'; artLayerCtx.lineJoin='round';
}
function initCardCanvas(bgColor){
  cardCtx.clearRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.fillStyle = bgColor || cardBgColor.value || getComputedStyle(document.documentElement).getPropertyValue('--card-skin')||'#fff2e6';
  cardCtx.fillRect(0,0,cardCanvas.width,cardCanvas.height);
  cardCtx.lineCap='round'; cardCtx.lineJoin='round';
}

/* current editing arrays (per opened order) */
let artStrokes = []; let currentArtStroke = null; let artDrawing = false;
let cardStrokes = []; let currentCardStroke = null; let cardDrawing = false;

/* saved local copies that are written to Firestore on completeMake */
let savedArtDataUrlLocal = null, savedCardDataUrlLocal = null;
let savedArtMeta = null, savedCardMeta = null;
let savedArtStrokesLocal = null;
let savedCardStrokesLocal = null;
/* event position */
function getEventPos(e, canvas){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : null;
  const cx = t ? t.clientX : e.clientX;
  const cy = t ? t.clientY : e.clientY;
  return { x: (cx - r.left) * (canvas.width / r.width), y: (cy - r.top) * (canvas.height / r.height) };
}

/* art handlers (write into artStrokes — which is per-order) */
artLayer.addEventListener('mousedown', (e)=>{
  artDrawing = true;
  const p = getEventPos(e, artLayer);
  const tool = penMode.value;
  const w = parseInt(penSize.value, 10);
  currentArtStroke = { tool, width: w, points: [ normPointInCanvas(p, artLayer) ] , pen: artPenColor.value || '#ffffff' };
});
artLayer.addEventListener('mousemove', (e)=>{
  if (!artDrawing || !currentArtStroke) return;
  const p = getEventPos(e, artLayer);
  currentArtStroke.points.push(normPointInCanvas(p, artLayer));
  renderLatestArtStrokeSegment(currentArtStroke);
});
artLayer.addEventListener('mouseup', ()=>{
  if (!artDrawing) return;
  artDrawing = false;
  if (currentArtStroke){ artStrokes.push(currentArtStroke); currentArtStroke = null; saveArt.disabled = false; updateTaskStatus(); }
});
artLayer.addEventListener('mouseleave', ()=>{ if (artDrawing){ artDrawing=false; if (currentArtStroke){ artStrokes.push(currentArtStroke); currentArtStroke=null; saveArt.disabled=false; updateTaskStatus(); } } });
artLayer.addEventListener('touchstart',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousedown', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
artLayer.addEventListener('touchmove',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousemove', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
artLayer.addEventListener('touchend',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mouseup')); });

function renderLatestArtStrokeSegment(stroke){
  if (!stroke || stroke.points.length < 2) return;
  const p1 = denormPoint(stroke.points[stroke.points.length-2], artLayer);
  const p2 = denormPoint(stroke.points[stroke.points.length-1], artLayer);
  if (stroke.tool === 'draw'){ artLayerCtx.globalCompositeOperation='source-over'; artLayerCtx.strokeStyle=stroke.pen || artPenColor.value || '#ffffff'; artLayerCtx.lineWidth=stroke.width; }
  else { artLayerCtx.globalCompositeOperation='destination-out'; artLayerCtx.lineWidth=stroke.width; }
  artLayerCtx.beginPath(); artLayerCtx.moveTo(p1.x,p1.y); artLayerCtx.lineTo(p2.x,p2.y); artLayerCtx.stroke();
}

/* card handlers (per-order cardStrokes) */
cardCanvas.addEventListener('mousedown', (e)=>{
  cardDrawing = true;
  const p = getEventPos(e, cardCanvas);
  const tool = cardMode.value; const w = parseInt(cardSize.value,10);
  currentCardStroke = { tool, width: w, points: [ normPointInCanvas(p, cardCanvas) ], pen: cardPenColor.value || '#000000' };
});
cardCanvas.addEventListener('mousemove', (e)=>{
  if (!cardDrawing || !currentCardStroke) return;
  const p = getEventPos(e, cardCanvas);
  currentCardStroke.points.push(normPointInCanvas(p, cardCanvas));
  renderLatestCardStrokeSegment(currentCardStroke);
});
cardCanvas.addEventListener('mouseup', ()=>{
  if (!cardDrawing) return;
  cardDrawing = false;
  if (currentCardStroke){ cardStrokes.push(currentCardStroke); currentCardStroke = null; saveCard.disabled = false; updateTaskStatus(); }
});
cardCanvas.addEventListener('mouseleave', ()=>{ if (cardDrawing){ cardDrawing=false; if (currentCardStroke){ cardStrokes.push(currentCardStroke); currentCardStroke=null; saveCard.disabled=true; updateTaskStatus(); } } });
cardCanvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousedown', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
cardCanvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousemove', {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
cardCanvas.addEventListener('touchend',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mouseup')); });

function renderLatestCardStrokeSegment(stroke){
  if (!stroke || stroke.points.length < 2) return;
  const p1 = denormPoint(stroke.points[stroke.points.length-2], cardCanvas);
  const p2 = denormPoint(stroke.points[stroke.points.length-1], cardCanvas);
  if (stroke.tool === 'draw'){ cardCtx.globalCompositeOperation='source-over'; cardCtx.strokeStyle=stroke.pen || cardPenColor.value || '#000'; cardCtx.lineWidth=stroke.width; }
  else { cardCtx.globalCompositeOperation='destination-out'; cardCtx.lineWidth=stroke.width; }
  cardCtx.beginPath(); cardCtx.moveTo(p1.x,p1.y); cardCtx.lineTo(p2.x,p2.y); cardCtx.stroke();
}

/* clear handlers */
clearArt.addEventListener('click', ()=>{ initArtCanvas(); artStrokes=[]; currentArtStroke=null; saveArt.disabled=true; updateTaskStatus(); });
clearCard.addEventListener('click', ()=>{ initCardCanvas(); cardStrokes=[]; currentCardStroke=null; saveCard.disabled=true; updateTaskStatus(); });

/* saveArt / saveCard: create high-res PNG + meta for this order's current art/card */
saveArt.addEventListener('click', ()=>{
  // create high-res canvas for fidelity
  const scale = 2;
  const tmp = document.createElement('canvas'); tmp.width = artLayer.width * scale; tmp.height = artLayer.height * scale;
  const t = tmp.getContext('2d');
  t.fillStyle = artBgColor.value || '#6b3b24'; t.fillRect(0,0,tmp.width,tmp.height);
  t.lineCap = 'round'; t.lineJoin = 'round';
  const strokes = JSON.parse(JSON.stringify(artStrokes || []));
  for (const s of strokes){
    t.beginPath(); t.globalCompositeOperation = s.tool === 'draw' ? 'source-over' : 'destination-out';
    t.strokeStyle = s.pen || artPenColor.value || '#fff'; t.lineWidth = (s.width || 6) * scale;
    const pts = s.points || [];
    for (let i=0;i<pts.length;i++){ const p = pts[i]; const x = p.x * tmp.width; const y = p.y * tmp.height; if (i===0) t.moveTo(x,y); else t.lineTo(x,y); }
    t.stroke(); t.closePath(); t.globalCompositeOperation='source-over';
  }
  savedArtDataUrlLocal = tmp.toDataURL('image/png');
  savedArtMeta = { origWidth: artLayer.width, origHeight: artLayer.height, savedWidth: tmp.width, savedHeight: tmp.height, bg: artBgColor.value || '#6b3b24', penDefault: artPenColor.value || '#ffffff', scale };
  // store strokes as deep copy for writing later
  savedArtStrokesLocal = JSON.parse(JSON.stringify(artStrokes || []));
  saveArt.disabled = true;
  updateTaskStatus();
  alert('アートを保存しました。');
});

saveCard.addEventListener('click', ()=>{
  const scale = 2;
  const tmp = document.createElement('canvas'); tmp.width = cardCanvas.width * scale; tmp.height = cardCanvas.height * scale;
  const t = tmp.getContext('2d');
  t.fillStyle = cardBgColor.value || '#fff2e6'; t.fillRect(0,0,tmp.width,tmp.height);
  t.lineCap = 'round'; t.lineJoin = 'round';
  const strokes = JSON.parse(JSON.stringify(cardStrokes || []));
  for (const s of strokes){
    t.beginPath(); t.globalCompositeOperation = s.tool === 'draw' ? 'source-over' : 'destination-out';
    t.strokeStyle = s.pen || cardPenColor.value || '#000'; t.lineWidth = (s.width || 4) * scale;
    const pts = s.points || [];
    for (let i=0;i<pts.length;i++){ const p = pts[i]; const x = p.x * tmp.width; const y = p.y * tmp.height; if (i===0) t.moveTo(x,y); else t.lineTo(x,y); }
    t.stroke(); t.closePath(); t.globalCompositeOperation='source-over';
  }
  savedCardDataUrlLocal = tmp.toDataURL('image/png');
  savedCardMeta = { origWidth: cardCanvas.width, origHeight: cardCanvas.height, savedWidth: tmp.width, savedHeight: tmp.height, bg: cardBgColor.value || '#fff2e6', penDefault: cardPenColor.value || '#000000', scale };
  savedCardStrokesLocal = JSON.parse(JSON.stringify(cardStrokes || []));
  saveCard.disabled = true;
  updateTaskStatus();
  alert('カードを保存しました。。');
});

/* pouring logic (unchanged) */
let espInterval=null, milkInterval=null, espDone=false, milkDone=false;
function resetPouring(){ if (espInterval){ clearInterval(espInterval); espInterval=null; } if (milkInterval){ clearInterval(milkInterval); milkInterval=null; } espBar.style.width='0%'; espPct.textContent='0%'; milkBar.style.width='0%'; milkPct.textContent='0%'; espDone=false; milkDone=false; startEsp.disabled=false; startMilk.disabled=true; taskStatusSmall.textContent='未完了: 注ぎ'; }
resetPouring();
function startAutoPour(barEl, pctEl, onOverflow){ let pct=0; const it=setInterval(()=>{ pct = Math.min(130,pct + Math.random()*4 + 1); barEl.style.width = pct + '%'; pctEl.textContent = Math.round(pct) + '%'; if (pct >= 120){ clearInterval(it); onOverflow(); } }, 100); return { it, getPct: ()=> pct }; }

startEsp.addEventListener('mousedown', ()=>{ if (espInterval) return; startEsp.textContent='注ぎ中...'; const res = startAutoPour(espBar, espPct, ()=>{ alert('注ぎ過ぎ（120%）最初からやり直しになります'); resetPouring(); }); espInterval = res.it; });
startEsp.addEventListener('mouseup', ()=>{ if (espInterval){ clearInterval(espInterval); espInterval=null; } startEsp.textContent='注ぐ（押し続け）'; const pct = parseFloat(espBar.style.width)||0; if (pct>=95 && pct<=105){ espDone=true; playTone(523,0.12); latteFillEsp(); startMilk.disabled=false; updateTaskStatus(); } else { alert('合格ラインを外しました。最初からやり直しになります'); resetPouring(); } });
startMilk.addEventListener('mousedown', ()=>{ if (milkInterval) return; startMilk.textContent='注ぎ中...'; const res = startAutoPour(milkBar, milkPct, ()=>{ alert('注ぎ過ぎ（120%）最初からやり直しになります'); resetPouring(); }); milkInterval = res.it; });
startMilk.addEventListener('mouseup', ()=>{ if (milkInterval){ clearInterval(milkInterval); milkInterval=null; } startMilk.textContent='注ぐ（押し続け）'; const pct = parseFloat(milkBar.style.width)||0; if (pct>=95 && pct<=105){ milkDone=true; playTone(660,0.12); latteFillMilk(); updateTaskStatus(); } else { alert('合格ラインを外しました。最初からやり直しになります'); resetPouring(); } });
startEsp.addEventListener('touchstart',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mousedown')); });
startEsp.addEventListener('touchend',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mouseup')); });
startMilk.addEventListener('touchstart',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mousedown')); });
startMilk.addEventListener('touchend',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mouseup')); });

/* latte visuals */
const latteCanvas = document.getElementById('latteCanvas'); const latteCtx = latteCanvas.getContext('2d');
function latteClear(){ latteCtx.clearRect(0,0,latteCanvas.width,latteCanvas.height); latteCtx.fillStyle='#6b3b24'; latteCtx.beginPath(); latteCtx.arc(60,60,58,0,Math.PI*2); latteCtx.fill(); }
function latteFillEsp(){ latteCtx.fillStyle='#5a2f1a'; latteCtx.fillRect(0,60,latteCanvas.width,60); }
function latteFillMilk(){ latteCtx.fillStyle='#f6efe6'; latteCtx.beginPath(); latteCtx.arc(60,60,48,0,Math.PI*2); latteCtx.fill(); }
latteClear();

/* updateTaskStatus */
function updateTaskStatus(){ const parts=[]; if (!espDone || !milkDone) parts.push('注ぎ'); if (!savedArtStrokesLocal && (!artStrokes || !artStrokes.length)) parts.push('アート'); if (!savedCardStrokesLocal && (!cardStrokes || !cardStrokes.length)) parts.push('カード'); taskStatusSmall.textContent = parts.length ? '未完了: ' + parts.join(', ') : 'すべて完了'; completeMake.disabled = parts.length !== 0; }

/* openMakeModal(order) — CRITICAL: ensure per-order isolation */
let currentMakingOrderId = null;
let currentOrderObj = null;
async function openMakeModal(order){
  // ensure order object with id available
  currentMakingOrderId = order.id;
  currentOrderObj = order;
  makerName.textContent = order.assignedToName || order.assignedTo || '';
  // apply menu-specific UI labels
  const cfg = MENUS[order.item] || MENUS['rate'];
  makeTitle.textContent = (cfg.ui && cfg.ui.makeTitle) ? cfg.ui.makeTitle + '（担当：' + (order.assignedToName || order.assignedTo || '') + '）' : '制作（担当）';
  espressoLabelEl.textContent = (cfg.ui && cfg.ui.espressoLabel) || 'エスプレッソ注ぎ';
  milkLabelEl.textContent = (cfg.ui && cfg.ui.milkLabel) || 'フームドミルク注ぎ';
  latteArtLabelEl.textContent = (cfg.ui && cfg.ui.latteArtLabel) || 'ラテアート';

  // IMPORTANT: reset current editing arrays to this order's strokes (deep copy) OR empty if none.
  artStrokes = (order.artStrokes && Array.isArray(order.artStrokes)) ? JSON.parse(JSON.stringify(order.artStrokes)) : [];
  cardStrokes = (order.cardStrokes && Array.isArray(order.cardStrokes)) ? JSON.parse(JSON.stringify(order.cardStrokes)) : [];

  // reset temporary saved data (they belong to this editing session)
  savedArtDataUrlLocal = order.artDataUrl || null;
  savedCardDataUrlLocal = order.cardDataUrl || null;
  savedArtMeta = order.artMeta || null;
  savedCardMeta = order.cardMeta || null;

  // initialize canvases according to menu or saved meta
  const artBgColorToUse = (savedArtMeta && savedArtMeta.bg) || cfg.artBg || artBgColor.value;
  const cardBgColorToUse = (savedCardMeta && savedCardMeta.bg) || cfg.cardBg || cardBgColor.value;
  initArtCanvas(artBgColorToUse);
  initCardCanvas(cardBgColorToUse);

  // replay existing strokes for this order onto canvases (these strokes are now the editing arrays)
  if (artStrokes && artStrokes.length) replayStrokesOnCanvasImmediate(artStrokes, artLayer, artLayerCtx, savedArtMeta);
  if (cardStrokes && cardStrokes.length) replayStrokesOnCanvasImmediate(cardStrokes, cardCanvas, cardCtx, savedCardMeta);

  // reset drawing state
  currentArtStroke = null; currentCardStroke = null; artDrawing=false; cardDrawing=false;

  // update UI controls
  saveArt.disabled = !(artStrokes && artStrokes.length); saveCard.disabled = !(cardStrokes && cardStrokes.length);
  updateTaskStatus();

  // show modal
  modalMakeLatte.style.display = 'flex';
}

/* replay helper */
function replayStrokesOnCanvasImmediate(strokes, canvasEl, ctx, meta){
  if (!strokes || !strokes.length) return;
  for (const s of strokes){
    ctx.beginPath();
    ctx.lineWidth = (s.width || 3) * ((canvasEl.width / (meta?.origWidth || canvasEl.width)));
    if (s.tool === 'draw'){ ctx.globalCompositeOperation='source-over'; ctx.strokeStyle = s.pen || (meta?.penDefault) || '#000'; } else { ctx.globalCompositeOperation='destination-out'; }
    const pts = s.points || [];
    for (let i=0;i<pts.length;i++){ const p=pts[i]; const den = denormPoint(p, canvasEl); if (i===0) ctx.moveTo(den.x, den.y); else ctx.lineTo(den.x, den.y); }
    ctx.stroke(); ctx.closePath(); ctx.globalCompositeOperation='source-over';
  }
}

/* completeMake: write the current order's art/card strokes & metas to Firestore and set state delivered */
completeMake.addEventListener('click', async ()=>{
  if (!currentMakingOrderId){ alert('対象の注文がありません'); return; }
  // use current editing arrays directly (they are per-order)
  const artStrokesToSave = artStrokes || [];
  const cardStrokesToSave = cardStrokes || [];
  // meta: if saved meta exists use it, else create from current canvases
  const artMetaToSave = savedArtMeta || (artStrokesToSave.length ? { origWidth: artLayer.width, origHeight: artLayer.height, savedWidth: artLayer.width*2, savedHeight: artLayer.height*2, bg: artBgColor.value || '#6b3b24', penDefault: artPenColor.value || '#fff', scale:2 } : null);
  const cardMetaToSave = savedCardMeta || (cardStrokesToSave.length ? { origWidth: cardCanvas.width, origHeight: cardCanvas.height, savedWidth: cardCanvas.width*2, savedHeight: cardCanvas.height*2, bg: cardBgColor.value || '#fff2e6', penDefault: cardPenColor.value || '#000', scale:2 } : null);

  // compose served image
  const tmp = document.createElement('canvas'); tmp.width=1200; tmp.height=1200; const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff8ef'; tctx.fillRect(0,0,tmp.width,tmp.height);
  tctx.drawImage(latteCanvas, 450,300,300,300);
  if (savedArtDataUrlLocal){
    const img = new Image(); img.src = savedArtDataUrlLocal; await new Promise(r=>{ img.onload=r; img.onerror=r; }); tctx.drawImage(img, 440,120,320,320);
  } else if (artStrokesToSave.length){
    const artTmp = document.createElement('canvas'); artTmp.width=600; artTmp.height=600; const actx = artTmp.getContext('2d');
    actx.fillStyle = artMetaToSave?.bg || '#6b3b24'; actx.fillRect(0,0,artTmp.width,artTmp.height);
    replayStrokesOnCanvasImmediate(artStrokesToSave, artTmp, actx, artMetaToSave);
    tctx.drawImage(artTmp, 440,120,320,320);
  }
  if (savedCardDataUrlLocal){
    const img = new Image(); img.src = savedCardDataUrlLocal; await new Promise(r=>{ img.onload=r; img.onerror=r; }); tctx.drawImage(img, 430,700,340,160);
  } else if (cardStrokesToSave.length){
    const cardTmp = document.createElement('canvas'); cardTmp.width=520; cardTmp.height=240; const cctx = cardTmp.getContext('2d');
    cctx.fillStyle = cardMetaToSave?.bg || '#fff2e6'; cctx.fillRect(0,0,cardTmp.width,cardTmp.height);
    replayStrokesOnCanvasImmediate(cardStrokesToSave, cardTmp, cctx, cardMetaToSave);
    tctx.drawImage(cardTmp, 430,700,340,160);
  }
  const servedDataUrl = tmp.toDataURL('image/png');

  try {
    await updateDoc(doc(db,'orders',currentMakingOrderId), {
      state: 'delivered',
      deliveredAt: Date.now(),
      servedImageData: servedDataUrl,
      artStrokes: artStrokesToSave,
      cardStrokes: cardStrokesToSave,
      artMeta: artMetaToSave || null,
      cardMeta: cardMetaToSave || null,
      artDataUrl: savedArtDataUrlLocal || null,
      cardDataUrl: savedCardDataUrlLocal || null
    });
    modalMakeLatte.style.display = 'none';
    try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
    // CLEAR current editing arrays to avoid carryover
    artStrokes = []; cardStrokes = []; currentArtStroke=null; currentCardStroke=null;
    savedArtDataUrlLocal = savedCardDataUrlLocal = null; savedArtMeta = savedCardMeta = null;
    currentMakingOrderId = null; currentOrderObj = null;
    alert('提供しました（Firestoreへ保存）');
  } catch(e){
    console.warn('completeMake failed', e);
    modalMakeLatte.style.display = 'none';
    try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
    currentMakingOrderId = null;
    alert('提供に失敗しました（Firestore更新エラー）');
  }
});

/* Client overlay handling and reconstructing images for only the ordering client */
function showClientStatus(text){ orderStatusMain.textContent = text; orderStatusSub.textContent = '店員が対応できない場合もございます'; orderStatusOverlay.style.display = 'flex'; }
function hideClientStatus(){ orderStatusOverlay.style.display = 'none'; }

function updateClientOverlay(){

    if (state.currentOrderIdForClient && dismissedOrders.has(state.currentOrderIdForClient)){
    // 既に閉じた注文なので、再表示しないように currentOrderIdForClient をクリアする
    state.currentOrderIdForClient = null;
    return;
  }

  if (!state.currentOrderIdForClient) return;
  const o = state.orders.find(x=>x.id===state.currentOrderIdForClient);
  if (!o) return;
// if (!state.currentOrderIdForClient) return;
 // const o = state.orders.find(x=>x.id===state.currentOrderIdForClient);
 // if (!o) return;
  if (o.state === 'waiting'){ showClientStatus('現在対応待ち中'); }
  else if (o.state === 'inprogress'){
    showClientStatus('現在調理中…');
    if (state.audioUnlocked){ try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play().catch(()=>{}); } catch(e){} }
    else state.pendingPlayQueue.push({ type:'cook' });
  }
  else if (o.state === 'delivered'){
    showClientServed(o);
    hideClientStatus();
    try{ audioCookbgm.pause(); audioCookbgm.currentTime = 0; } catch(e){}
  } else if (o.state === 'cancelled'){
    showClientStatus('スタッフの応答がないため現在注文を取り消しになります');
    setTimeout(()=>{ hideClientStatus(); state.currentOrderIdForClient = null; }, 10000);
  }
}

/* showClientServed: only render art/card if order.clientId === local clientId */
async function showClientServed(order){
  if (order.servedImageData){
    servedImage.src = order.servedImageData;
  } else {
    const baseUrl = getAssetUrl(order.itemImageBase + '1.png');
    servedImage.src = baseUrl;
  }

  const artCtx = servedArtMini.getContext('2d');
  artCtx.clearRect(0,0,servedArtMini.width,servedArtMini.height);
  artCtx.fillStyle = (order.artMeta && order.artMeta.bg) || MENUS[order.item]?.artBg || '#6b3b24';
  artCtx.fillRect(0,0,servedArtMini.width,servedArtMini.height);
  if (order.clientId === clientId){
    if (order.artStrokes && order.artStrokes.length){
      replayStrokesOnCanvasImmediate(order.artStrokes, servedArtMini, artCtx, order.artMeta);
    } else if (order.artDataUrl){
      const img = new Image(); img.src = order.artDataUrl; await new Promise(r=>{ img.onload=r; img.onerror=r; }); artCtx.drawImage(img,0,0,servedArtMini.width,servedArtMini.height);
    }
  }

  const cardCtxMini = servedCardMini.getContext('2d');
  cardCtxMini.clearRect(0,0,servedCardMini.width,servedCardMini.height);
  cardCtxMini.fillStyle = (order.cardMeta && order.cardMeta.bg) || MENUS[order.item]?.cardBg || '#fff2e6';
  cardCtxMini.fillRect(0,0,servedCardMini.width,servedCardMini.height);
  if (order.clientId === clientId){
    if (order.cardStrokes && order.cardStrokes.length){
      replayStrokesOnCanvasImmediate(order.cardStrokes, servedCardMini, cardCtxMini, order.cardMeta);
    } else if (order.cardDataUrl){
      const img = new Image(); img.src = order.cardDataUrl; await new Promise(r=>{ img.onload=r; img.onerror=r; }); cardCtxMini.drawImage(img,0,0,servedCardMini.width,servedCardMini.height);
    }
  }

  const cfg = MENUS[order.item] || MENUS['rate'];
  const frames = await preloadFrames(cfg.imageBase, cfg.frameCount || 5, cfg.lastFrameRandom);
  servedSequence = frames.slice(); servedSequenceIndex = 0;
  if (servedSequence.length) servedImage.src = servedSequence[0];

  document.getElementById('modalEat').style.display = 'flex';
}

/* preload frames */
async function preloadFrames(basePath, frameCount=5, lastRandom=false){
  const frames = [];
  for (let i=1;i<=frameCount;i++){
    let name = i;
    if (i===frameCount && lastRandom){
      if (Math.random() < 0.5) name = frameCount; else name = '0' + frameCount;
    }
    const url = getAssetUrl(basePath + name + '.png');
    try {
      const res = await fetch(url);
      if (!res.ok) continue;
      const blob = await res.blob();
      frames.push(URL.createObjectURL(blob));
    } catch(e){ continue; }
  }
  return frames;
}

/* served image long-press: loop rate.mp3 while pressing and stop on release; advance frame on release */
let servedPressing = false;
servedImage.addEventListener('mousedown', (e)=>{ startServedPress(e); });
servedImage.addEventListener('mouseup', (e)=>{ endServedPress(e); });
servedImage.addEventListener('mouseleave', (e)=>{ endServedPress(e); });
servedImage.addEventListener('touchstart', (e)=>{ e.preventDefault(); startServedPress(e); }, {passive:false});
servedImage.addEventListener('touchend', (e)=>{ e.preventDefault(); endServedPress(e); }, {passive:false});

function startServedPress(e){
  e && e.preventDefault();
  if (servedPressing) return;
  servedPressing = true;
  try{
    audioRate.loop = true;
    audioRate.currentTime = 0;
    if (state.audioUnlocked) audioRate.play().catch(()=>{});
    else state.pendingPlayQueue.push({ type:'typerate' });
  } catch(e){}
}
function endServedPress(e){
  e && e.preventDefault();
  if (!servedPressing) return;
  servedPressing = false;
  try{ audioRate.pause(); audioRate.currentTime = 0; } catch(e){}
  if (!servedSequence.length) return;
  if (servedSequenceIndex < servedSequence.length - 1){
    servedSequenceIndex++;
    servedImage.src = servedSequence[servedSequenceIndex];
  }
}

/* saveAll (client) */
saveAllBtn.addEventListener('click', ()=>{
  const tmp = document.createElement('canvas'); tmp.width = 1200; tmp.height = 1200; const t = tmp.getContext('2d');
  t.fillStyle = '#fff8ef'; t.fillRect(0,0,tmp.width,tmp.height);
  const mainImg = new Image(); mainImg.crossOrigin = 'anonymous'; mainImg.src = servedImage.src;
  mainImg.onload = ()=> {
    t.drawImage(mainImg, 150,100,900,600);
    t.drawImage(servedArtMini, 860,120,220,220);
    t.drawImage(servedCardMini, 860,360,260,120);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'served_save.png'; a.click();
  };
  mainImg.onerror = ()=> { alert('画像の読み込みに失敗しました'); };
});

/* homeFromEat: when client returns home, remove drawing data for that order from Firestore so it won't be shared further */

homeFromEat.addEventListener('click', async ()=>{
  // 現在表示中の注文 ID を取得
  const curId = state.currentOrderIdForClient;
  if (curId){
    // Firestore に保存された手書きデータを消す（注文者のものだけ）
    try {
      const o = state.orders.find(x => x.id === curId);
      if (o && o.clientId === clientId){
        await updateDoc(doc(db,'orders',curId), {
          artStrokes: null,
          cardStrokes: null,
          artDataUrl: null,
          cardDataUrl: null,
          servedImageData: null,
          artMeta: null,
          cardMeta: null
        });
      }
    } catch(e){
      console.warn('clear art data failed', e);
    }
    // この注文は「閉じた」とマークして再表示を防ぐ
    dismissedOrders.add(curId);
    try { localStorage.setItem('reiji_dismissed_orders', JSON.stringify(Array.from(dismissedOrders))); } catch(e){}
    // ローカル状態をクリア
    state.currentOrderIdForClient = null;
  }
  // モーダルを閉じる
  document.getElementById('modalEat').style.display = 'none';
});
  
//homeFromEat.addEventListener('click', async ()=>{
  ///const o = state.orders.find(x=>x.id === state.currentOrderIdForClient);
  //if (o && o.clientId === clientId){
  //  try {
   //   await updateDoc(doc(db,'orders',o.id), { artStrokes:null, cardStrokes:null, artDataUrl:null, cardDataUrl:null, servedImageData:null, artMeta:null, cardMeta:null });
//    } catch(e){ console.warn('clear art data failed', e); }
//  }
//  document.getElementById('modalEat').style.display = 'none';
//  state.currentOrderIdForClient = null;
//});

/* J/E/C/K jukebox build */
function buildJukebox(){
  const list = [
    { id:'J', img:'@zzcafe2800/reiji_cafe/main/J.png', audio: audioJ },
    { id:'E', img:'@zzcafe2800/reiji_cafe/main/E.png', audio: audioE },
    { id:'C', img:'@zzcafe2800/reiji_cafe/main/C.png', audio: audioC },
    { id:'K', img:'@zzcafe2800/reiji_cafe/main/K.png', audio: audioK },
  ];
  jukeboxArea.innerHTML = '';
  for (const it of list){
    const wrap = document.createElement('div'); wrap.className='wrapper';
    const img = document.createElement('img'); img.src = getAssetUrl(it.img); img.alt = it.id;
    img.title = it.id;
    img.style.width = '56px';
    img.addEventListener('click', ()=>{
      try { it.audio.currentTime = 0; it.audio.play().catch(()=>{}); } catch(e){}
    });
    const hint = document.createElement('div'); hint.className='hint'; hint.textContent = '';
    wrap.appendChild(img); wrap.appendChild(hint);
    jukeboxArea.appendChild(wrap);
  }
}

/* order button enable/disable logic */
function updateOrderButtonState(){
  const now = new Date();
  const anyAvailable = state.staffs.some(s => s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if (anyAvailable) orderBtn.classList.remove('disabled'); else orderBtn.classList.add('disabled');
}

/* Sound overlay handling */
function showSoundOverlay(){ soundOverlay.style.display = 'flex'; }
function hideSoundOverlay(){ soundOverlay.style.display = 'none'; }
enableSoundBtn.addEventListener('click', ()=> {
  state.audioUnlocked = true;
  try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); ctx.resume && ctx.resume(); ctx.close && ctx.close(); } catch(e){}
  hideSoundOverlay();
  flushPendingPlays();
});
disableSoundBtn.addEventListener('click', ()=> { state.audioUnlocked = false; hideSoundOverlay(); });

/* header BGM button opens URL */
bgmBtn.addEventListener('click', ()=> window.open('https://x.gd/6C0VB', '_blank'));

/* initial boot */
buildJukebox();
buildMenu().catch(()=>{});
initArtCanvas(); initCardCanvas();
startRealtime();
showSoundOverlay();

/* End of script */
</script>
  <script>
document.getElementById("enableSoundBtn")?.addEventListener("click", () => {
  const cover = document.querySelector(".cover");
  if (cover) {
    cover.classList.add("open");
  }
});
</script>
<script>
const cover = document.querySelector(".cover");

cover.addEventListener("animationend", () => {
  cover.classList.add("finished");
});
</script>

</body>
</html>
