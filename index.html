<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ゲームカフェ — 修正版（replayStrokesOnCtx 重複削除）</title>
<meta name="format-detection" content="telephone=no">
<style>
  :root{ --bg:#f7efe7; --accent:#b33; --paper:#fff8ef; --dark:#3a2b20; --muted:#8b6d5c; --card-skin:#fff2e6; }
  html,body{height:100%;margin:0;font-family: "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background:linear-gradient(180deg,#fdf2ea 0%,#f7efe7 100%);}
  .container{max-width:1000px;margin:18px auto;padding:18px;background:var(--paper);box-shadow:0 6px 20px rgba(0,0,0,0.15);border-radius:10px;border:6px solid var(--accent);position:relative;min-height:720px;display:flex;flex-direction:column;}
  header{display:flex;align-items:center;justify-content:space-between;padding:6px 12px;color:var(--dark);}
  h1{margin:0;font-size:18px;}
  .content{flex:1;display:flex;align-items:center;justify-content:center;padding:12px;}
  .order-block{width:100%;max-width:520px;display:flex;flex-direction:column;align-items:center;gap:10px;}
  .status-line{font-weight:700;background:rgba(255,255,255,0.92);padding:8px 12px;border-radius:8px;border:2px solid #f0c6c6;text-align:center;}
  .order-btn{background:linear-gradient(180deg,#ffd4c4,#ffb38a);border:4px solid var(--accent);color:var(--dark);padding:22px 36px;border-radius:12px;font-size:34px;cursor:pointer;box-shadow:0 6px 0 #913;user-select:none;width:100%;max-width:420px;}
  .order-btn.disabled{opacity:0.4;cursor:not-allowed;box-shadow:none;}
  .small-pass{position:fixed;left:12px;bottom:12px;background:rgba(255,255,255,0.95);padding:6px;border-radius:6px;border:1px dashed #c66;display:flex;align-items:center;gap:6px;z-index:60;}
  .small-pass input{width:100px;padding:4px;}
  .guest-mini{position:fixed;right:12px;bottom:12px;background:var(--paper);padding:8px;border-radius:8px;border:1px solid #e6d6cc;font-size:13px;box-shadow:0 6px 12px rgba(0,0,0,0.08);}
  .staff-full{position:fixed;inset:0;background:linear-gradient(180deg,#fff8f2,#fff3ec);padding:18px;z-index:90;display:none;flex-direction:column;overflow:auto;}
  .staff-full.show{display:flex;}
  .staff-top{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .big-toggle{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .big-toggle button{flex:1;padding:12px;border-radius:8px;font-size:16px;border:2px solid #c6b3b3;cursor:pointer;}
  .big-toggle .on{background:#2b8f4a;color:#fff;border-color:#2b8f4a;}
  .big-toggle .off{background:#f0f0f0;color:#666;}
  .staff-body{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;}
  .staff-panel{flex:1;min-width:280px;background:var(--paper);padding:12px;border-radius:8px;border:1px solid #e6d6cc;max-height:520px;overflow:auto;}
  .order-item{padding:8px;border-bottom:1px dashed #e6d0c6;display:flex;justify-content:space-between;align-items:center;}
  .menu-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;}
  .menu-item{padding:8px;border:2px solid #e0bdb5;background:#fff;border-radius:8px;text-align:center;cursor:pointer;}
  img.menu-thumb{width:100%;height:120px;object-fit:cover;border-radius:6px;}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:100;}
  .modal{background:#fff;padding:16px;border-radius:10px;width:760px;max-width:95%;box-shadow:0 8px 30px rgba(0,0,0,0.4);border:6px solid var(--accent);}
  .art-area{position:relative;width:240px;height:240px;border-radius:6px;overflow:hidden;border:1px solid #d4c0b8;background:#b36e3c;}
  .art-area canvas{position:absolute;left:0;top:0;width:240px;height:240px;}
  .card-canvas{border:1px solid #e6d0c6;background:var(--card-skin);border-radius:8px;}
  .small-info{font-size:12px;color:var(--muted);}
  .status-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:120;flex-direction:column;color:#111;}
  .status-card{width:80%;max-width:720px;background:rgba(255,255,255,0.98);padding:28px;border-radius:12px;border:4px solid var(--accent);text-align:center;font-size:26px;font-weight:700;}
  .status-sub{font-size:14px;color:#444;margin-top:8px;}
  @media (max-width:600px){
    .order-btn{font-size:28px;padding:18px 28px;}
    .modal{width:94%;}
    .staff-body{flex-direction:column;}
    .staff-panel{max-height:none;}
    .guest-mini{right:8px;bottom:8px;font-size:12px;padding:6px;}
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>ゲームカフェ 飲食疑似提供サイト</h1>
    <div class="small-info">現在時刻: <span id="nowtime">--:--:--</span></div>
  </header>

  <div class="content">
    <div class="order-block">
      <div id="shiftShort" class="status-line">読み込み中...</div>
      <button id="orderBtn" class="order-btn disabled">注文</button>
      <div id="helperSmall" class="small-info">①注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div>
    </div>
  </div>

  <div class="guest-mini" id="guestMini">
    <div id="guestRole"><strong>あなたは現在：客</strong></div>
    <div class="small-info" style="margin-top:6px">スタッフは「1232」で入室</div>
  </div>

  <div class="small-pass">
    <label style="font-size:12px;margin:0">スタッフパス</label>
    <input id="staffPass" placeholder="小さい" />
    <button id="passOk" class="small">OK</button>
  </div>
</div>

<!-- Staff full-screen UI -->
<div id="staffFull" class="staff-full" aria-hidden="true">
  <div class="staff-top">
    <div>
      <strong id="staffBadge">スタッフ</strong>
      <div class="small-info">全画面スタッフモード</div>
    </div>
    <div>
      <button id="logoutStaff" class="small">退室</button>
    </div>
  </div>

  <div style="margin-top:8px;">
    <div style="display:flex;gap:8px;align-items:center;">
      <label>シフト開始</label><input id="shiftStart" type="time" />
      <label>終了</label><input id="shiftEnd" type="time" />
      <button id="saveShift" class="small">保存</button>
    </div>

    <div class="big-toggle" style="margin-top:8px;">
      <button id="shiftBtn" class="on">シフト中</button>
      <button id="breakBtn" class="off">休憩中</button>
    </div>
  </div>

  <div class="staff-body">
    <div class="staff-panel">
      <strong>現在のシフト一覧</strong>
      <div id="shiftList" class="shift-list small-info" style="margin-top:8px">読み込み中…</div>
    </div>

    <div class="staff-panel">
      <strong>スタッフ用 注文一覧 <small id="pendingTasksSmall" class="small-info"></small></strong>
      <div id="staffOrderList" class="order-list" style="margin-top:8px">注文を待っています</div>
    </div>
  </div>
</div>

<!-- Status overlay for client -->
<div id="orderStatusOverlay" class="status-overlay">
  <div class="status-card" id="orderStatusCard">状態
    <div class="status-sub" id="orderStatusSub">①注意：事故として必ずスタッフ（店員）が対応できない場合もございます</div>
  </div>
</div>

<!-- Modals -->
<div id="modalName" class="modal-back">
  <div class="modal">
    <h3>名前を入力</h3>
    <input id="orderName" placeholder="名前を入力" />
    <div style="margin-top:10px;text-align:right;">
      <button id="cancelOrderName" class="small">キャンセル</button>
      <button id="okOrderName" class="btn-red">決定</button>
    </div>
  </div>
</div>

<div id="modalMenu" class="modal-back">
  <div class="modal">
    <h3>メニューを選択</h3>
    <div class="menu-grid" id="menuGrid"></div>
    <div style="margin-top:10px;text-align:right;"><button id="backMenu" class="small">戻る</button></div>
  </div>
</div>

<!-- Make latte modal -->
<div id="modalMakeLatte" class="modal-back">
  <div class="modal" style="width:95%;max-width:920px;">
    <h3>カフェラテ制作（担当：<span id="makerName"></span>）</h3>
    <div style="display:flex;flex-wrap:wrap;gap:12px;">
      <div style="flex:1;min-width:280px;">
        <div style="height:220px;display:flex;align-items:center;justify-content:center;">
          <div style="width:180px;height:180px;border-radius:12px;background:#fff8f2;display:flex;align-items:center;justify-content:center;border:2px solid #d2b6ab;position:relative;">
            <div style="position:absolute;left:8px;top:8px;right:8px;bottom:8px;display:flex;align-items:center;justify-content:center;flex-direction:column;">
              <div id="espressoCup" style="width:120px;height:120px;border-radius:60px;overflow:hidden;position:relative;background:#6b3b24;">
                <canvas id="latteCanvas" width="120" height="120" style="display:block;"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label>エスプレッソ注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startEsp" class="small">注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="espBar" style="height:100%;width:0%;background:linear-gradient(90deg,#a7552b,#6b3);"></div>
                </div>
                <div style="position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;">
                  <div id="espMarkerLow" style="position:absolute;left:95%;top:0;bottom:0;width:2px;background:rgba(255,255,255,0.85);transform:translateX(-1px);"></div>
                  <div id="espMarkerHigh" style="position:absolute;left:105%;top:0;bottom:0;width:2px;background:rgba(255,255,255,0.85);transform:translateX(-1px);"></div>
                </div>
              </div>
              <div id="espPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格: 95%〜105%。120% は注ぎ過ぎ（失敗）。</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label>フームドミルク注ぎ</label>
          <div style="background:#eee;border-radius:6px;padding:6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="startMilk" class="small" disabled>注ぐ（押し続け）</button>
              <div style="flex:1;position:relative;">
                <div style="height:16px;background:#fff;border-radius:8px;border:1px solid #d4c0b8;overflow:hidden;position:relative;">
                  <div id="milkBar" style="height:100%;width:0%;background:linear-gradient(90deg,#fff,#eee);"></div>
                </div>
                <div style="position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;">
                  <div id="milkMarkerLow" style="position:absolute;left:95%;top:0;bottom:0;width:2px;background:rgba(0,0,0,0.6);transform:translateX(-1px);"></div>
                  <div id="milkMarkerHigh" style="position:absolute;left:105%;top:0;bottom:0;width:2px;background:rgba(0,0,0,0.6);transform:translateX(-1px);"></div>
                </div>
              </div>
              <div id="milkPct" style="width:48px;text-align:right;font-weight:700;">0%</div>
            </div>
            <div class="small-info">合格: 95%〜105%。120% 到達で失敗。</div>
          </div>
        </div>
      </div>

      <div style="flex:1;min-width:300px;">
        <div style="background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>ラテアート（白ペン）</strong>
          <div style="margin-top:8px;">
            <div class="art-area" id="artArea">
              <canvas id="artBg" width="240" height="240"></canvas>
              <canvas id="artLayer" width="240" height="240"></canvas>
            </div>
            <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
              <label>ツール</label>
              <select id="penMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
              <label>太さ</label>
              <select id="penSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
              <button id="clearArt" class="small">クリア</button>
            </div>
            <div style="margin-top:8px;text-align:right;">
              <button id="saveArt" class="btn-green" disabled>アート保存</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;background:#fff8ef;padding:8px;border-radius:8px;border:1px solid #e0c7bb;">
          <strong>メッセージカード（手書き）</strong>
          <div style="margin-top:6px;">
            <canvas id="cardCanvas" class="card-canvas" width="320" height="120"></canvas>
          </div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
            <label>ツール</label>
            <select id="cardMode"><option value="draw">描く</option><option value="erase">消しゴム</option></select>
            <label>太さ</label>
            <select id="cardSize"><option value="2">小</option><option value="6" selected>中</option><option value="12">大</option></select>
            <button id="clearCard" class="small">クリア</button>
          </div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveCard" class="small" disabled>カード保存</button>
          </div>
        </div>

        <div style="margin-top:8px;display:flex;justify-content:flex-end;align-items:center;gap:8px;">
          <div id="taskStatusSmall" class="small-info" style="margin-right:auto"></div>
          <button id="completeMake" class="btn-red" disabled>提供する（完了）</button>
          <button id="cancelMake" class="small">中止</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Eat modal -->
<div id="modalEat" class="modal-back">
  <div class="modal">
    <h3>飲食画面</h3>
    <div style="display:flex;gap:12px;">
      <div style="flex:1;">
        <div style="width:320px;height:240px;border:1px solid #d4c0b8;border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;position:relative;">
          <img id="servedImage" src="" alt="商品画像" style="max-width:100%;max-height:100%;border-radius:8px;" />
        </div>
        <div style="margin-top:8px;display:flex;gap:6px;align-items:center;">
          <button id="eatNext" class="small">食べる（次へ）</button>
          <div id="eatSoundInfo" class="small-info">クリックで rate.mp3 を順に再生</div>
        </div>
      </div>
      <div style="width:200px;">
        <div style="border:1px solid #e2cfc8;padding:8px;border-radius:8px;background:#fff7f3;">
          <strong>メッセージカード</strong>
          <div id="servedCard" style="margin-top:8px;background:var(--card-skin);padding:8px;border-radius:6px;border:1px solid #e6d0c6;min-height:120px;">カードはここに表示されます。</div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveImageBtn" class="small">画像保存</button>
            <button id="homeFromEat" class="small">ホームへ</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/*
  修正点:
  - replayStrokesOnCtx をこのスクリプト内で一度だけ定義（重複削除）。
  - アート・カードの描画 => 数値化 (strokes配列) を Firestore に保存する実装。
  - 提供ボタンが反応しない問題を修正（completeMake ハンドラの存在・動作を確保）。
  - 配信時に客側で飲食画面を生成して表示する仕組みを実装（art / card を再構築）。
  - 重複定義や名前の衝突を避けるため、関数は全て一度だけ定義。
*/

/* Firebase imports */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
import { getFirestore, collection, doc, onSnapshot, addDoc, updateDoc, deleteDoc, getDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";
import { getStorage, ref as storageRef, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-storage.js";

/* Firebase config */
const firebaseConfig = {
  apiKey: "AIzaSyCNm1bmsVG4uZIJaL-bwbIcLCghzJ-ejvM",
  authDomain: "reiji-cafr.firebaseapp.com",
  projectId: "reiji-cafr",
  storageBucket: "reiji-cafr.firebasestorage.app",
  messagingSenderId: "18020287382",
  appId: "1:18020287382:web:1a87e6378598697ea3d3b7",
  measurementId: "G-F35S7FGW9M"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);
signInAnonymously(auth).catch(e=>console.warn('匿名サインイン失敗', e));

/* DOM refs - reuse IDs from HTML above */
const nowtime = document.getElementById('nowtime');
const orderBtn = document.getElementById('orderBtn');
const staffPass = document.getElementById('staffPass');
const passOk = document.getElementById('passOk');
const shiftShort = document.getElementById('shiftShort');
const helperSmall = document.getElementById('helperSmall');
const staffFull = document.getElementById('staffFull');
const staffBadge = document.getElementById('staffBadge');
const logoutStaff = document.getElementById('logoutStaff');
const shiftBtn = document.getElementById('shiftBtn');
const breakBtn = document.getElementById('breakBtn');
const shiftStart = document.getElementById('shiftStart');
const shiftEnd = document.getElementById('shiftEnd');
const saveShift = document.getElementById('saveShift');
const shiftList = document.getElementById('shiftList');
const staffOrderList = document.getElementById('staffOrderList');
const pendingTasksSmall = document.getElementById('pendingTasksSmall');

const modalName = document.getElementById('modalName');
const orderName = document.getElementById('orderName');
const cancelOrderName = document.getElementById('cancelOrderName');
const okOrderName = document.getElementById('okOrderName');
const modalMenu = document.getElementById('modalMenu');
const menuGrid = document.getElementById('menuGrid');
const backMenu = document.getElementById('backMenu');

const modalMakeLatte = document.getElementById('modalMakeLatte');
const makerName = document.getElementById('makerName');
const startEsp = document.getElementById('startEsp');
const espBar = document.getElementById('espBar');
const espPct = document.getElementById('espPct');
const startMilk = document.getElementById('startMilk');
const milkBar = document.getElementById('milkBar');
const milkPct = document.getElementById('milkPct');

const artBg = document.getElementById('artBg');
const artLayer = document.getElementById('artLayer');
const artBgCtx = artBg.getContext('2d');
const artLayerCtx = artLayer.getContext('2d');
const penMode = document.getElementById('penMode');
const penSize = document.getElementById('penSize');
const clearArt = document.getElementById('clearArt');
const saveArt = document.getElementById('saveArt');

const cardCanvas = document.getElementById('cardCanvas');
const cardCtx = cardCanvas.getContext('2d');
const cardMode = document.getElementById('cardMode');
const cardSize = document.getElementById('cardSize');
const clearCard = document.getElementById('clearCard');
const saveCard = document.getElementById('saveCard');

const taskStatusSmall = document.getElementById('taskStatusSmall');
const completeMake = document.getElementById('completeMake');
const cancelMake = document.getElementById('cancelMake');

const modalEat = document.getElementById('modalEat');
const servedImage = document.getElementById('servedImage');
const servedCard = document.getElementById('servedCard');
const eatNext = document.getElementById('eatNext');
const saveImageBtn = document.getElementById('saveImageBtn');
const homeFromEat = document.getElementById('homeFromEat');

const orderStatusOverlay = document.getElementById('orderStatusOverlay');
const orderStatusCard = document.getElementById('orderStatusCard');
const orderStatusSub = document.getElementById('orderStatusSub');

/* assets */
function getAssetUrl(path){ if(!path) return ''; if(path.startsWith('@')) return 'https://raw.githubusercontent.com/'+path.slice(1); try{ return new URL(path).href }catch(e){ return path; } }
const audioTyaimu = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/tyaimu.mp3'));
const audioCookbgm = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/cookbgm.mp3'));
const audioRate = new Audio(getAssetUrl('@zzcafe2800/reiji_cafe/files/rate.mp3'));

/* collections */
const staffsCol = collection(db,'staffs');
const ordersCol = collection(db,'orders');

/* state */
const state = { staffs:[], orders:[], currentUser:{role:'guest',staffId:null}, currentOrderIdForClient:null };

/* utils */
function uid(p='id'){ return p + Math.random().toString(36).slice(2,9); }
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function show(el){ if(el) el.style.display=''; }
function hide(el){ if(el) el.style.display='none'; }
function showModal(m){ if(m) m.style.display='flex'; }
function hideModal(m){ if(m) m.style.display='none'; }
setInterval(()=> nowtime.textContent = new Date().toLocaleTimeString(), 1000);

/* single implementation of replayStrokesOnCtx (only once in this file) */
/* strokes: [{ mode:'draw'|'erase', color:'#fff', width:number, points:[{x:0..1,y:0..1}, ...] }, ...] */
function replayStrokesOnCtx(strokes, ctx, width, height){
  if(!strokes || !ctx) return;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  for(const s of strokes){
    if(!s.points || s.points.length<2) continue;
    ctx.lineWidth = s.width || 4;
    if(s.mode === 'erase' || s.mode === 'eraseStroke'){
      ctx.globalCompositeOperation = 'destination-out';
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = s.color || '#fff';
    }
    ctx.beginPath();
    for(let i=0;i<s.points.length-1;i++){
      const p1 = s.points[i], p2 = s.points[i+1];
      const x1 = p1.x * width, y1 = p1.y * height, x2 = p2.x * width, y2 = p2.y * height;
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
    }
    ctx.stroke();
  }
  ctx.restore();
}

/* Firestore realtime listeners */
try {
  const qS = query(staffsCol, orderBy('createdAt','asc'));
  onSnapshot(qS, snap => {
    state.staffs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    state.staffs.forEach(s=>{ s.onShift = !!s.onShift; s.breaking = !!s.breaking; s.shiftStart ||= '09:00'; s.shiftEnd ||= '17:00'; });
    dedupeStaffsByName(); updateShiftShort(); renderShiftList(); updateOrderButtonState(); renderOrderLists();
  }, err=>console.warn(err));
} catch(e){ console.warn(e); }

try {
  const qO = query(ordersCol, orderBy('createdAt','asc'));
  onSnapshot(qO, snap => {
    state.orders = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    dedupeOrdersByName(); renderOrderLists(); updateClientOverlay();
  }, err=>console.warn(err));
} catch(e){ console.warn(e); }

/* dedupe helpers (best-effort deletion of older duplicates) */
async function dedupeStaffsByName(){
  const byName = {};
  state.staffs.forEach(s=>{ const n=(s.name||'').trim(); if(!n) return; byName[n]=byName[n]||[]; byName[n].push(s); });
  for(const n in byName){
    const arr = byName[n].sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
    for(let i=1;i<arr.length;i++){ try{ await deleteDoc(doc(db,'staffs',arr[i].id)); } catch(e){} }
  }
}
async function dedupeOrdersByName(){
  const byName = {};
  state.orders.forEach(o=>{ const n=(o.name||'').trim(); if(!n) return; byName[n]=byName[n]||[]; byName[n].push(o); });
  for(const n in byName){
    const arr = byName[n].sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
    for(let i=1;i<arr.length;i++){ try{ await deleteDoc(doc(db,'orders',arr[i].id)); } catch(e){} }
  }
}

/* UI updates */
function updateShiftShort(){
  const now = new Date();
  const active = (state.staffs||[]).filter(s=> s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now));
  if(!active.length) shiftShort.textContent = '状況①：現在、スタッフ対応不可（シフト外／休憩中）';
  else shiftShort.textContent = '状況①：' + active.map(s=>`${s.name} (${s.shiftStart}〜${s.shiftEnd})`).join(' / ');
}
function renderShiftList(){ shiftList.innerHTML=''; const now=new Date(); (state.staffs||[]).forEach(s=>{ const d=document.createElement('div'); const onNow=isNowWithinShift(s.shiftStart,s.shiftEnd,now); d.innerHTML=`<strong>${escapeHtml(s.name)}</strong> ${s.shiftStart}〜${s.shiftEnd} ${s.onShift?'<span style="color:green">シフト中</span>':'<span style="color:gray">-</span>'} ${s.breaking?'<span style="color:orange">休憩中</span>':''} ${onNow?'<span class="small-info">（現在この時間）</span>':''}`; shiftList.appendChild(d); }); }
function isNowWithinShift(start,end,dateObj){ if(!start||!end) return false; const [sh,sm]=start.split(':').map(Number); const [eh,em]=end.split(':').map(Number); const sDate=new Date(dateObj); sDate.setHours(sh,sm,0,0); const eDate=new Date(dateObj); eDate.setHours(eh,em,0,0); if(eDate<=sDate) eDate.setDate(eDate.getDate()+1); return dateObj>=sDate && dateObj<=eDate; }
function updateOrderButtonState(){ const now=new Date(); const any = (state.staffs||[]).some(s=> s.onShift && !s.breaking && isNowWithinShift(s.shiftStart,s.shiftEnd,now)); if(any) orderBtn.classList.remove('disabled'); else orderBtn.classList.add('disabled'); }

/* render staff orders */
function renderOrderLists(){
  staffOrderList.innerHTML='';
  const now = Date.now();
  (state.orders||[]).forEach(o=>{
    if(!o || o.state==='cancelled') return;
    if(o.state==='delivered' || o.state==='served') return;
    if((now - (o.createdAt||now)) > 5*60*1000){ try{ deleteDoc(doc(db,'orders',o.id)); } catch(e){}; return; }
    const div = document.createElement('div'); div.className='order-item';
    const left = document.createElement('div'); left.innerHTML = `<strong>${escapeHtml(o.name)}</strong><div class="small-info">${escapeHtml(o.item)} - 状態:${escapeHtml(o.state)} - 作成:${new Date(o.createdAt||0).toLocaleTimeString()}</div>`;
    const right = document.createElement('div');
    const tasks = computeOrderTasks(o);
    if(tasks.length){ const t=document.createElement('div'); t.className='small-info'; t.textContent='未完了: '+tasks.join(', '); right.appendChild(t); }
    if(o.state==='waiting'){ const btn=document.createElement('button'); btn.textContent='対応'; btn.className='small btn-green'; btn.onclick=()=> assignOrderToCurrentStaff(o.id); right.appendChild(btn); }
    else if(o.state==='inprogress'){ const info=document.createElement('div'); info.className='small-info'; info.textContent=`担当: ${o.assignedToName||o.assignedTo||''}`; right.appendChild(info); const makeBtn=document.createElement('button'); makeBtn.textContent='制作'; makeBtn.className='small'; makeBtn.onclick=()=> openMakeModal(o); right.appendChild(makeBtn); }
    else if(o.state==='done'){ const pBtn=document.createElement('button'); pBtn.textContent='提供'; pBtn.className='small btn-green'; pBtn.onclick=()=> openMakeModal(o); right.appendChild(pBtn); }
    div.appendChild(left); div.appendChild(right); staffOrderList.appendChild(div);
  });
  pendingTasksSmall.textContent = (state.orders||[]).filter(o=> o.state==='waiting' || o.state==='inprogress').length ? ` 未処理:${(state.orders||[]).filter(o=> o.state==='waiting' || o.state==='inprogress').length}` : '';
}
function computeOrderTasks(o){ const pending=[]; if(!o) return pending; if(o.state==='waiting') pending.push('対応待ち'); if(o.state==='inprogress' || o.state==='done'){ if(!o.artStrokes && !o.artDataUrl) pending.push('アート'); if(!o.cardStrokes && !o.cardDataUrl) pending.push('カード'); if(o.state!=='delivered' && o.state!=='served') pending.push('提供待ち'); } return pending; }

/* menu & ordering */
const menuItems = [{ id:'latte', title:'カフェラテ', imageBase:'@zzcafe2800/reiji_cafe/main/rate' }];

async function buildMenu(){
  menuGrid.innerHTML='';
  for(const it of menuItems){
    const div=document.createElement('div'); div.className='menu-item';
    const img=document.createElement('img'); img.className='menu-thumb'; img.alt=it.title;
    const url = getAssetUrl(it.imageBase + '1.png');
    try{ const res=await fetch(url); if(res.ok){ const blob = await res.blob(); img.src = URL.createObjectURL(blob); } else img.src = placeholder(it.title); } catch(e){ img.src = placeholder(it.title); }
    div.appendChild(img); const t = document.createElement('div'); t.textContent = it.title; div.appendChild(t);
    div.addEventListener('click', ()=> onMenuSelect(it));
    menuGrid.appendChild(div);
  }
}
function placeholder(title){ const c=document.createElement('canvas'); c.width=320; c.height=240; const ctx=c.getContext('2d'); ctx.fillStyle='#fff8ef'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#6b3b24'; ctx.beginPath(); ctx.arc(160,110,60,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText(title,100,200); return c.toDataURL(); }

orderBtn.addEventListener('click', ()=>{
  if(orderBtn.classList.contains('disabled')) return;
  try{ audioTyaimu.currentTime=0; audioTyaimu.play(); } catch(e){}
  showModal(modalName); orderName.value=''; orderName.placeholder='名前を入力';
  okOrderName.onclick = ()=> {
    const name = orderName.value.trim(); if(!name){ alert('名前を入力'); return; }
    hideModal(modalName); buildMenu(); showModal(modalMenu); okOrderName.onclick = null;
  };
});
backMenu.addEventListener('click', ()=> hideModal(modalMenu));

async function onMenuSelect(item){
  hideModal(modalMenu);
  const name = orderName.value.trim() || '名無し';
  const createdAt = Date.now(); const expiresAt = createdAt + 5*60*1000;
  const order = { name, item:item.id, state:'waiting', createdAt, expiresAt, assignedTo:null, assignedToName:null, artStrokes:null, cardStrokes:null, artDataUrl:null, cardDataUrl:null, servedImageUrl:null };
  try{ const r = await addDoc(ordersCol, order); state.currentOrderIdForClient = r.id; showClientOverlay('現在対応待ち中'); scheduleOrderTimeout({ id:r.id, expiresAt }); } catch(e){ console.warn(e); order.id=uid('o'); state.orders.push(order); state.currentOrderIdForClient = order.id; showClientOverlay('現在対応待ち中'); renderOrderLists(); }
}

/* staff login */
passOk.addEventListener('click', ()=>{
  if(staffPass.value === '1232'){ showModal(modalName); orderName.placeholder='スタッフ名を入力'; okOrderName.onclick = async ()=> { const name = orderName.value.trim(); if(!name){ alert('名前'); return; } hideModal(modalName); try{ const r = await addDoc(staffsCol, { name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() }); enterStaffFull(name, r.id); } catch(e){ console.warn(e); const s={ id: uid('s'), name, shiftStart:'09:00', shiftEnd:'17:00', onShift:true, breaking:false, createdAt: Date.now() }; state.staffs.push(s); enterStaffFull(name, s.id); } okOrderName.onclick = null; }; } else alert('パスワードが違います'); });

function enterStaffFull(name,id){ state.currentUser.role='staff'; state.currentUser.staffId=id; staffBadge.textContent=name; staffFull.classList.add('show'); renderShiftList(); renderOrderLists(); }
logoutStaff.addEventListener('click', async ()=>{ const id = state.currentUser.staffId; if(id){ try{ await deleteDoc(doc(db,'staffs',id)); } catch(e){} } state.currentUser={role:'guest',staffId:null}; staffFull.classList.remove('show'); });

shiftBtn.addEventListener('click', async ()=>{ const id = state.currentUser.staffId; if(!id) return; try{ await updateDoc(doc(db,'staffs',id), { onShift:true, breaking:false }); } catch(e){} });
breakBtn.addEventListener('click', async ()=>{ const id = state.currentUser.staffId; if(!id) return; try{ await updateDoc(doc(db,'staffs',id), { onShift:false, breaking:true }); } catch(e){} });
saveShift.addEventListener('click', async ()=>{ const id = state.currentUser.staffId; if(!id) return; try{ await updateDoc(doc(db,'staffs',id), { shiftStart: shiftStart.value||'09:00', shiftEnd: shiftEnd.value||'17:00' }); alert('保存'); } catch(e){ console.warn(e); } });

/* assign/order actions */
async function assignOrderToCurrentStaff(orderId){
  const staffId = state.currentUser.staffId; if(!staffId){ alert('スタッフとしてログイン'); return; }
  const staff = state.staffs.find(s=>s.id===staffId);
  try{ await updateDoc(doc(db,'orders',orderId), { state:'inprogress', assignedTo: staffId, assignedToName: staff.name }); try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play(); } catch(e){} } catch(e){ console.warn(e); }
}

/* --- Make modal logic (pour/art/card/save/provide) --- */
const latteCanvas = document.getElementById('latteCanvas');
const latteCtx = latteCanvas.getContext('2d');
function resetLatteCanvas(){ latteCtx.clearRect(0,0,latteCanvas.width,latteCanvas.height); latteCtx.fillStyle='#6b3b24'; latteCtx.beginPath(); latteCtx.arc(60,60,58,0,Math.PI*2); latteCtx.fill(); }
resetLatteCanvas();

let espInterval=null, milkInterval=null, espDone=false, milkDone=false;
function resetPouring(){ if(espInterval) clearInterval(espInterval); if(milkInterval) clearInterval(milkInterval); espInterval=null; milkInterval=null; espDone=false; milkDone=false; espBar.style.width='0%'; espPct.textContent='0%'; milkBar.style.width='0%'; milkPct.textContent='0%'; startEsp.disabled=false; startMilk.disabled=true; resetLatteCanvas(); updateTaskStatus(); }

function startLoop(barEl,pctEl,over120Cb){
  let pct=0;
  const it = setInterval(()=>{ pct = Math.min(130,pct + Math.random()*4 + 1); barEl.style.width = pct + '%'; pctEl.textContent = Math.round(pct) + '%'; if(pct>=120){ clearInterval(it); over120Cb(); } }, 100);
  return { it, getPct: ()=> pct };
}
startEsp.addEventListener('mousedown', ()=>{ if(espInterval) return; startEsp.textContent='注ぎ中...'; const r = startLoop(espBar,espPct, ()=>{ alert('注ぎ過ぎ(120%)。最初から'); resetPouring(); }); espInterval = r.it; });
startEsp.addEventListener('mouseup', ()=>{ if(espInterval){ clearInterval(espInterval); espInterval=null; } startEsp.textContent='注ぐ（押し続け）'; const pct = parseFloat(espBar.style.width)||0; if(pct>=95 && pct<=105){ espDone=true; playTone(523,0.12); latteCtx.fillStyle='#5a2f1a'; latteCtx.fillRect(0,60,latteCanvas.width,60); startMilk.disabled=false; updateTaskStatus(); } else{ alert('合格ライン外。最初から'); resetPouring(); } });
startEsp.addEventListener('touchstart',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mousedown')); });
startEsp.addEventListener('touchend',(e)=>{ e.preventDefault(); startEsp.dispatchEvent(new Event('mouseup')); });

startMilk.addEventListener('mousedown', ()=>{ if(milkInterval) return; startMilk.textContent='注ぎ中...'; const r = startLoop(milkBar,milkPct, ()=>{ alert('注ぎ過ぎ(120%)。最初から'); resetPouring(); }); milkInterval = r.it; });
startMilk.addEventListener('mouseup', ()=>{ if(milkInterval){ clearInterval(milkInterval); milkInterval=null; } startMilk.textContent='注ぐ（押し続け）'; const pct = parseFloat(milkBar.style.width)||0; if(pct>=95 && pct<=105){ milkDone=true; playTone(660,0.12); latteCtx.fillStyle='#f6efe6'; latteCtx.beginPath(); latteCtx.arc(60,60,48,0,Math.PI*2); latteCtx.fill(); updateTaskStatus(); } else{ alert('合格ライン外。最初から'); resetPouring(); } });
startMilk.addEventListener('touchstart',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mousedown')); });
startMilk.addEventListener('touchend',(e)=>{ e.preventDefault(); startMilk.dispatchEvent(new Event('mouseup')); });

/* art & card stroke recording and replay */
let artStrokes = []; let currentArtStroke = null;
function initArt(){ artBgCtx.clearRect(0,0,artBg.width,artBg.height); artBgCtx.fillStyle='#6b3b24'; artBgCtx.beginPath(); artBgCtx.arc(120,120,100,0,Math.PI*2); artBgCtx.fill(); artLayerCtx.clearRect(0,0,artLayer.width,artLayer.height); artLayerCtx.globalCompositeOperation='source-over'; artStrokes = []; saveArt.disabled=true; }
initArt();

let artDrawing=false, artLast={x:0,y:0};
function artGetPos(e){ const r = artLayer.getBoundingClientRect(); const t = e.touches ? e.touches[0] : null; const cx = t ? t.clientX : e.clientX; const cy = t ? t.clientY : e.clientY; return { x: (cx - r.left) * (artLayer.width / r.width), y: (cy - r.top) * (artLayer.height / r.height) }; }
artLayer.addEventListener('mousedown',(e)=>{ artDrawing=true; artLast = artGetPos(e); currentArtStroke = { mode: penMode.value, color: (penMode.value==='draw'?'#fff':'#000'), width: parseInt(penSize.value,10), points:[{x:artLast.x/artLayer.width, y:artLast.y/artLayer.height}] }; });
artLayer.addEventListener('mousemove',(e)=>{ if(!artDrawing) return; const p = artGetPos(e); drawArtSegment(artLast,p); artLast=p; currentArtStroke.points.push({ x:p.x/artLayer.width, y:p.y/artLayer.height }); });
artLayer.addEventListener('mouseup', ()=>{ if(artDrawing && currentArtStroke){ artStrokes.push(currentArtStroke); currentArtStroke=null; saveArt.disabled=false; updateTaskStatus(); } artDrawing=false; artLayerCtx.globalCompositeOperation='source-over'; });
artLayer.addEventListener('mouseleave', ()=>{ if(artDrawing && currentArtStroke){ artStrokes.push(currentArtStroke); currentArtStroke=null; saveArt.disabled=false; updateTaskStatus(); } artDrawing=false; artLayerCtx.globalCompositeOperation='source-over'; });
artLayer.addEventListener('touchstart',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousedown',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); });
artLayer.addEventListener('touchmove',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mousemove',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); });
artLayer.addEventListener('touchend',(e)=>{ e.preventDefault(); artLayer.dispatchEvent(new MouseEvent('mouseup')); });

function drawArtSegment(from,to){
  const size = parseInt(penSize.value,10);
  const mode = penMode.value;
  if(mode==='draw'){ artLayerCtx.globalCompositeOperation='source-over'; artLayerCtx.strokeStyle='#ffffff'; artLayerCtx.lineWidth=size; }
  else { artLayerCtx.globalCompositeOperation='destination-out'; artLayerCtx.lineWidth=size; }
  artLayerCtx.beginPath(); artLayerCtx.moveTo(from.x,from.y); artLayerCtx.lineTo(to.x,to.y); artLayerCtx.stroke();
}
clearArt.addEventListener('click', ()=> initArt());

saveArt.addEventListener('click', async ()=>{
  if(!currentMakingOrderId){ alert('対象注文がありません'); return; }
  try{
    const tmp = document.createElement('canvas'); tmp.width = latteCanvas.width; tmp.height = latteCanvas.height; const tctx = tmp.getContext('2d');
    tctx.fillStyle = '#6b3b24'; tctx.beginPath(); tctx.arc(60,60,58,0,Math.PI*2); tctx.fill();
    replayStrokesOnCtx(artStrokes, tctx, tmp.width, tmp.height);
    const artDataUrl = tmp.toDataURL('image/png');
    await updateDoc(doc(db,'orders',currentMakingOrderId), { artStrokes: artStrokes.length?artStrokes:null, artDataUrl: artDataUrl });
    saveArt.disabled = true; updateTaskStatus(); alert('アートを保存しました（数値）');
  } catch(e){ console.warn(e); alert('アート保存に失敗しました'); saveArt.disabled = true; updateTaskStatus(); }
});

/* card strokes */
let cardStrokes = []; let currentCardStroke = null;
function initCard(){ cardCtx.clearRect(0,0,cardCanvas.width,cardCanvas.height); cardCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin') || '#fff2e6'; cardCtx.fillRect(0,0,cardCanvas.width,cardCanvas.height); cardStrokes=[]; saveCard.disabled=true; }
initCard();

let cardDrawing=false, cardLast={x:0,y:0};
cardCanvas.addEventListener('mousedown',(e)=>{ cardDrawing=true; cardLast = getCardPos(e); currentCardStroke = { mode: cardMode.value, color:'#000', width: parseInt(cardSize.value,10), points: [{ x: cardLast.x/cardCanvas.width, y: cardLast.y/cardCanvas.height }] }; });
cardCanvas.addEventListener('mousemove',(e)=>{ if(!cardDrawing) return; const p = getCardPos(e); drawCardSeg(cardLast,p); cardLast = p; currentCardStroke.points.push({ x:p.x/cardCanvas.width, y:p.y/cardCanvas.height }); });
cardCanvas.addEventListener('mouseup', ()=>{ if(cardDrawing && currentCardStroke){ cardStrokes.push(currentCardStroke); currentCardStroke=null; saveCard.disabled=false; updateTaskStatus(); } cardDrawing=false; cardCtx.globalCompositeOperation='source-over'; });
cardCanvas.addEventListener('mouseleave', ()=>{ if(cardDrawing && currentCardStroke){ cardStrokes.push(currentCardStroke); currentCardStroke=null; saveCard.disabled=false; updateTaskStatus(); } cardDrawing=false; cardCtx.globalCompositeOperation='source-over'; });
cardCanvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousedown',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); });
cardCanvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mousemove',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); });
cardCanvas.addEventListener('touchend',(e)=>{ e.preventDefault(); cardCanvas.dispatchEvent(new MouseEvent('mouseup')); });

function getCardPos(e){ const r=cardCanvas.getBoundingClientRect(); const t=e.touches?e.touches[0]:null; const cx = t? t.clientX : e.clientX; const cy = t? t.clientY : e.clientY; return { x: (cx - r.left)*(cardCanvas.width / r.width), y: (cy - r.top)*(cardCanvas.height / r.height) }; }
function drawCardSeg(from,to){ const size=parseInt(cardSize.value,10); const mode = cardMode.value; if(mode==='draw'){ cardCtx.globalCompositeOperation='source-over'; cardCtx.strokeStyle='#000'; cardCtx.lineWidth=size; } else { cardCtx.globalCompositeOperation='destination-out'; cardCtx.lineWidth=size; } cardCtx.beginPath(); cardCtx.moveTo(from.x,from.y); cardCtx.lineTo(to.x,to.y); cardCtx.stroke(); }
clearCard.addEventListener('click', ()=> initCard());

saveCard.addEventListener('click', async ()=>{
  if(!currentMakingOrderId){ alert('対象注文がありません'); return; }
  try{
    const tmp = document.createElement('canvas'); tmp.width = cardCanvas.width; tmp.height = cardCanvas.height; const tctx = tmp.getContext('2d');
    tctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin') || '#fff2e6'; tctx.fillRect(0,0,tmp.width,tmp.height);
    replayStrokesOnCtx(cardStrokes, tctx, tmp.width, tmp.height);
    const cardDataUrl = tmp.toDataURL('image/png');
    await updateDoc(doc(db,'orders',currentMakingOrderId), { cardStrokes: cardStrokes.length?cardStrokes:null, cardDataUrl: cardDataUrl });
    saveCard.disabled = true; updateTaskStatus(); alert('カードを保存しました（数値）');
  } catch(e){ console.warn(e); alert('カード保存に失敗しました'); saveCard.disabled = true; updateTaskStatus(); }
});

/* update small task status and enable complete */
function updateTaskStatus(){
  const parts = [];
  if(!espDone || !milkDone) parts.push('注ぎ');
  if(!saveArt.disabled) parts.push('アート未保存');
  if(!saveCard.disabled) parts.push('カード未保存');
  taskStatusSmall.textContent = parts.length ? '未完了: '+parts.join(', ') : 'すべて完了';
  completeMake.disabled = parts.length > 0;
}

/* openMakeModal and completeMake flow */
let currentMakingOrderId = null;
function openMakeModal(order){
  currentMakingOrderId = order.id;
  makerName.textContent = order.assignedToName || order.assignedTo || '';
  initArt(); initCard(); resetLatteCanvas(); resetPouring();
  if(order.artStrokes){ replayStrokesOnCtx(order.artStrokes, artLayerCtx, artLayer.width, artLayer.height); artStrokes = order.artStrokes.slice(); saveArt.disabled = true; }
  if(order.cardStrokes){ replayStrokesOnCtx(order.cardStrokes, cardCtx, cardCanvas.width, cardCanvas.height); cardStrokes = order.cardStrokes.slice(); saveCard.disabled = true; }
  espDone = !!order.espCleared; milkDone = !!order.milkCleared;
  startEsp.disabled = !!order.espCleared; startMilk.disabled = !!order.milkCleared || !order.espCleared;
  updateTaskStatus(); showModal(modalMakeLatte);
}

completeMake.addEventListener('click', async ()=>{
  if(!currentMakingOrderId){ alert('対象がありません'); return; }
  // build composite image
  const tmp = document.createElement('canvas'); tmp.width=600; tmp.height=600; const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff8ef'; tctx.fillRect(0,0,tmp.width,tmp.height);
  tctx.drawImage(latteCanvas, 180,120,240,240);
  tctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin') || '#fff2e6'; tctx.fillRect(160,380,280,120);
  tctx.drawImage(cardCanvas, 170,390,260,100);
  const dataUrl = tmp.toDataURL('image/png');
  try{
    const sRef = storageRef(storage, `served_images/${currentMakingOrderId}.png`);
    await uploadString(sRef, dataUrl, 'data_url');
    const url = await getDownloadURL(sRef);
    await updateDoc(doc(db,'orders',currentMakingOrderId), {
      state:'delivered',
      artStrokes: artStrokes.length?artStrokes:null,
      cardStrokes: cardStrokes.length?cardStrokes:null,
      artDataUrl: latteCanvas.toDataURL(),
      cardDataUrl: cardCanvas.toDataURL(),
      servedImageUrl: url,
      deliveredAt: Date.now()
    });
    hideModal(modalMakeLatte); try{ audioCookbgm.pause(); audioCookbgm.currentTime=0; } catch(e){} currentMakingOrderId=null; alert('提供しました（クラウド保存）');
  } catch(e){
    console.warn(e);
    try{ await updateDoc(doc(db,'orders',currentMakingOrderId), { state:'delivered', artStrokes: artStrokes.length?artStrokes:null, cardStrokes: cardStrokes.length?cardStrokes:null, artDataUrl: latteCanvas.toDataURL(), cardDataUrl: cardCanvas.toDataURL(), servedImageUrl: dataUrl, deliveredAt: Date.now() }); } catch(err){ console.warn(err); }
    hideModal(modalMakeLatte); try{ audioCookbgm.pause(); audioCookbgm.currentTime=0; } catch(e){} currentMakingOrderId=null; alert('提供しました（保存処理に一部問題あり）');
  }
});
cancelMake.addEventListener('click', ()=>{ if(confirm('制作を中止しますか？')){ hideModal(modalMakeLatte); currentMakingOrderId=null; } });

/* client: when order becomes delivered, reconstruct and show modalEat */
function updateClientOverlay(){
  if(!state.currentOrderIdForClient) return;
  const o = state.orders.find(x=>x.id===state.currentOrderIdForClient);
  if(!o) return;
  if(o.state === 'waiting'){ showClientStatus('現在対応待ち中'); }
  else if(o.state === 'inprogress'){ showClientStatus('現在調理中…'); try{ audioCookbgm.currentTime=0; audioCookbgm.loop=true; audioCookbgm.play(); } catch(e){} }
  else if(o.state === 'delivered'){ showClientStatus('只今、運搬中'); // present served view
    showServedFromOrder(o);
  } else if(o.state === 'cancelled'){ showClientStatus('スタッフの応答がないため現在注文を取り消しになります'); setTimeout(()=>{ hideClientStatus(); state.currentOrderIdForClient=null; }, 10000); }
}
function showClientStatus(text){ orderStatusCard.textContent = text; orderStatusSub.textContent = '①注意：事故として必ずスタッフ（店員）が対応できない場合もございます'; orderStatusOverlay.style.display='flex'; }
function hideClientStatus(){ orderStatusOverlay.style.display='none'; }

/* showServedFromOrder: reconstruct images from strokes and dataUrls and display to client */
async function showServedFromOrder(order){
  // preload base images (rate1..n)
  const baseImgs = await preloadRateSequenceForItem(order.item);
  const baseImgUrl = baseImgs.length ? baseImgs[0] : null;

  const tmp = document.createElement('canvas'); tmp.width=640; tmp.height=480; const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff8ef'; tctx.fillRect(0,0,tmp.width,tmp.height);

  if(baseImgUrl){ await drawImageOnCanvasFromUrl(baseImgUrl, tctx, tmp.width, tmp.height, 0.6); }
  else { tctx.fillStyle='#6b3b24'; tctx.beginPath(); tctx.arc(tmp.width/2,tmp.height/3,80,0,Math.PI*2); tctx.fill(); }

  if(order.artStrokes && order.artStrokes.length){
    const artTmp = document.createElement('canvas'); artTmp.width=120; artTmp.height=120; const actx = artTmp.getContext('2d');
    actx.fillStyle = '#6b3b24'; actx.beginPath(); actx.arc(60,60,58,0,Math.PI*2); actx.fill();
    replayStrokesOnCtx(order.artStrokes, actx, artTmp.width, artTmp.height);
    tctx.drawImage(artTmp, tmp.width-140, 20, 120, 120);
  } else if(order.artDataUrl){ await drawImageOnCanvasFromUrl(order.artDataUrl, tctx, tmp.width, tmp.height, 0.18, tmp.width-140,20,120,120); }

  if(order.cardStrokes && order.cardStrokes.length){
    const ctmp = document.createElement('canvas'); ctmp.width=260; ctmp.height=100; const cctx = ctmp.getContext('2d');
    cctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-skin') || '#fff2e6'; cctx.fillRect(0,0,ctmp.width,ctmp.height);
    replayStrokesOnCtx(order.cardStrokes, cctx, ctmp.width, ctmp.height);
    tctx.drawImage(ctmp, tmp.width-280, tmp.height-140, 260,100);
  } else if(order.cardDataUrl){ await drawImageOnCanvasFromUrl(order.cardDataUrl, tctx, tmp.width, tmp.height, 0.35, tmp.width-280, tmp.height-140, 260,100); }

  servedImage.src = tmp.toDataURL('image/png');
  servedImage._sequence = baseImgs;
  servedImage._index = 0;

  servedCard.innerHTML = '';
  if(order.cardStrokes && order.cardStrokes.length){
    const displayCanvas = document.createElement('canvas'); displayCanvas.width=260; displayCanvas.height=100; replayStrokesOnCtx(order.cardStrokes, displayCanvas.getContext('2d'), displayCanvas.width, displayCanvas.height);
    servedCard.appendChild(displayCanvas);
  } else if(order.cardDataUrl){
    const i = document.createElement('img'); i.src = order.cardDataUrl; i.style.maxWidth='100%'; servedCard.appendChild(i);
  } else servedCard.textContent = 'カードはありません';

  showModal(modalEat);

  let clickCount = 0;
  eatNext.onclick = ()=>{
    clickCount++;
    const seq = servedImage._sequence || [];
    if(seq.length && servedImage._index < seq.length-1){ servedImage._index++; servedImage.src = seq[servedImage._index]; try{ audioRate.currentTime=0; audioRate.play(); } catch(e){} }
    else if(seq.length && servedImage._index === seq.length-1){ try{ audioRate.currentTime=0; audioRate.play(); } catch(e){} }
    else { try{ audioRate.currentTime=0; audioRate.play(); } catch(e){} }
  };

  saveImageBtn.onclick = ()=> { const a=document.createElement('a'); a.href = servedImage.src; a.download = `served_${order.id}.png`; a.click(); };
  homeFromEat.onclick = ()=> hideModal(modalEat);
}

/* preloadRateSequenceForItem (rate1..rateN) */
async function preloadRateSequenceForItem(itemId){
  const item = menuItems.find(m=>m.id===itemId);
  if(!item) return [];
  const base = item.imageBase || '@zzcafe2800/reiji_cafe/main/rate';
  const imgs = [];
  for(let i=1;i<=12;i++){
    const url = getAssetUrl(base + i + '.png');
    try{
      const res = await fetch(url);
      if(!res.ok){ if(res.status===404) break; else break; }
      const blob = await res.blob(); imgs.push(URL.createObjectURL(blob));
    } catch(e){ break; }
  }
  return imgs;
}

/* helper draw image */
function drawImageOnCanvasFromUrl(url, ctx, canvasW, canvasH, scale=0.6, dx, dy, dw, dh){
  return new Promise((resolve)=>{
    const img = new Image(); img.crossOrigin = 'anonymous';
    img.onload = ()=>{
      const w = img.width, h = img.height;
      const sw = (canvasW * scale), sh = (h/w) * sw;
      const x = dx === undefined ? (canvasW - sw)/2 : dx;
      const y = dy === undefined ? (canvasH - sh)/2 : dy;
      const dw_ = dw || sw, dh_ = dh || sh;
      ctx.drawImage(img, x, y, dw_, dh_);
      resolve();
    };
    img.onerror = ()=> resolve();
    img.src = url;
  });
}

/* schedule cancellation */
function scheduleOrderTimeout(order){
  const remaining = (order.expiresAt || 0) - Date.now();
  if(remaining <= 0) return;
  setTimeout(async ()=>{
    try{ const snap = await getDoc(doc(db,'orders',order.id)); if(snap.exists()){ const o = snap.data(); if(o.state === 'waiting'){ await updateDoc(doc(db,'orders',order.id), { state:'cancelled', cancelReason:'スタッフの応答がないため現在注文を取り消しになります' }); } } } catch(e){ console.warn(e); }
  }, remaining);
}

/* small tone helper */
function playTone(freq=440,dur=0.12){ try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination); g.gain.value=0.12; o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, dur*1000); } catch(e){} }

/* initial UI */
buildMenu().catch(()=>{});
function showModal(m){ if(m) m.style.display='flex'; }
function hideModal(m){ if(m) m.style.display='none'; }

/* expose state for debugging */
window.__reiji_state = state;

/* End of script */
</script>
</body>
</html>
